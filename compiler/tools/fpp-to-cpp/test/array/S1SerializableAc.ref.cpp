// ======================================================================
// \title  S1SerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for S1 struct
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "S1SerializableAc.hpp"

namespace M {

  // ----------------------------------------------------------------------
  // Constructors
  // ----------------------------------------------------------------------

  S1 ::
    S1() :
      Serializable(),
      m_mF32(0.0f),
      m_mF64(0.0),
      m_mI16(0),
      m_mI32(0),
      m_mI64(0),
      m_mI8(0),
      m_mU16(0),
      m_mU32(0),
      m_mU64(0),
      m_mU8(0),
      m_mBool(false),
      m_mString(m___fprime_ac_mString_buffer, sizeof m___fprime_ac_mString_buffer, Fw::String(""))
  {

  }

  S1 ::
    S1(
        F32 mF32,
        F64 mF64,
        I16 mI16,
        I32 mI32,
        I64 mI64,
        I8 mI8,
        U16 mU16,
        U32 mU32,
        U64 mU64,
        U8 mU8,
        bool mBool,
        const Fw::StringBase& mString
    ) :
      Serializable(),
      m_mF32(mF32),
      m_mF64(mF64),
      m_mI16(mI16),
      m_mI32(mI32),
      m_mI64(mI64),
      m_mI8(mI8),
      m_mU16(mU16),
      m_mU32(mU32),
      m_mU64(mU64),
      m_mU8(mU8),
      m_mBool(mBool),
      m_mString(m___fprime_ac_mString_buffer, sizeof m___fprime_ac_mString_buffer, mString)
  {

  }

  S1 ::
    S1(const S1& obj) :
      Serializable(),
      m_mF32(obj.m_mF32),
      m_mF64(obj.m_mF64),
      m_mI16(obj.m_mI16),
      m_mI32(obj.m_mI32),
      m_mI64(obj.m_mI64),
      m_mI8(obj.m_mI8),
      m_mU16(obj.m_mU16),
      m_mU32(obj.m_mU32),
      m_mU64(obj.m_mU64),
      m_mU8(obj.m_mU8),
      m_mBool(obj.m_mBool),
      m_mString(m___fprime_ac_mString_buffer, sizeof m___fprime_ac_mString_buffer, obj.m_mString)
  {

  }

  // ----------------------------------------------------------------------
  // Operators
  // ----------------------------------------------------------------------

  S1& S1 ::
    operator=(const S1& obj)
  {
    if (this == &obj) {
      return *this;
    }

    set(obj.m_mF32, obj.m_mF64, obj.m_mI16, obj.m_mI32, obj.m_mI64, obj.m_mI8, obj.m_mU16, obj.m_mU32, obj.m_mU64, obj.m_mU8, obj.m_mBool, obj.m_mString);
    return *this;
  }

  bool S1 ::
    operator==(const S1& obj) const
  {
    if (this == &obj) { return true; }
    return (
      (this->m_mF32 == obj.m_mF32) &&
      (this->m_mF64 == obj.m_mF64) &&
      (this->m_mI16 == obj.m_mI16) &&
      (this->m_mI32 == obj.m_mI32) &&
      (this->m_mI64 == obj.m_mI64) &&
      (this->m_mI8 == obj.m_mI8) &&
      (this->m_mU16 == obj.m_mU16) &&
      (this->m_mU32 == obj.m_mU32) &&
      (this->m_mU64 == obj.m_mU64) &&
      (this->m_mU8 == obj.m_mU8) &&
      (this->m_mBool == obj.m_mBool) &&
      (this->m_mString == obj.m_mString)
    );
  }

  bool S1 ::
    operator!=(const S1& obj) const
  {
    return !(*this == obj);
  }

#ifdef BUILD_UT

  std::ostream& operator<<(std::ostream& os, const S1& obj) {
    Fw::String s;
    obj.toString(s);
    os << s.toChar();
    return os;
  }

#endif

  // ----------------------------------------------------------------------
  // Member functions
  // ----------------------------------------------------------------------

  Fw::SerializeStatus S1 ::
    serializeTo(
        Fw::SerializeBufferBase& buffer,
        Fw::Endianness mode
    ) const
  {
    Fw::SerializeStatus status;

    status = buffer.serializeFrom(this->m_mF32, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_mF64, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_mI16, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_mI32, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_mI64, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_mI8, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_mU16, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_mU32, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_mU64, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_mU8, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_mBool, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_mString, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

  Fw::SerializeStatus S1 ::
    deserializeFrom(
        Fw::SerializeBufferBase& buffer,
        Fw::Endianness mode
    )
  {
    Fw::SerializeStatus status;

    status = buffer.deserializeTo(this->m_mF32, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_mF64, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_mI16, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_mI32, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_mI64, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_mI8, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_mU16, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_mU32, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_mU64, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_mU8, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_mBool, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_mString, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

  FwSizeType S1 ::
    serializedSize() const
  {
    FwSizeType size = 0;
    size += sizeof(F32);
    size += sizeof(F64);
    size += sizeof(I16);
    size += sizeof(I32);
    size += sizeof(I64);
    size += sizeof(I8);
    size += sizeof(U16);
    size += sizeof(U32);
    size += sizeof(U64);
    size += sizeof(U8);
    size += sizeof(U8);
    size += this->m_mString.serializedSize();
    return size;
  }

#if FW_SERIALIZABLE_TO_STRING

  void S1 ::
    toString(Fw::StringBase& sb) const
  {
    Fw::String tmp;
    sb = "( ";

    // Format mF32
    sb += "mF32 = ";
    tmp.format("%f", static_cast<F64>(this->m_mF32));
    sb += tmp;
    sb += ", ";

    // Format mF64
    sb += "mF64 = ";
    tmp.format("%f", this->m_mF64);
    sb += tmp;
    sb += ", ";

    // Format mI16
    sb += "mI16 = ";
    tmp.format("%" PRIi16 "", this->m_mI16);
    sb += tmp;
    sb += ", ";

    // Format mI32
    sb += "mI32 = ";
    tmp.format("%" PRIi32 "", this->m_mI32);
    sb += tmp;
    sb += ", ";

    // Format mI64
    sb += "mI64 = ";
    tmp.format("%" PRIi64 "", this->m_mI64);
    sb += tmp;
    sb += ", ";

    // Format mI8
    sb += "mI8 = ";
    tmp.format("%" PRIi8 "", this->m_mI8);
    sb += tmp;
    sb += ", ";

    // Format mU16
    sb += "mU16 = ";
    tmp.format("%" PRIu16 "", this->m_mU16);
    sb += tmp;
    sb += ", ";

    // Format mU32
    sb += "mU32 = ";
    tmp.format("%" PRIu32 "", this->m_mU32);
    sb += tmp;
    sb += ", ";

    // Format mU64
    sb += "mU64 = ";
    tmp.format("%" PRIu64 "", this->m_mU64);
    sb += tmp;
    sb += ", ";

    // Format mU8
    sb += "mU8 = ";
    tmp.format("%" PRIu8 "", this->m_mU8);
    sb += tmp;
    sb += ", ";

    // Format mBool
    sb += "mBool = ";
    tmp.format("%d", this->m_mBool);
    sb += tmp;
    sb += ", ";

    // Format mString
    sb += "mString = ";
    sb += this->m_mString;
    sb += " )";
  }

#endif

  // ----------------------------------------------------------------------
  // Setter functions
  // ----------------------------------------------------------------------

  void S1 ::
    set(
        F32 mF32,
        F64 mF64,
        I16 mI16,
        I32 mI32,
        I64 mI64,
        I8 mI8,
        U16 mU16,
        U32 mU32,
        U64 mU64,
        U8 mU8,
        bool mBool,
        const Fw::StringBase& mString
    )
  {
    this->m_mF32 = mF32;
    this->m_mF64 = mF64;
    this->m_mI16 = mI16;
    this->m_mI32 = mI32;
    this->m_mI64 = mI64;
    this->m_mI8 = mI8;
    this->m_mU16 = mU16;
    this->m_mU32 = mU32;
    this->m_mU64 = mU64;
    this->m_mU8 = mU8;
    this->m_mBool = mBool;
    this->m_mString = mString;
  }

  void S1 ::
    set_mF32(F32 mF32)
  {
    this->m_mF32 = mF32;
  }

  void S1 ::
    set_mF64(F64 mF64)
  {
    this->m_mF64 = mF64;
  }

  void S1 ::
    set_mI16(I16 mI16)
  {
    this->m_mI16 = mI16;
  }

  void S1 ::
    set_mI32(I32 mI32)
  {
    this->m_mI32 = mI32;
  }

  void S1 ::
    set_mI64(I64 mI64)
  {
    this->m_mI64 = mI64;
  }

  void S1 ::
    set_mI8(I8 mI8)
  {
    this->m_mI8 = mI8;
  }

  void S1 ::
    set_mU16(U16 mU16)
  {
    this->m_mU16 = mU16;
  }

  void S1 ::
    set_mU32(U32 mU32)
  {
    this->m_mU32 = mU32;
  }

  void S1 ::
    set_mU64(U64 mU64)
  {
    this->m_mU64 = mU64;
  }

  void S1 ::
    set_mU8(U8 mU8)
  {
    this->m_mU8 = mU8;
  }

  void S1 ::
    set_mBool(bool mBool)
  {
    this->m_mBool = mBool;
  }

  void S1 ::
    set_mString(const Fw::StringBase& mString)
  {
    this->m_mString = mString;
  }

}
