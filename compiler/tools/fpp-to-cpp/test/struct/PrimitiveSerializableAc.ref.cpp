// ======================================================================
// \title  PrimitiveSerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for Primitive struct
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "PrimitiveSerializableAc.hpp"

// ----------------------------------------------------------------------
// Constructors
// ----------------------------------------------------------------------

Primitive ::
  Primitive() :
    Serializable(),
    m_mF64(0.0),
    m_mI16(0),
    m_mI32(0),
    m_mI64(0),
    m_mI8(0),
    m_mU16(0),
    m_mU32(0),
    m_mU64(0),
    m_mU8(0),
    m_m_bool(false),
    m_m_string(m___fprime_ac_m_string_buffer, sizeof m___fprime_ac_m_string_buffer, Fw::String(""))
{
  for (FwSizeType i = 0; i < 3; i++) {
    this->m_mF32[i] = 0.0f;
  }
}

Primitive ::
  Primitive(
      const Type_of_mF32& mF32,
      F64 mF64,
      I16 mI16,
      I32 mI32,
      I64 mI64,
      I8 mI8,
      U16 mU16,
      U32 mU32,
      U64 mU64,
      U8 mU8,
      bool m_bool,
      const Fw::StringBase& m_string
  ) :
    Serializable(),
    m_mF64(mF64),
    m_mI16(mI16),
    m_mI32(mI32),
    m_mI64(mI64),
    m_mI8(mI8),
    m_mU16(mU16),
    m_mU32(mU32),
    m_mU64(mU64),
    m_mU8(mU8),
    m_m_bool(m_bool),
    m_m_string(m___fprime_ac_m_string_buffer, sizeof m___fprime_ac_m_string_buffer, m_string)
{
  for (FwSizeType i = 0; i < 3; i++) {
    this->m_mF32[i] = mF32[i];
  }
}

Primitive ::
  Primitive(const Primitive& obj) :
    Serializable(),
    m_mF64(obj.m_mF64),
    m_mI16(obj.m_mI16),
    m_mI32(obj.m_mI32),
    m_mI64(obj.m_mI64),
    m_mI8(obj.m_mI8),
    m_mU16(obj.m_mU16),
    m_mU32(obj.m_mU32),
    m_mU64(obj.m_mU64),
    m_mU8(obj.m_mU8),
    m_m_bool(obj.m_m_bool),
    m_m_string(m___fprime_ac_m_string_buffer, sizeof m___fprime_ac_m_string_buffer, obj.m_m_string)
{
  for (FwSizeType i = 0; i < 3; i++) {
    this->m_mF32[i] = obj.m_mF32[i];
  }
}

Primitive ::
  Primitive(
      F32 mF32,
      F64 mF64,
      I16 mI16,
      I32 mI32,
      I64 mI64,
      I8 mI8,
      U16 mU16,
      U32 mU32,
      U64 mU64,
      U8 mU8,
      bool m_bool,
      const Fw::StringBase& m_string
  ) :
    Serializable(),
    m_mF64(mF64),
    m_mI16(mI16),
    m_mI32(mI32),
    m_mI64(mI64),
    m_mI8(mI8),
    m_mU16(mU16),
    m_mU32(mU32),
    m_mU64(mU64),
    m_mU8(mU8),
    m_m_bool(m_bool),
    m_m_string(m___fprime_ac_m_string_buffer, sizeof m___fprime_ac_m_string_buffer, m_string)
{
  for (FwSizeType i = 0; i < 3; i++) {
    this->m_mF32[i] = mF32;
  }
}

// ----------------------------------------------------------------------
// Operators
// ----------------------------------------------------------------------

Primitive& Primitive ::
  operator=(const Primitive& obj)
{
  if (this == &obj) {
    return *this;
  }

  set(obj.m_mF32, obj.m_mF64, obj.m_mI16, obj.m_mI32, obj.m_mI64, obj.m_mI8, obj.m_mU16, obj.m_mU32, obj.m_mU64, obj.m_mU8, obj.m_m_bool, obj.m_m_string);
  return *this;
}

bool Primitive ::
  operator==(const Primitive& obj) const
{
  // Compare non-array members
  if (!(
    (this->m_mF64 == obj.m_mF64) &&
    (this->m_mI16 == obj.m_mI16) &&
    (this->m_mI32 == obj.m_mI32) &&
    (this->m_mI64 == obj.m_mI64) &&
    (this->m_mI8 == obj.m_mI8) &&
    (this->m_mU16 == obj.m_mU16) &&
    (this->m_mU32 == obj.m_mU32) &&
    (this->m_mU64 == obj.m_mU64) &&
    (this->m_mU8 == obj.m_mU8) &&
    (this->m_m_bool == obj.m_m_bool) &&
    (this->m_m_string == obj.m_m_string)
  )) {
    return false;
  }

  // Compare array members
  if (!(this->m_mF32 == obj.m_mF32)) {
    for (FwSizeType i = 0; i < 3; i++) {
      if (!(this->m_mF32[i] == obj.m_mF32[i])) {
        return false;
      }
    }
  }

  return true;
}

bool Primitive ::
  operator!=(const Primitive& obj) const
{
  return !(*this == obj);
}

#ifdef BUILD_UT

std::ostream& operator<<(std::ostream& os, const Primitive& obj) {
  Fw::String s;
  obj.toString(s);
  os << s.toChar();
  return os;
}

#endif

// ----------------------------------------------------------------------
// Member functions
// ----------------------------------------------------------------------

Fw::SerializeStatus Primitive ::
  serialize(Fw::SerializeBufferBase& buffer) const
{
  Fw::SerializeStatus status;

  for (FwSizeType i = 0; i < 3; i++) {
    status = buffer.serialize(this->m_mF32[i]);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
  }
  status = buffer.serialize(this->m_mF64);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->m_mI16);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->m_mI32);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->m_mI64);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->m_mI8);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->m_mU16);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->m_mU32);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->m_mU64);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->m_mU8);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->m_m_bool);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->m_m_string);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }

  return status;
}

Fw::SerializeStatus Primitive ::
  deserialize(Fw::SerializeBufferBase& buffer)
{
  Fw::SerializeStatus status;

  for (FwSizeType i = 0; i < 3; i++) {
    status = buffer.deserialize(this->m_mF32[i]);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
  }
  status = buffer.deserialize(this->m_mF64);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->m_mI16);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->m_mI32);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->m_mI64);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->m_mI8);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->m_mU16);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->m_mU32);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->m_mU64);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->m_mU8);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->m_m_bool);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->m_m_string);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }

  return status;
}

#if FW_SERIALIZABLE_TO_STRING

void Primitive ::
  toString(Fw::StringBase& sb) const
{
  static const char* formatString =
    "( "
    "mF32 = [ %s ], "
    "mF64 = %f, "
    "mI16 = %" PRIi16 ", "
    "mI32 = %" PRIi32 ", "
    "mI64 = %" PRIi64 ", "
    "mI8 = %" PRIi8 ", "
    "mU16 = %" PRIu16 ", "
    "mU32 = %" PRIu32 ", "
    "mU64 = %" PRIu64 ", "
    "mU8 = %" PRIu8 ", "
    "m_bool = %d, "
    "m_string = %s"
    " )";

  // Declare strings to hold any serializable toString() arguments
  Fw::String mF32Str;

  // Call toString for arrays and serializable types
  for (FwSizeType i = 0; i < 3; i++) {
    Fw::String mF32Tmp;
    mF32Tmp.format("%f", static_cast<F64>(this->m_mF32[i]));

    FwSizeType size = mF32Tmp.length() + (i > 0 ? 2 : 0);
    FwSizeType remaining = mF32Str.maxLength() - mF32Str.length();
    if (size < remaining) {
      if (i > 0) {
        mF32Str += ", ";
      }
      mF32Str += mF32Tmp;
    } else {
      break;
    }
  }

  sb.format(
    formatString,
<<<<<<< HEAD
    this->m_mF32[0],
    this->m_mF32[1],
    this->m_mF32[2],
=======
    mF32Str.toChar(),
>>>>>>> 45295d17f (Generate loop for toString() on Struct member arrays)
    this->m_mF64,
    this->m_mI16,
    this->m_mI32,
    this->m_mI64,
    this->m_mI8,
    this->m_mU16,
    this->m_mU32,
    this->m_mU64,
    this->m_mU8,
    this->m_m_bool,
    this->m_m_string.toChar()
  );
}

#endif

// ----------------------------------------------------------------------
// Setter functions
// ----------------------------------------------------------------------

void Primitive ::
  set(
      const Type_of_mF32& mF32,
      F64 mF64,
      I16 mI16,
      I32 mI32,
      I64 mI64,
      I8 mI8,
      U16 mU16,
      U32 mU32,
      U64 mU64,
      U8 mU8,
      bool m_bool,
      const Fw::StringBase& m_string
  )
{
  this->m_mF64 = mF64;
  this->m_mI16 = mI16;
  this->m_mI32 = mI32;
  this->m_mI64 = mI64;
  this->m_mI8 = mI8;
  this->m_mU16 = mU16;
  this->m_mU32 = mU32;
  this->m_mU64 = mU64;
  this->m_mU8 = mU8;
  this->m_m_bool = m_bool;
  this->m_m_string = m_string;

  for (FwSizeType i = 0; i < 3; i++) {
    this->m_mF32[i] = mF32[i];
  }
}

void Primitive ::
  setmF32(const Type_of_mF32& mF32)
{
  for (FwSizeType i = 0; i < 3; i++) {
    this->m_mF32[i] = mF32[i];
  }
}

void Primitive ::
  setmF64(F64 mF64)
{
  this->m_mF64 = mF64;
}

void Primitive ::
  setmI16(I16 mI16)
{
  this->m_mI16 = mI16;
}

void Primitive ::
  setmI32(I32 mI32)
{
  this->m_mI32 = mI32;
}

void Primitive ::
  setmI64(I64 mI64)
{
  this->m_mI64 = mI64;
}

void Primitive ::
  setmI8(I8 mI8)
{
  this->m_mI8 = mI8;
}

void Primitive ::
  setmU16(U16 mU16)
{
  this->m_mU16 = mU16;
}

void Primitive ::
  setmU32(U32 mU32)
{
  this->m_mU32 = mU32;
}

void Primitive ::
  setmU64(U64 mU64)
{
  this->m_mU64 = mU64;
}

void Primitive ::
  setmU8(U8 mU8)
{
  this->m_mU8 = mU8;
}

void Primitive ::
  setm_bool(bool m_bool)
{
  this->m_m_bool = m_bool;
}

void Primitive ::
  setm_string(const Fw::StringBase& m_string)
{
  this->m_m_string = m_string;
}
