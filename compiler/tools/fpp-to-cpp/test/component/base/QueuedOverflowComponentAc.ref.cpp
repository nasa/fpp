// ======================================================================
// \title  QueuedOverflowComponentAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for QueuedOverflow component base class
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Fw/Types/ExternalString.hpp"
#if FW_ENABLE_TEXT_LOGGING
#include "Fw/Types/String.hpp"
#endif
#include "base/QueuedOverflowComponentAc.hpp"

namespace {
  enum MsgTypeEnum {
    QUEUEDOVERFLOW_COMPONENT_EXIT = Fw::ActiveComponentBase::ACTIVE_COMPONENT_EXIT,
    PRODUCTRECVINHOOK_DPRESPONSE,
    ASSERTASYNC_TYPED,
    BLOCKASYNC_TYPED,
    DROPASYNC_TYPED,
    HOOKASYNC_TYPED,
    SERIALASYNCHOOK_SERIAL,
    CMD_CMD_HOOK,
    CMD_CMD_PARAMS_PRIORITY_HOOK,
    INT_IF_INTERNALHOOKDROP,
  };

  // Get the max size by constructing a union of the async input, command, and
  // internal port serialization sizes
  union BuffUnion {
    BYTE productRecvInHookPortSize[Fw::InputDpResponsePort::SERIALIZED_SIZE];
    BYTE assertAsyncPortSize[Ports::InputTypedPort::SERIALIZED_SIZE];
    BYTE blockAsyncPortSize[Ports::InputTypedPort::SERIALIZED_SIZE];
    BYTE dropAsyncPortSize[Ports::InputTypedPort::SERIALIZED_SIZE];
    BYTE hookAsyncPortSize[Ports::InputTypedPort::SERIALIZED_SIZE];
    BYTE cmdPortSize[Fw::InputCmdPort::SERIALIZED_SIZE];
  };

  // Define a message buffer class large enough to handle all the
  // asynchronous inputs to the component
  class ComponentIpcSerializableBuffer :
    public Fw::SerializeBufferBase
  {

    public:

      enum {
        // Offset into data in buffer: Size of message ID and port number
        DATA_OFFSET = sizeof(FwEnumStoreType) + sizeof(FwIndexType),
        // Max data size
        MAX_DATA_SIZE = sizeof(BuffUnion),
        // Max message size: Size of message id + size of port + max data size
        SERIALIZATION_SIZE = DATA_OFFSET + MAX_DATA_SIZE
      };

      Fw::Serializable::SizeType getBuffCapacity() const {
        return sizeof(m_buff);
      }

      U8* getBuffAddr() {
        return m_buff;
      }

      const U8* getBuffAddr() const {
        return m_buff;
      }

    private:
      // Should be the max of all the input ports serialized sizes...
      U8 m_buff[SERIALIZATION_SIZE];

  };
}

// ----------------------------------------------------------------------
// Component initialization
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  init(
      FwSizeType queueDepth,
      FwSizeType msgSize,
      FwEnumStoreType instance
  )
{
  // Initialize base class
  Fw::QueuedComponentBase::init(instance);

  // Connect input port cmdIn
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_cmdIn_InputPorts());
    port++
  ) {
    this->m_cmdIn_InputPort[port].init();
    this->m_cmdIn_InputPort[port].addCallComp(
      this,
      m_p_cmdIn_in
    );
    this->m_cmdIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_cmdIn_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_cmdIn_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port productRecvInHook
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_productRecvInHook_InputPorts());
    port++
  ) {
    this->m_productRecvInHook_InputPort[port].init();
    this->m_productRecvInHook_InputPort[port].addCallComp(
      this,
      m_p_productRecvInHook_in
    );
    this->m_productRecvInHook_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_productRecvInHook_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_productRecvInHook_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port assertAsync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_assertAsync_InputPorts());
    port++
  ) {
    this->m_assertAsync_InputPort[port].init();
    this->m_assertAsync_InputPort[port].addCallComp(
      this,
      m_p_assertAsync_in
    );
    this->m_assertAsync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_assertAsync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_assertAsync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port blockAsync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_blockAsync_InputPorts());
    port++
  ) {
    this->m_blockAsync_InputPort[port].init();
    this->m_blockAsync_InputPort[port].addCallComp(
      this,
      m_p_blockAsync_in
    );
    this->m_blockAsync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_blockAsync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_blockAsync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port dropAsync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_dropAsync_InputPorts());
    port++
  ) {
    this->m_dropAsync_InputPort[port].init();
    this->m_dropAsync_InputPort[port].addCallComp(
      this,
      m_p_dropAsync_in
    );
    this->m_dropAsync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_dropAsync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_dropAsync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port hookAsync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_hookAsync_InputPorts());
    port++
  ) {
    this->m_hookAsync_InputPort[port].init();
    this->m_hookAsync_InputPort[port].addCallComp(
      this,
      m_p_hookAsync_in
    );
    this->m_hookAsync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_hookAsync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_hookAsync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port serialAsyncHook
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_serialAsyncHook_InputPorts());
    port++
  ) {
    this->m_serialAsyncHook_InputPort[port].init();
    this->m_serialAsyncHook_InputPort[port].addCallComp(
      this,
      m_p_serialAsyncHook_in
    );
    this->m_serialAsyncHook_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_serialAsyncHook_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_serialAsyncHook_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port cmdRegOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_cmdRegOut_OutputPorts());
    port++
  ) {
    this->m_cmdRegOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_cmdRegOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_cmdRegOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port cmdResponseOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_cmdResponseOut_OutputPorts());
    port++
  ) {
    this->m_cmdResponseOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_cmdResponseOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_cmdResponseOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port eventOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_eventOut_OutputPorts());
    port++
  ) {
    this->m_eventOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_eventOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_eventOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port prmGetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_prmGetOut_OutputPorts());
    port++
  ) {
    this->m_prmGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_prmGetOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_prmGetOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port prmSetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_prmSetOut_OutputPorts());
    port++
  ) {
    this->m_prmSetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_prmSetOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_prmSetOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

#if FW_ENABLE_TEXT_LOGGING == 1
  // Connect output port textEventOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_textEventOut_OutputPorts());
    port++
  ) {
    this->m_textEventOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_textEventOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_textEventOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }
#endif

  // Connect output port timeGetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_timeGetOut_OutputPorts());
    port++
  ) {
    this->m_timeGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_timeGetOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_timeGetOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port tlmOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_tlmOut_OutputPorts());
    port++
  ) {
    this->m_tlmOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_tlmOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_tlmOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Passed-in size added to port number and message type enumeration sizes.
  this->m_msgSize = FW_MAX(
    msgSize +
    static_cast<FwSizeType>(sizeof(FwIndexType)) +
    static_cast<FwSizeType>(sizeof(FwEnumStoreType)),
    static_cast<FwSizeType>(ComponentIpcSerializableBuffer::SERIALIZATION_SIZE)
  );

  // Create the queue
  Os::Queue::Status qStat = this->createQueue(queueDepth, this->m_msgSize);
  FW_ASSERT(
    Os::Queue::Status::OP_OK == qStat,
    static_cast<FwAssertArgType>(qStat)
  );
}

// ----------------------------------------------------------------------
// Getters for special input ports
// ----------------------------------------------------------------------

Fw::InputCmdPort* QueuedOverflowComponentBase ::
  get_cmdIn_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdIn_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_cmdIn_InputPort[portNum];
}

Fw::InputDpResponsePort* QueuedOverflowComponentBase ::
  get_productRecvInHook_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_productRecvInHook_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_productRecvInHook_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Getters for typed input ports
// ----------------------------------------------------------------------

Ports::InputTypedPort* QueuedOverflowComponentBase ::
  get_assertAsync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_assertAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_assertAsync_InputPort[portNum];
}

Ports::InputTypedPort* QueuedOverflowComponentBase ::
  get_blockAsync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_blockAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_blockAsync_InputPort[portNum];
}

Ports::InputTypedPort* QueuedOverflowComponentBase ::
  get_dropAsync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_dropAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_dropAsync_InputPort[portNum];
}

Ports::InputTypedPort* QueuedOverflowComponentBase ::
  get_hookAsync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_hookAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_hookAsync_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Getters for serial input ports
// ----------------------------------------------------------------------

Fw::InputSerializePort* QueuedOverflowComponentBase ::
  get_serialAsyncHook_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_serialAsyncHook_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_serialAsyncHook_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Connect input ports to special output ports
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  set_cmdRegOut_OutputPort(
      FwIndexType portNum,
      Fw::InputCmdRegPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdRegOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdRegOut_OutputPort[portNum].addCallPort(port);
}

void QueuedOverflowComponentBase ::
  set_cmdResponseOut_OutputPort(
      FwIndexType portNum,
      Fw::InputCmdResponsePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdResponseOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdResponseOut_OutputPort[portNum].addCallPort(port);
}

void QueuedOverflowComponentBase ::
  set_eventOut_OutputPort(
      FwIndexType portNum,
      Fw::InputLogPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_eventOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_eventOut_OutputPort[portNum].addCallPort(port);
}

void QueuedOverflowComponentBase ::
  set_prmGetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputPrmGetPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_prmGetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmGetOut_OutputPort[portNum].addCallPort(port);
}

void QueuedOverflowComponentBase ::
  set_prmSetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputPrmSetPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_prmSetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmSetOut_OutputPort[portNum].addCallPort(port);
}

#if FW_ENABLE_TEXT_LOGGING == 1

void QueuedOverflowComponentBase ::
  set_textEventOut_OutputPort(
      FwIndexType portNum,
      Fw::InputLogTextPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_textEventOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_textEventOut_OutputPort[portNum].addCallPort(port);
}

#endif

void QueuedOverflowComponentBase ::
  set_timeGetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputTimePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_timeGetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_timeGetOut_OutputPort[portNum].addCallPort(port);
}

void QueuedOverflowComponentBase ::
  set_tlmOut_OutputPort(
      FwIndexType portNum,
      Fw::InputTlmPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_tlmOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_tlmOut_OutputPort[portNum].addCallPort(port);
}

#if FW_PORT_SERIALIZATION

// ----------------------------------------------------------------------
// Connect serial input ports to special output ports
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  set_cmdRegOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdRegOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdRegOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedOverflowComponentBase ::
  set_cmdResponseOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdResponseOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdResponseOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedOverflowComponentBase ::
  set_eventOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_eventOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_eventOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedOverflowComponentBase ::
  set_prmSetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_prmSetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmSetOut_OutputPort[portNum].registerSerialPort(port);
}

#if FW_ENABLE_TEXT_LOGGING == 1

void QueuedOverflowComponentBase ::
  set_textEventOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_textEventOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_textEventOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

void QueuedOverflowComponentBase ::
  set_timeGetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_timeGetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_timeGetOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedOverflowComponentBase ::
  set_tlmOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_tlmOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_tlmOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

// ----------------------------------------------------------------------
// Command registration
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  regCommands()
{
  FW_ASSERT(this->m_cmdRegOut_OutputPort[0].isConnected());

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_HOOK
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_PARAMS_PRIORITY_HOOK
  );
}

// ----------------------------------------------------------------------
// Component construction and destruction
// ----------------------------------------------------------------------

QueuedOverflowComponentBase ::
  QueuedOverflowComponentBase(const char* compName) :
    Fw::QueuedComponentBase(compName)
{

}

QueuedOverflowComponentBase ::
  ~QueuedOverflowComponentBase()
{

}

// ----------------------------------------------------------------------
// Getters for numbers of special input ports
// ----------------------------------------------------------------------

FwIndexType QueuedOverflowComponentBase ::
  getNum_cmdIn_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdIn_InputPort));
}

FwIndexType QueuedOverflowComponentBase ::
  getNum_productRecvInHook_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_productRecvInHook_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of typed input ports
// ----------------------------------------------------------------------

FwIndexType QueuedOverflowComponentBase ::
  getNum_assertAsync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_assertAsync_InputPort));
}

FwIndexType QueuedOverflowComponentBase ::
  getNum_blockAsync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_blockAsync_InputPort));
}

FwIndexType QueuedOverflowComponentBase ::
  getNum_dropAsync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_dropAsync_InputPort));
}

FwIndexType QueuedOverflowComponentBase ::
  getNum_hookAsync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_hookAsync_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of serial input ports
// ----------------------------------------------------------------------

FwIndexType QueuedOverflowComponentBase ::
  getNum_serialAsyncHook_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_serialAsyncHook_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of special output ports
// ----------------------------------------------------------------------

FwIndexType QueuedOverflowComponentBase ::
  getNum_cmdRegOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdRegOut_OutputPort));
}

FwIndexType QueuedOverflowComponentBase ::
  getNum_cmdResponseOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdResponseOut_OutputPort));
}

FwIndexType QueuedOverflowComponentBase ::
  getNum_eventOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_eventOut_OutputPort));
}

FwIndexType QueuedOverflowComponentBase ::
  getNum_prmGetOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_prmGetOut_OutputPort));
}

FwIndexType QueuedOverflowComponentBase ::
  getNum_prmSetOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_prmSetOut_OutputPort));
}

#if FW_ENABLE_TEXT_LOGGING == 1

FwIndexType QueuedOverflowComponentBase ::
  getNum_textEventOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_textEventOut_OutputPort));
}

#endif

FwIndexType QueuedOverflowComponentBase ::
  getNum_timeGetOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_timeGetOut_OutputPort));
}

FwIndexType QueuedOverflowComponentBase ::
  getNum_tlmOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_tlmOut_OutputPort));
}

// ----------------------------------------------------------------------
// Connection status queries for special output ports
// ----------------------------------------------------------------------

bool QueuedOverflowComponentBase ::
  isConnected_cmdRegOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdRegOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_cmdRegOut_OutputPort[portNum].isConnected();
}

bool QueuedOverflowComponentBase ::
  isConnected_cmdResponseOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdResponseOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_cmdResponseOut_OutputPort[portNum].isConnected();
}

bool QueuedOverflowComponentBase ::
  isConnected_eventOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_eventOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_eventOut_OutputPort[portNum].isConnected();
}

bool QueuedOverflowComponentBase ::
  isConnected_prmGetOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_prmGetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_prmGetOut_OutputPort[portNum].isConnected();
}

bool QueuedOverflowComponentBase ::
  isConnected_prmSetOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_prmSetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_prmSetOut_OutputPort[portNum].isConnected();
}

#if FW_ENABLE_TEXT_LOGGING == 1

bool QueuedOverflowComponentBase ::
  isConnected_textEventOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_textEventOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_textEventOut_OutputPort[portNum].isConnected();
}

#endif

bool QueuedOverflowComponentBase ::
  isConnected_timeGetOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_timeGetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_timeGetOut_OutputPort[portNum].isConnected();
}

bool QueuedOverflowComponentBase ::
  isConnected_tlmOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_tlmOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_tlmOut_OutputPort[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Port handler base-class functions for special input ports
//
// Call these functions directly to bypass the corresponding ports
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  productRecvInHook_handlerBase(
      FwIndexType portNum,
      FwDpIdType id,
      const Fw::Buffer& buffer,
      const Fw::Success& status
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_productRecvInHook_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  productRecvInHook_preMsgHook(
    portNum,
    id,
    buffer,
    status
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serializeFrom(
    static_cast<FwEnumStoreType>(PRODUCTRECVINHOOK_DPRESPONSE)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serializeFrom(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument id
  _status = msg.serializeFrom(id);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument buffer
  _status = msg.serializeFrom(buffer);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument status
  _status = msg.serializeFrom(status);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  if (qStatus == Os::Queue::Status::FULL) {
    this->productRecvInHook_overflowHook(portNum, id, buffer, status);
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

// ----------------------------------------------------------------------
// Port handler base-class functions for typed input ports
//
// Call these functions directly to bypass the corresponding ports
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  assertAsync_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_assertAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  assertAsync_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serializeFrom(
    static_cast<FwEnumStoreType>(ASSERTASYNC_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serializeFrom(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serializeFrom(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serializeFrom(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serializeFrom(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str1
  _status = str1.serializeTo(msg, 80);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serializeFrom(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serializeFrom(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serializeFrom(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedOverflowComponentBase ::
  blockAsync_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_blockAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  blockAsync_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serializeFrom(
    static_cast<FwEnumStoreType>(BLOCKASYNC_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serializeFrom(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serializeFrom(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serializeFrom(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serializeFrom(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str1
  _status = str1.serializeTo(msg, 80);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serializeFrom(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serializeFrom(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serializeFrom(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::BLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedOverflowComponentBase ::
  dropAsync_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_dropAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  dropAsync_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serializeFrom(
    static_cast<FwEnumStoreType>(DROPASYNC_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serializeFrom(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serializeFrom(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serializeFrom(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serializeFrom(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str1
  _status = str1.serializeTo(msg, 80);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serializeFrom(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serializeFrom(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serializeFrom(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  if (qStatus == Os::Queue::Status::FULL) {
    this->incNumMsgDropped();
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedOverflowComponentBase ::
  hookAsync_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_hookAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  hookAsync_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serializeFrom(
    static_cast<FwEnumStoreType>(HOOKASYNC_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serializeFrom(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serializeFrom(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serializeFrom(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serializeFrom(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str1
  _status = str1.serializeTo(msg, 80);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serializeFrom(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serializeFrom(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serializeFrom(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  if (qStatus == Os::Queue::Status::FULL) {
    this->hookAsync_overflowHook(portNum, u32, f32, b, str1, e, a, s);
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

// ----------------------------------------------------------------------
// Port handler base-class functions for serial input ports
//
// Call these functions directly to bypass the corresponding ports
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  serialAsyncHook_handlerBase(
      FwIndexType portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_serialAsyncHook_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Declare buffer for serialAsyncHook
  U8 msgBuff[this->m_msgSize];
  Fw::ExternalSerializeBuffer msgSerBuff(
    msgBuff,
    static_cast<Fw::Serializable::SizeType>(this->m_msgSize)
  );
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msgSerBuff.serializeFrom(
    static_cast<FwEnumStoreType>(SERIALASYNCHOOK_SERIAL)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msgSerBuff.serializeFrom(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument buffer
  _status = msgSerBuff.serializeFrom(buffer);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msgSerBuff, 0, _block);

  if (qStatus == Os::Queue::Status::FULL) {
    this->serialAsyncHook_overflowHook(portNum, buffer);
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

// ----------------------------------------------------------------------
// Pre-message hooks for special async input ports
//
// Each of these functions is invoked just before processing a message
// on the corresponding port. By default, they do nothing. You can
// override them to provide specific pre-message behavior.
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  productRecvInHook_preMsgHook(
      FwIndexType portNum,
      FwDpIdType id,
      const Fw::Buffer& buffer,
      const Fw::Success& status
  )
{
  // Default: no-op
}

// ----------------------------------------------------------------------
// Pre-message hooks for typed async input ports
//
// Each of these functions is invoked just before processing a message
// on the corresponding port. By default, they do nothing. You can
// override them to provide specific pre-message behavior.
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  assertAsync_preMsgHook(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

void QueuedOverflowComponentBase ::
  blockAsync_preMsgHook(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

void QueuedOverflowComponentBase ::
  dropAsync_preMsgHook(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

void QueuedOverflowComponentBase ::
  hookAsync_preMsgHook(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

// ----------------------------------------------------------------------
// Pre-message hooks for serial async input ports
//
// Each of these functions is invoked just before processing a message
// on the corresponding port. By default, they do nothing. You can
// override them to provide specific pre-message behavior.
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  serialAsyncHook_preMsgHook(
      FwIndexType portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Default: no-op
}

// ----------------------------------------------------------------------
// Hooks for internal ports
//
// Each of these functions is invoked just before dropping a message
// on the corresponding internal port. You should override them to provide
// specific drop behavior.
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
// Internal interface base-class functions
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  internalHookDrop_internalInterfaceInvoke()
{
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize the message ID
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_INTERNALHOOKDROP));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  _status = msg.serializeFrom(static_cast<FwIndexType>(0));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  if (qStatus == Os::Queue::Status::FULL) {
    this->internalHookDrop_overflowHook();
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

// ----------------------------------------------------------------------
// Command response
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  cmdResponse_out(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdResponse response
  )
{
  FW_ASSERT(this->m_cmdResponseOut_OutputPort[0].isConnected());
  this->m_cmdResponseOut_OutputPort[0].invoke(opCode, cmdSeq, response);
}

// ----------------------------------------------------------------------
// Command handler base-class functions
//
// Call these functions directly to bypass the command input port
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  CMD_HOOK_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Call pre-message hook
  this->CMD_HOOK_preMsgHook(opCode,cmdSeq);

  // Defer deserializing arguments to the message dispatcher
  // to avoid deserializing and reserializing just for IPC
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize for IPC
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_CMD_HOOK));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  FwIndexType port = 0;

  _status = msg.serializeFrom(port);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(opCode);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(cmdSeq);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(args);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  if (qStatus == Os::Queue::Status::FULL) {
    this->CMD_HOOK_cmdOverflowHook(opCode, cmdSeq);
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedOverflowComponentBase ::
  CMD_PARAMS_PRIORITY_HOOK_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Call pre-message hook
  this->CMD_PARAMS_PRIORITY_HOOK_preMsgHook(opCode,cmdSeq);

  // Defer deserializing arguments to the message dispatcher
  // to avoid deserializing and reserializing just for IPC
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize for IPC
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_CMD_PARAMS_PRIORITY_HOOK));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  FwIndexType port = 0;

  _status = msg.serializeFrom(port);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(opCode);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(cmdSeq);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(args);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 30, _block);

  if (qStatus == Os::Queue::Status::FULL) {
    this->CMD_PARAMS_PRIORITY_HOOK_cmdOverflowHook(opCode, cmdSeq);
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

// ----------------------------------------------------------------------
// Pre-message hooks for async commands
//
// Each of these functions is invoked just before processing the
// corresponding command. By default they do nothing. You can
// override them to provide specific pre-command behavior.
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  CMD_HOOK_preMsgHook(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{
  // Defaults to no-op; can be overridden
  (void) opCode;
  (void) cmdSeq;
}

void QueuedOverflowComponentBase ::
  CMD_PARAMS_PRIORITY_HOOK_preMsgHook(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{
  // Defaults to no-op; can be overridden
  (void) opCode;
  (void) cmdSeq;
}

// ----------------------------------------------------------------------
// Time
// ----------------------------------------------------------------------

Fw::Time QueuedOverflowComponentBase ::
  getTime() const
{
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    Fw::Time _time;
    this->m_timeGetOut_OutputPort[0].invoke(_time);
    return _time;
  }
  else {
    return Fw::Time(TimeBase::TB_NONE, 0, 0);
  }
}

// ----------------------------------------------------------------------
// Message dispatch functions
// ----------------------------------------------------------------------

Fw::QueuedComponentBase::MsgDispatchStatus QueuedOverflowComponentBase ::
  doDispatch()
{
  U8 _msgBuff[this->m_msgSize];
  Fw::ExternalSerializeBuffer _msg(
    _msgBuff,
    static_cast<Fw::Serializable::SizeType>(this->m_msgSize)
  );
  FwQueuePriorityType _priority = 0;

  Os::Queue::Status _msgStatus = this->m_queue.receive(
    _msg,
    Os::Queue::NONBLOCKING,
    _priority
  );
  if (Os::Queue::Status::EMPTY == _msgStatus) {
    return Fw::QueuedComponentBase::MSG_DISPATCH_EMPTY;
  }
  else {
    FW_ASSERT(
      _msgStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(_msgStatus)
    );
  }

  // Reset to beginning of buffer
  _msg.resetDeser();

  FwEnumStoreType _desMsg = 0;
  Fw::SerializeStatus _deserStatus = _msg.deserializeTo(_desMsg);
  FW_ASSERT(
    _deserStatus == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_deserStatus)
  );

  MsgTypeEnum _msgType = static_cast<MsgTypeEnum>(_desMsg);

  if (_msgType == QUEUEDOVERFLOW_COMPONENT_EXIT) {
    return MSG_DISPATCH_EXIT;
  }

  FwIndexType portNum = 0;
  _deserStatus = _msg.deserializeTo(portNum);
  FW_ASSERT(
    _deserStatus == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_deserStatus)
  );

  switch (_msgType) {
    // Handle async input port productRecvInHook
    case PRODUCTRECVINHOOK_DPRESPONSE: {
      // Deserialize argument id
      FwDpIdType id;
      _deserStatus = _msg.deserializeTo(id);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument buffer
      Fw::Buffer buffer;
      _deserStatus = _msg.deserializeTo(buffer);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument status
      Fw::Success status;
      _deserStatus = _msg.deserializeTo(status);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );
      // Call handler function
      this->productRecvInHook_handler(
        portNum,
        id,
        buffer,
        status
      );

      break;
    }

    // Handle async input port assertAsync
    case ASSERTASYNC_TYPED: {
      // Deserialize argument u32
      U32 u32;
      _deserStatus = _msg.deserializeTo(u32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      _deserStatus = _msg.deserializeTo(f32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument b
      bool b;
      _deserStatus = _msg.deserializeTo(b);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument str1
      char __fprime_ac_str1_buffer[Fw::StringBase::BUFFER_SIZE(80)];
      Fw::ExternalString str1(__fprime_ac_str1_buffer, sizeof __fprime_ac_str1_buffer);
      _deserStatus = _msg.deserializeTo(str1);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument e
      E e;
      _deserStatus = _msg.deserializeTo(e);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument a
      A a;
      _deserStatus = _msg.deserializeTo(a);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument s
      S s;
      _deserStatus = _msg.deserializeTo(s);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );
      // Call handler function
      this->assertAsync_handler(
        portNum,
        u32,
        f32,
        b,
        str1,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port blockAsync
    case BLOCKASYNC_TYPED: {
      // Deserialize argument u32
      U32 u32;
      _deserStatus = _msg.deserializeTo(u32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      _deserStatus = _msg.deserializeTo(f32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument b
      bool b;
      _deserStatus = _msg.deserializeTo(b);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument str1
      char __fprime_ac_str1_buffer[Fw::StringBase::BUFFER_SIZE(80)];
      Fw::ExternalString str1(__fprime_ac_str1_buffer, sizeof __fprime_ac_str1_buffer);
      _deserStatus = _msg.deserializeTo(str1);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument e
      E e;
      _deserStatus = _msg.deserializeTo(e);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument a
      A a;
      _deserStatus = _msg.deserializeTo(a);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument s
      S s;
      _deserStatus = _msg.deserializeTo(s);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );
      // Call handler function
      this->blockAsync_handler(
        portNum,
        u32,
        f32,
        b,
        str1,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port dropAsync
    case DROPASYNC_TYPED: {
      // Deserialize argument u32
      U32 u32;
      _deserStatus = _msg.deserializeTo(u32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      _deserStatus = _msg.deserializeTo(f32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument b
      bool b;
      _deserStatus = _msg.deserializeTo(b);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument str1
      char __fprime_ac_str1_buffer[Fw::StringBase::BUFFER_SIZE(80)];
      Fw::ExternalString str1(__fprime_ac_str1_buffer, sizeof __fprime_ac_str1_buffer);
      _deserStatus = _msg.deserializeTo(str1);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument e
      E e;
      _deserStatus = _msg.deserializeTo(e);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument a
      A a;
      _deserStatus = _msg.deserializeTo(a);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument s
      S s;
      _deserStatus = _msg.deserializeTo(s);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );
      // Call handler function
      this->dropAsync_handler(
        portNum,
        u32,
        f32,
        b,
        str1,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port hookAsync
    case HOOKASYNC_TYPED: {
      // Deserialize argument u32
      U32 u32;
      _deserStatus = _msg.deserializeTo(u32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      _deserStatus = _msg.deserializeTo(f32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument b
      bool b;
      _deserStatus = _msg.deserializeTo(b);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument str1
      char __fprime_ac_str1_buffer[Fw::StringBase::BUFFER_SIZE(80)];
      Fw::ExternalString str1(__fprime_ac_str1_buffer, sizeof __fprime_ac_str1_buffer);
      _deserStatus = _msg.deserializeTo(str1);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument e
      E e;
      _deserStatus = _msg.deserializeTo(e);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument a
      A a;
      _deserStatus = _msg.deserializeTo(a);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument s
      S s;
      _deserStatus = _msg.deserializeTo(s);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );
      // Call handler function
      this->hookAsync_handler(
        portNum,
        u32,
        f32,
        b,
        str1,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port serialAsyncHook
    case SERIALASYNCHOOK_SERIAL: {
      // Deserialize serialized buffer into new buffer
      U8 handBuff[this->m_msgSize];
      Fw::ExternalSerializeBuffer serHandBuff(
        handBuff,
        static_cast<Fw::Serializable::SizeType>(this->m_msgSize)
      );
      _deserStatus = _msg.deserializeTo(serHandBuff);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );
      this->serialAsyncHook_handler(portNum, serHandBuff);

      break;
    }

    // Handle command CMD_HOOK
    case CMD_CMD_HOOK: {
      // Deserialize opcode
      FwOpcodeType _opCode = 0;
      _deserStatus = _msg.deserializeTo(_opCode);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command sequence
      U32 _cmdSeq = 0;
      _deserStatus = _msg.deserializeTo(_cmdSeq);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command argument buffer
      Fw::CmdArgBuffer args;
      _deserStatus = _msg.deserializeTo(args);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Reset buffer
      args.resetDeser();

      // Make sure there was no data left over.
      // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
      if (args.getBuffLeft() != 0) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }
#endif

      // Call handler function
      this->CMD_HOOK_cmdHandler(_opCode, _cmdSeq);

      break;
    }

    // Handle command CMD_PARAMS_PRIORITY_HOOK
    case CMD_CMD_PARAMS_PRIORITY_HOOK: {
      // Deserialize opcode
      FwOpcodeType _opCode = 0;
      _deserStatus = _msg.deserializeTo(_opCode);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command sequence
      U32 _cmdSeq = 0;
      _deserStatus = _msg.deserializeTo(_cmdSeq);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command argument buffer
      Fw::CmdArgBuffer args;
      _deserStatus = _msg.deserializeTo(args);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Reset buffer
      args.resetDeser();

      // Deserialize argument u32
      U32 u32;
      _deserStatus = args.deserializeTo(u32);
      if (_deserStatus != Fw::FW_SERIALIZE_OK) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(
              _opCode,
              _cmdSeq,
              Fw::CmdResponse::FORMAT_ERROR
          );
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }

      // Make sure there was no data left over.
      // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
      if (args.getBuffLeft() != 0) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }
#endif

      // Call handler function
      this->CMD_PARAMS_PRIORITY_HOOK_cmdHandler(
        _opCode, _cmdSeq,
        u32
      );

      break;
    }

    // Handle internal interface internalHookDrop
    case INT_IF_INTERNALHOOKDROP: {
      // Make sure there was no data left over.
      // That means the buffer size was incorrect.
      FW_ASSERT(
        _msg.getBuffLeft() == 0,
        static_cast<FwAssertArgType>(_msg.getBuffLeft())
      );

      // Call handler function
      this->internalHookDrop_internalInterfaceHandler();

      break;
    }

    default:
      return MSG_DISPATCH_ERROR;
  }

  return MSG_DISPATCH_OK;
}

// ----------------------------------------------------------------------
// Helper functions for dispatching current messages
// ----------------------------------------------------------------------

Fw::QueuedComponentBase::MsgDispatchStatus QueuedOverflowComponentBase ::
  dispatchCurrentMessages()
{
  // Dispatch all current messages unless ERROR or EXIT occur
  const FwSizeType currentMessageCount = this->m_queue.getMessagesAvailable();
  MsgDispatchStatus messageStatus = MsgDispatchStatus::MSG_DISPATCH_EMPTY;
  for (FwSizeType i = 0; i < currentMessageCount; i++) {
    messageStatus = this->doDispatch();
    if (messageStatus != QueuedComponentBase::MSG_DISPATCH_OK) {
      break;
    }
  }
  return messageStatus;
}

// ----------------------------------------------------------------------
// Calls for messages received on special input ports
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  m_p_cmdIn_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  FW_ASSERT(callComp);
  QueuedOverflowComponentBase* compPtr = static_cast<QueuedOverflowComponentBase*>(callComp);

  const U32 idBase = callComp->getIdBase();
  FW_ASSERT(opCode >= idBase, static_cast<FwAssertArgType>(opCode), static_cast<FwAssertArgType>(idBase));

  // Select base class function based on opcode
  switch (opCode - idBase) {
    case OPCODE_CMD_HOOK: {
      compPtr->CMD_HOOK_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_PARAMS_PRIORITY_HOOK: {
      compPtr->CMD_PARAMS_PRIORITY_HOOK_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }
  }
}

void QueuedOverflowComponentBase ::
  m_p_productRecvInHook_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      FwDpIdType id,
      const Fw::Buffer& buffer,
      const Fw::Success& status
  )
{
  FW_ASSERT(callComp);
  QueuedOverflowComponentBase* compPtr = static_cast<QueuedOverflowComponentBase*>(callComp);
  compPtr->productRecvInHook_handlerBase(
    portNum,
    id,
    buffer,
    status
  );
}

// ----------------------------------------------------------------------
// Calls for messages received on typed input ports
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  m_p_assertAsync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedOverflowComponentBase* compPtr = static_cast<QueuedOverflowComponentBase*>(callComp);
  compPtr->assertAsync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedOverflowComponentBase ::
  m_p_blockAsync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedOverflowComponentBase* compPtr = static_cast<QueuedOverflowComponentBase*>(callComp);
  compPtr->blockAsync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedOverflowComponentBase ::
  m_p_dropAsync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedOverflowComponentBase* compPtr = static_cast<QueuedOverflowComponentBase*>(callComp);
  compPtr->dropAsync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedOverflowComponentBase ::
  m_p_hookAsync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedOverflowComponentBase* compPtr = static_cast<QueuedOverflowComponentBase*>(callComp);
  compPtr->hookAsync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Calls for messages received on serial input ports
// ----------------------------------------------------------------------

#if FW_PORT_SERIALIZATION

void QueuedOverflowComponentBase ::
  m_p_serialAsyncHook_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  FW_ASSERT(callComp);
  QueuedOverflowComponentBase* compPtr = static_cast<QueuedOverflowComponentBase*>(callComp);
  compPtr->serialAsyncHook_handlerBase(
    portNum,
    buffer
  );
}

#endif

// ----------------------------------------------------------------------
// Private data product handling functions
// ----------------------------------------------------------------------

void QueuedOverflowComponentBase ::
  productRecvInHook_handler(
      const FwIndexType portNum,
      FwDpIdType id,
      const Fw::Buffer& buffer,
      const Fw::Success& status
  )
{
  (void) portNum;
  (void) id;
  (void) buffer;
  (void) status;
  // No data products defined
}
