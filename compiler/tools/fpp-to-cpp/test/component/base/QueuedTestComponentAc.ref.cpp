// ======================================================================
// \title  QueuedTestComponentAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for QueuedTest component base class
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Fw/Types/ExternalString.hpp"
#if FW_ENABLE_TEXT_LOGGING
#include "Fw/Types/String.hpp"
#endif
#include "base/QueuedTestComponentAc.hpp"

namespace {
  enum MsgTypeEnum {
    QUEUEDTEST_COMPONENT_EXIT = Fw::ActiveComponentBase::ACTIVE_COMPONENT_EXIT,
    PRODUCTRECVIN_DPRESPONSE,
    ALIASTYPEDASYNC_ALIASTYPED,
    NOARGSASYNC_NOARGS,
    TYPEDASYNC_TYPED,
    TYPEDASYNCASSERT_TYPED,
    TYPEDASYNCBLOCKPRIORITY_TYPED,
    TYPEDASYNCDROPPRIORITY_TYPED,
    CMD_CMD_ASYNC,
    CMD_CMD_PRIORITY,
    CMD_CMD_PARAMS_PRIORITY,
    CMD_CMD_DROP,
    CMD_CMD_PARAMS_PRIORITY_DROP,
    INT_IF_INTERNALARRAY,
    INT_IF_INTERNALENUM,
    INT_IF_INTERNALPRIMITIVE,
    INT_IF_INTERNALPRIORITYDROP,
    INT_IF_INTERNALSTRING,
    INT_IF_INTERNALSTRUCT,
  };

  // Get the max size by constructing a union of the async input, command, and
  // internal port serialization sizes
  union BuffUnion {
    BYTE productRecvInPortSize[Fw::InputDpResponsePort::SERIALIZED_SIZE];
    BYTE aliasTypedAsyncPortSize[Ports::InputAliasTypedPort::SERIALIZED_SIZE];
    BYTE typedAsyncPortSize[Ports::InputTypedPort::SERIALIZED_SIZE];
    BYTE typedAsyncAssertPortSize[Ports::InputTypedPort::SERIALIZED_SIZE];
    BYTE typedAsyncBlockPriorityPortSize[Ports::InputTypedPort::SERIALIZED_SIZE];
    BYTE typedAsyncDropPriorityPortSize[Ports::InputTypedPort::SERIALIZED_SIZE];
    BYTE cmdPortSize[Fw::InputCmdPort::SERIALIZED_SIZE];
    // Size of internalArray argument list
    BYTE internalArrayIntIfSize[
      A::SERIALIZED_SIZE
    ];
    // Size of internalEnum argument list
    BYTE internalEnumIntIfSize[
      E::SERIALIZED_SIZE
    ];
    // Size of internalPrimitive argument list
    BYTE internalPrimitiveIntIfSize[
      sizeof(U32) +
      sizeof(F32) +
      sizeof(U8)
    ];
    // Size of internalString argument list
    BYTE internalStringIntIfSize[
      Fw::InternalInterfaceString::SERIALIZED_SIZE +
      Fw::InternalInterfaceString::SERIALIZED_SIZE
    ];
    // Size of internalStruct argument list
    BYTE internalStructIntIfSize[
      S::SERIALIZED_SIZE
    ];
  };

  // Define a message buffer class large enough to handle all the
  // asynchronous inputs to the component
  class ComponentIpcSerializableBuffer :
    public Fw::SerializeBufferBase
  {

    public:

      enum {
        // Offset into data in buffer: Size of message ID and port number
        DATA_OFFSET = sizeof(FwEnumStoreType) + sizeof(FwIndexType),
        // Max data size
        MAX_DATA_SIZE = sizeof(BuffUnion),
        // Max message size: Size of message id + size of port + max data size
        SERIALIZATION_SIZE = DATA_OFFSET + MAX_DATA_SIZE
      };

      Fw::Serializable::SizeType getBuffCapacity() const {
        return sizeof(m_buff);
      }

      U8* getBuffAddr() {
        return m_buff;
      }

      const U8* getBuffAddr() const {
        return m_buff;
      }

    private:
      // Should be the max of all the input ports serialized sizes...
      U8 m_buff[SERIALIZATION_SIZE];

  };
}

// ----------------------------------------------------------------------
// Types for data products
// ----------------------------------------------------------------------

QueuedTestComponentBase::DpContainer ::
  DpContainer(
      FwDpIdType id,
      const Fw::Buffer& buffer,
      FwDpIdType baseId
  ) :
    Fw::DpContainer(id, buffer),
    m_baseId(baseId)
{

}

QueuedTestComponentBase::DpContainer ::
  DpContainer() :
    Fw::DpContainer(),
    m_baseId(0)
{

}

Fw::SerializeStatus QueuedTestComponentBase::DpContainer ::
  serializeRecord_DataArrayRecord(
      const QueuedTest_Data* array,
      FwSizeType size
  )
{
  FW_ASSERT(array != nullptr);
  // Compute the size delta
  FwSizeType sizeDelta =
    sizeof(FwDpIdType) + sizeof(FwSizeStoreType);
  for (FwSizeType i = 0; i < size; i++) {
    sizeDelta += array[i].serializedSize();
  }
  // Serialize the elements if they will fit
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if ((this->m_dataBuffer.getBuffLength() + sizeDelta) <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::DataArrayRecord;
    status = this->m_dataBuffer.serializeFrom(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serializeSize(size);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    for (FwSizeType i = 0; i < size; i++) {
      status = this->m_dataBuffer.serializeFrom(array[i]);
      FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    }
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

Fw::SerializeStatus QueuedTestComponentBase::DpContainer ::
  serializeRecord_DataRecord(const QueuedTest_Data& elt)
{
  const FwSizeType sizeDelta =
    sizeof(FwDpIdType) +
    elt.serializedSize();
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if (this->m_dataBuffer.getBuffLength() + sizeDelta <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::DataRecord;
    status = this->m_dataBuffer.serializeFrom(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serializeFrom(elt);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

Fw::SerializeStatus QueuedTestComponentBase::DpContainer ::
  serializeRecord_StringArrayRecord(
      const Fw::StringBase** array,
      FwSizeType size
  )
{
  FW_ASSERT(array != nullptr);
  // Compute the size delta
  const FwSizeType stringSize = 80;
  FwSizeType sizeDelta =
    sizeof(FwDpIdType) +
    sizeof(FwSizeStoreType);
  for (FwSizeType i = 0; i < size; i++) {
    const Fw::StringBase *const sbPtr = array[i];
    FW_ASSERT(sbPtr != nullptr);
    sizeDelta += sbPtr->serializedTruncatedSize(stringSize);
  }
  // Serialize the elements if they will fit
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if ((this->m_dataBuffer.getBuffLength() + sizeDelta) <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::StringArrayRecord;
    status = this->m_dataBuffer.serializeFrom(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serializeSize(size);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    for (FwSizeType i = 0; i < size; i++) {
      const Fw::StringBase *const sbPtr = array[i];
      FW_ASSERT(sbPtr != nullptr);
      status = sbPtr->serializeTo(this->m_dataBuffer, stringSize);
      FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    }
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

Fw::SerializeStatus QueuedTestComponentBase::DpContainer ::
  serializeRecord_StringRecord(const Fw::StringBase& elt)
{
  const FwSizeType stringSize = 80;
  const FwSizeType sizeDelta =
    sizeof(FwDpIdType) +
    elt.serializedTruncatedSize(stringSize);
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if (this->m_dataBuffer.getBuffLength() + sizeDelta <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::StringRecord;
    status = this->m_dataBuffer.serializeFrom(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = elt.serializeTo(this->m_dataBuffer, stringSize);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

Fw::SerializeStatus QueuedTestComponentBase::DpContainer ::
  serializeRecord_U32ArrayRecord(
      const U32* array,
      FwSizeType size
  )
{
  FW_ASSERT(array != nullptr);
  // Compute the size delta
  const FwSizeType sizeDelta =
    sizeof(FwDpIdType) +
    sizeof(FwSizeStoreType) +
    size * sizeof(U32);
  // Serialize the elements if they will fit
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if ((this->m_dataBuffer.getBuffLength() + sizeDelta) <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::U32ArrayRecord;
    status = this->m_dataBuffer.serializeFrom(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serializeSize(size);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    for (FwSizeType i = 0; i < size; i++) {
      status = this->m_dataBuffer.serializeFrom(array[i]);
      FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    }
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

Fw::SerializeStatus QueuedTestComponentBase::DpContainer ::
  serializeRecord_U32Record(U32 elt)
{
  const FwSizeType sizeDelta =
    sizeof(FwDpIdType) +
    sizeof(U32);
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if (this->m_dataBuffer.getBuffLength() + sizeDelta <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::U32Record;
    status = this->m_dataBuffer.serializeFrom(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serializeFrom(elt);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

Fw::SerializeStatus QueuedTestComponentBase::DpContainer ::
  serializeRecord_U8ArrayRecord(
      const U8* array,
      FwSizeType size
  )
{
  FW_ASSERT(array != nullptr);
  // Compute the size delta
  const FwSizeType sizeDelta =
    sizeof(FwDpIdType) +
    sizeof(FwSizeStoreType) +
    size * sizeof(U8);
  // Serialize the elements if they will fit
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if ((this->m_dataBuffer.getBuffLength() + sizeDelta) <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::U8ArrayRecord;
    status = this->m_dataBuffer.serializeFrom(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serializeSize(size);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serializeFrom(array, size, Fw::Serialization::OMIT_LENGTH);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

// ----------------------------------------------------------------------
// Component initialization
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  init(
      FwSizeType queueDepth,
      FwEnumStoreType instance
  )
{
  // Initialize base class
  Fw::QueuedComponentBase::init(instance);

  // Connect input port cmdIn
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_cmdIn_InputPorts());
    port++
  ) {
    this->m_cmdIn_InputPort[port].init();
    this->m_cmdIn_InputPort[port].addCallComp(
      this,
      m_p_cmdIn_in
    );
    this->m_cmdIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_cmdIn_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_cmdIn_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port productRecvIn
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_productRecvIn_InputPorts());
    port++
  ) {
    this->m_productRecvIn_InputPort[port].init();
    this->m_productRecvIn_InputPort[port].addCallComp(
      this,
      m_p_productRecvIn_in
    );
    this->m_productRecvIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_productRecvIn_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_productRecvIn_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port aliasTypedAsync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_aliasTypedAsync_InputPorts());
    port++
  ) {
    this->m_aliasTypedAsync_InputPort[port].init();
    this->m_aliasTypedAsync_InputPort[port].addCallComp(
      this,
      m_p_aliasTypedAsync_in
    );
    this->m_aliasTypedAsync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_aliasTypedAsync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_aliasTypedAsync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsAliasStringReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsAliasStringReturnSync_InputPorts());
    port++
  ) {
    this->m_noArgsAliasStringReturnSync_InputPort[port].init();
    this->m_noArgsAliasStringReturnSync_InputPort[port].addCallComp(
      this,
      m_p_noArgsAliasStringReturnSync_in
    );
    this->m_noArgsAliasStringReturnSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsAliasStringReturnSync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsAliasStringReturnSync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsAsync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsAsync_InputPorts());
    port++
  ) {
    this->m_noArgsAsync_InputPort[port].init();
    this->m_noArgsAsync_InputPort[port].addCallComp(
      this,
      m_p_noArgsAsync_in
    );
    this->m_noArgsAsync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsAsync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsAsync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsGuarded_InputPorts());
    port++
  ) {
    this->m_noArgsGuarded_InputPort[port].init();
    this->m_noArgsGuarded_InputPort[port].addCallComp(
      this,
      m_p_noArgsGuarded_in
    );
    this->m_noArgsGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsGuarded_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsGuarded_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsReturnGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsReturnGuarded_InputPorts());
    port++
  ) {
    this->m_noArgsReturnGuarded_InputPort[port].init();
    this->m_noArgsReturnGuarded_InputPort[port].addCallComp(
      this,
      m_p_noArgsReturnGuarded_in
    );
    this->m_noArgsReturnGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsReturnGuarded_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsReturnGuarded_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsReturnSync_InputPorts());
    port++
  ) {
    this->m_noArgsReturnSync_InputPort[port].init();
    this->m_noArgsReturnSync_InputPort[port].addCallComp(
      this,
      m_p_noArgsReturnSync_in
    );
    this->m_noArgsReturnSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsReturnSync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsReturnSync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsStringReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsStringReturnSync_InputPorts());
    port++
  ) {
    this->m_noArgsStringReturnSync_InputPort[port].init();
    this->m_noArgsStringReturnSync_InputPort[port].addCallComp(
      this,
      m_p_noArgsStringReturnSync_in
    );
    this->m_noArgsStringReturnSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsStringReturnSync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsStringReturnSync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsSync_InputPorts());
    port++
  ) {
    this->m_noArgsSync_InputPort[port].init();
    this->m_noArgsSync_InputPort[port].addCallComp(
      this,
      m_p_noArgsSync_in
    );
    this->m_noArgsSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsSync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsSync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedAliasGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedAliasGuarded_InputPorts());
    port++
  ) {
    this->m_typedAliasGuarded_InputPort[port].init();
    this->m_typedAliasGuarded_InputPort[port].addCallComp(
      this,
      m_p_typedAliasGuarded_in
    );
    this->m_typedAliasGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedAliasGuarded_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedAliasGuarded_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedAliasReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedAliasReturnSync_InputPorts());
    port++
  ) {
    this->m_typedAliasReturnSync_InputPort[port].init();
    this->m_typedAliasReturnSync_InputPort[port].addCallComp(
      this,
      m_p_typedAliasReturnSync_in
    );
    this->m_typedAliasReturnSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedAliasReturnSync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedAliasReturnSync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedAliasStringReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedAliasStringReturnSync_InputPorts());
    port++
  ) {
    this->m_typedAliasStringReturnSync_InputPort[port].init();
    this->m_typedAliasStringReturnSync_InputPort[port].addCallComp(
      this,
      m_p_typedAliasStringReturnSync_in
    );
    this->m_typedAliasStringReturnSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedAliasStringReturnSync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedAliasStringReturnSync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedAsync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedAsync_InputPorts());
    port++
  ) {
    this->m_typedAsync_InputPort[port].init();
    this->m_typedAsync_InputPort[port].addCallComp(
      this,
      m_p_typedAsync_in
    );
    this->m_typedAsync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedAsync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedAsync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedAsyncAssert
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedAsyncAssert_InputPorts());
    port++
  ) {
    this->m_typedAsyncAssert_InputPort[port].init();
    this->m_typedAsyncAssert_InputPort[port].addCallComp(
      this,
      m_p_typedAsyncAssert_in
    );
    this->m_typedAsyncAssert_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedAsyncAssert_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedAsyncAssert_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedAsyncBlockPriority
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedAsyncBlockPriority_InputPorts());
    port++
  ) {
    this->m_typedAsyncBlockPriority_InputPort[port].init();
    this->m_typedAsyncBlockPriority_InputPort[port].addCallComp(
      this,
      m_p_typedAsyncBlockPriority_in
    );
    this->m_typedAsyncBlockPriority_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedAsyncBlockPriority_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedAsyncBlockPriority_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedAsyncDropPriority
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedAsyncDropPriority_InputPorts());
    port++
  ) {
    this->m_typedAsyncDropPriority_InputPort[port].init();
    this->m_typedAsyncDropPriority_InputPort[port].addCallComp(
      this,
      m_p_typedAsyncDropPriority_in
    );
    this->m_typedAsyncDropPriority_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedAsyncDropPriority_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedAsyncDropPriority_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedGuarded_InputPorts());
    port++
  ) {
    this->m_typedGuarded_InputPort[port].init();
    this->m_typedGuarded_InputPort[port].addCallComp(
      this,
      m_p_typedGuarded_in
    );
    this->m_typedGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedGuarded_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedGuarded_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedReturnGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedReturnGuarded_InputPorts());
    port++
  ) {
    this->m_typedReturnGuarded_InputPort[port].init();
    this->m_typedReturnGuarded_InputPort[port].addCallComp(
      this,
      m_p_typedReturnGuarded_in
    );
    this->m_typedReturnGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedReturnGuarded_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedReturnGuarded_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedReturnSync_InputPorts());
    port++
  ) {
    this->m_typedReturnSync_InputPort[port].init();
    this->m_typedReturnSync_InputPort[port].addCallComp(
      this,
      m_p_typedReturnSync_in
    );
    this->m_typedReturnSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedReturnSync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedReturnSync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedSync_InputPorts());
    port++
  ) {
    this->m_typedSync_InputPort[port].init();
    this->m_typedSync_InputPort[port].addCallComp(
      this,
      m_p_typedSync_in
    );
    this->m_typedSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedSync_InputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedSync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port cmdRegOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_cmdRegOut_OutputPorts());
    port++
  ) {
    this->m_cmdRegOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_cmdRegOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_cmdRegOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port cmdResponseOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_cmdResponseOut_OutputPorts());
    port++
  ) {
    this->m_cmdResponseOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_cmdResponseOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_cmdResponseOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port eventOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_eventOut_OutputPorts());
    port++
  ) {
    this->m_eventOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_eventOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_eventOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port prmGetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_prmGetOut_OutputPorts());
    port++
  ) {
    this->m_prmGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_prmGetOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_prmGetOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port prmSetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_prmSetOut_OutputPorts());
    port++
  ) {
    this->m_prmSetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_prmSetOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_prmSetOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port productRequestOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_productRequestOut_OutputPorts());
    port++
  ) {
    this->m_productRequestOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_productRequestOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_productRequestOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port productSendOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_productSendOut_OutputPorts());
    port++
  ) {
    this->m_productSendOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_productSendOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_productSendOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

#if FW_ENABLE_TEXT_LOGGING == 1
  // Connect output port textEventOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_textEventOut_OutputPorts());
    port++
  ) {
    this->m_textEventOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_textEventOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_textEventOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }
#endif

  // Connect output port timeGetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_timeGetOut_OutputPorts());
    port++
  ) {
    this->m_timeGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_timeGetOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_timeGetOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port tlmOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_tlmOut_OutputPorts());
    port++
  ) {
    this->m_tlmOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_tlmOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_tlmOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsOut_OutputPorts());
    port++
  ) {
    this->m_noArgsOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsReturnOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsReturnOut_OutputPorts());
    port++
  ) {
    this->m_noArgsReturnOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsReturnOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsReturnOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsStringReturnOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsStringReturnOut_OutputPorts());
    port++
  ) {
    this->m_noArgsStringReturnOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsStringReturnOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsStringReturnOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAliasOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedAliasOut_OutputPorts());
    port++
  ) {
    this->m_typedAliasOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedAliasOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedAliasOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAliasReturnOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedAliasReturnOut_OutputPorts());
    port++
  ) {
    this->m_typedAliasReturnOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedAliasReturnOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedAliasReturnOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAliasReturnStringOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedAliasReturnStringOut_OutputPorts());
    port++
  ) {
    this->m_typedAliasReturnStringOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedAliasReturnStringOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedAliasReturnStringOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedOut_OutputPorts());
    port++
  ) {
    this->m_typedOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedReturnOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedReturnOut_OutputPorts());
    port++
  ) {
    this->m_typedReturnOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedReturnOut_OutputPort[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedReturnOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Create the queue
  Os::Queue::Status qStat = this->createQueue(
    queueDepth,
    static_cast<FwSizeType>(ComponentIpcSerializableBuffer::SERIALIZATION_SIZE)
  );
  FW_ASSERT(
    Os::Queue::Status::OP_OK == qStat,
    static_cast<FwAssertArgType>(qStat)
  );
}

// ----------------------------------------------------------------------
// Getters for special input ports
// ----------------------------------------------------------------------

Fw::InputCmdPort* QueuedTestComponentBase ::
  get_cmdIn_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdIn_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_cmdIn_InputPort[portNum];
}

Fw::InputDpResponsePort* QueuedTestComponentBase ::
  get_productRecvIn_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_productRecvIn_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_productRecvIn_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Getters for typed input ports
// ----------------------------------------------------------------------

Ports::InputAliasTypedPort* QueuedTestComponentBase ::
  get_aliasTypedAsync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_aliasTypedAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_aliasTypedAsync_InputPort[portNum];
}

Ports::InputNoArgsAliasStringReturnPort* QueuedTestComponentBase ::
  get_noArgsAliasStringReturnSync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsAliasStringReturnSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsAliasStringReturnSync_InputPort[portNum];
}

Ports::InputNoArgsPort* QueuedTestComponentBase ::
  get_noArgsAsync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsAsync_InputPort[portNum];
}

Ports::InputNoArgsPort* QueuedTestComponentBase ::
  get_noArgsGuarded_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsGuarded_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsGuarded_InputPort[portNum];
}

Ports::InputNoArgsReturnPort* QueuedTestComponentBase ::
  get_noArgsReturnGuarded_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsReturnGuarded_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsReturnGuarded_InputPort[portNum];
}

Ports::InputNoArgsReturnPort* QueuedTestComponentBase ::
  get_noArgsReturnSync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsReturnSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsReturnSync_InputPort[portNum];
}

Ports::InputNoArgsStringReturnPort* QueuedTestComponentBase ::
  get_noArgsStringReturnSync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsStringReturnSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsStringReturnSync_InputPort[portNum];
}

Ports::InputNoArgsPort* QueuedTestComponentBase ::
  get_noArgsSync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsSync_InputPort[portNum];
}

Ports::InputAliasTypedPort* QueuedTestComponentBase ::
  get_typedAliasGuarded_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasGuarded_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAliasGuarded_InputPort[portNum];
}

Ports::InputAliasTypedReturnPort* QueuedTestComponentBase ::
  get_typedAliasReturnSync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasReturnSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAliasReturnSync_InputPort[portNum];
}

Ports::InputAliasTypedReturnStringPort* QueuedTestComponentBase ::
  get_typedAliasStringReturnSync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasStringReturnSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAliasStringReturnSync_InputPort[portNum];
}

Ports::InputTypedPort* QueuedTestComponentBase ::
  get_typedAsync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAsync_InputPort[portNum];
}

Ports::InputTypedPort* QueuedTestComponentBase ::
  get_typedAsyncAssert_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAsyncAssert_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAsyncAssert_InputPort[portNum];
}

Ports::InputTypedPort* QueuedTestComponentBase ::
  get_typedAsyncBlockPriority_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAsyncBlockPriority_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAsyncBlockPriority_InputPort[portNum];
}

Ports::InputTypedPort* QueuedTestComponentBase ::
  get_typedAsyncDropPriority_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAsyncDropPriority_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAsyncDropPriority_InputPort[portNum];
}

Ports::InputTypedPort* QueuedTestComponentBase ::
  get_typedGuarded_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedGuarded_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedGuarded_InputPort[portNum];
}

Ports::InputTypedReturnPort* QueuedTestComponentBase ::
  get_typedReturnGuarded_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedReturnGuarded_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedReturnGuarded_InputPort[portNum];
}

Ports::InputTypedReturnPort* QueuedTestComponentBase ::
  get_typedReturnSync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedReturnSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedReturnSync_InputPort[portNum];
}

Ports::InputTypedPort* QueuedTestComponentBase ::
  get_typedSync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedSync_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Connect input ports to special output ports
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  set_cmdRegOut_OutputPort(
      FwIndexType portNum,
      Fw::InputCmdRegPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdRegOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdRegOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_cmdResponseOut_OutputPort(
      FwIndexType portNum,
      Fw::InputCmdResponsePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdResponseOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdResponseOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_eventOut_OutputPort(
      FwIndexType portNum,
      Fw::InputLogPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_eventOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_eventOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_prmGetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputPrmGetPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_prmGetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmGetOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_prmSetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputPrmSetPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_prmSetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmSetOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_productRequestOut_OutputPort(
      FwIndexType portNum,
      Fw::InputDpRequestPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_productRequestOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_productRequestOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_productSendOut_OutputPort(
      FwIndexType portNum,
      Fw::InputDpSendPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_productSendOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_productSendOut_OutputPort[portNum].addCallPort(port);
}

#if FW_ENABLE_TEXT_LOGGING == 1

void QueuedTestComponentBase ::
  set_textEventOut_OutputPort(
      FwIndexType portNum,
      Fw::InputLogTextPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_textEventOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_textEventOut_OutputPort[portNum].addCallPort(port);
}

#endif

void QueuedTestComponentBase ::
  set_timeGetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputTimePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_timeGetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_timeGetOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_tlmOut_OutputPort(
      FwIndexType portNum,
      Fw::InputTlmPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_tlmOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_tlmOut_OutputPort[portNum].addCallPort(port);
}

// ----------------------------------------------------------------------
// Connect typed input ports to typed output ports
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  set_noArgsOut_OutputPort(
      FwIndexType portNum,
      Ports::InputNoArgsPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_noArgsOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_noArgsReturnOut_OutputPort(
      FwIndexType portNum,
      Ports::InputNoArgsReturnPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsReturnOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_noArgsReturnOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_noArgsStringReturnOut_OutputPort(
      FwIndexType portNum,
      Ports::InputNoArgsStringReturnPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsStringReturnOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_noArgsStringReturnOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_typedAliasOut_OutputPort(
      FwIndexType portNum,
      Ports::InputAliasTypedPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedAliasOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_typedAliasReturnOut_OutputPort(
      FwIndexType portNum,
      Ports::InputAliasTypedReturnPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasReturnOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedAliasReturnOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_typedAliasReturnStringOut_OutputPort(
      FwIndexType portNum,
      Ports::InputAliasTypedReturnStringPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasReturnStringOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedAliasReturnStringOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_typedOut_OutputPort(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedOut_OutputPort[portNum].addCallPort(port);
}

void QueuedTestComponentBase ::
  set_typedReturnOut_OutputPort(
      FwIndexType portNum,
      Ports::InputTypedReturnPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedReturnOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedReturnOut_OutputPort[portNum].addCallPort(port);
}

#if FW_PORT_SERIALIZATION

// ----------------------------------------------------------------------
// Connect serial input ports to special output ports
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  set_cmdRegOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdRegOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdRegOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedTestComponentBase ::
  set_cmdResponseOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdResponseOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdResponseOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedTestComponentBase ::
  set_eventOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_eventOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_eventOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedTestComponentBase ::
  set_prmSetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_prmSetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmSetOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedTestComponentBase ::
  set_productRequestOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_productRequestOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_productRequestOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedTestComponentBase ::
  set_productSendOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_productSendOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_productSendOut_OutputPort[portNum].registerSerialPort(port);
}

#if FW_ENABLE_TEXT_LOGGING == 1

void QueuedTestComponentBase ::
  set_textEventOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_textEventOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_textEventOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

void QueuedTestComponentBase ::
  set_timeGetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_timeGetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_timeGetOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedTestComponentBase ::
  set_tlmOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_tlmOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_tlmOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

#if FW_PORT_SERIALIZATION

// ----------------------------------------------------------------------
// Connect serial input ports to typed output ports
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  set_noArgsOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_noArgsOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedTestComponentBase ::
  set_typedAliasOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedAliasOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedTestComponentBase ::
  set_typedOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

// ----------------------------------------------------------------------
// Command registration
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  regCommands()
{
  FW_ASSERT(this->m_cmdRegOut_OutputPort[0].isConnected());

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_SYNC
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_SYNC_PRIMITIVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_SYNC_STRING
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_SYNC_ENUM
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_SYNC_ARRAY
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_SYNC_STRUCT
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_GUARDED
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_GUARDED_PRIMITIVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_GUARDED_STRING
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_GUARDED_ENUM
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_GUARDED_ARRAY
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_GUARDED_STRUCT
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_ASYNC
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_PRIORITY
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_PARAMS_PRIORITY
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_DROP
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_CMD_PARAMS_PRIORITY_DROP
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMU32_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMU32_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMF64_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMF64_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMSTRING_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMSTRING_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMENUM_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMENUM_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMARRAY_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMARRAY_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMSTRUCT_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMSTRUCT_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMI32EXT_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMI32EXT_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMF64EXT_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMF64EXT_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMSTRINGEXT_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMSTRINGEXT_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMENUMEXT_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMENUMEXT_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMARRAYEXT_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMARRAYEXT_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMSTRUCTEXT_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMSTRUCTEXT_SAVE
  );
}

// ----------------------------------------------------------------------
// Parameter loading
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  loadParameters()
{
  Fw::ParamBuffer _buff;
  Fw::SerializeStatus _stat = Fw::FW_SERIALIZE_OK;
  const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());
  FW_ASSERT(this->m_prmGetOut_OutputPort[0].isConnected());

  FwPrmIdType _id{};

  Fw::ParamValid param_valid;

  _id = _baseId + PARAMID_PARAMU32;

  // Get parameter ParamU32
  this->m_param_ParamU32_valid =
    this->m_prmGetOut_OutputPort[0].invoke(
      _id,
      _buff
    );

  // Deserialize value
  this->m_paramLock.lock();

  // If there was a deserialization issue, mark it invalid
  if (this->m_param_ParamU32_valid == Fw::ParamValid::VALID) {
    _stat = _buff.deserializeTo(this->m_ParamU32);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      this->m_param_ParamU32_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    // No default
  }

  this->m_paramLock.unLock();

  _id = _baseId + PARAMID_PARAMF64;

  // Get parameter ParamF64
  this->m_param_ParamF64_valid =
    this->m_prmGetOut_OutputPort[0].invoke(
      _id,
      _buff
    );

  // Deserialize value
  this->m_paramLock.lock();

  // If there was a deserialization issue, mark it invalid
  if (this->m_param_ParamF64_valid == Fw::ParamValid::VALID) {
    _stat = _buff.deserializeTo(this->m_ParamF64);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      this->m_param_ParamF64_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    // No default
  }

  this->m_paramLock.unLock();

  _id = _baseId + PARAMID_PARAMSTRING;

  // Get parameter ParamString
  this->m_param_ParamString_valid =
    this->m_prmGetOut_OutputPort[0].invoke(
      _id,
      _buff
    );

  // Deserialize value
  this->m_paramLock.lock();

  // If there was a deserialization issue, mark it invalid
  if (this->m_param_ParamString_valid == Fw::ParamValid::VALID) {
    _stat = _buff.deserializeTo(this->m_ParamString);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      this->m_param_ParamString_valid = Fw::ParamValid::DEFAULT;
      // Set default value
      this->m_ParamString = Fw::String("default");
    }
  }
  else {
    // Set default value
    this->m_param_ParamString_valid = Fw::ParamValid::DEFAULT;
    this->m_ParamString = Fw::String("default");
  }

  this->m_paramLock.unLock();

  _id = _baseId + PARAMID_PARAMENUM;

  // Get parameter ParamEnum
  this->m_param_ParamEnum_valid =
    this->m_prmGetOut_OutputPort[0].invoke(
      _id,
      _buff
    );

  // Deserialize value
  this->m_paramLock.lock();

  // If there was a deserialization issue, mark it invalid
  if (this->m_param_ParamEnum_valid == Fw::ParamValid::VALID) {
    _stat = _buff.deserializeTo(this->m_ParamEnum);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      this->m_param_ParamEnum_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    // No default
  }

  this->m_paramLock.unLock();

  _id = _baseId + PARAMID_PARAMARRAY;

  // Get parameter ParamArray
  this->m_param_ParamArray_valid =
    this->m_prmGetOut_OutputPort[0].invoke(
      _id,
      _buff
    );

  // Deserialize value
  this->m_paramLock.lock();

  // If there was a deserialization issue, mark it invalid
  if (this->m_param_ParamArray_valid == Fw::ParamValid::VALID) {
    _stat = _buff.deserializeTo(this->m_ParamArray);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      this->m_param_ParamArray_valid = Fw::ParamValid::DEFAULT;
      // Set default value
      this->m_ParamArray = A({1, 2, 3});
    }
  }
  else {
    // Set default value
    this->m_param_ParamArray_valid = Fw::ParamValid::DEFAULT;
    this->m_ParamArray = A({1, 2, 3});
  }

  this->m_paramLock.unLock();

  _id = _baseId + PARAMID_PARAMSTRUCT;

  // Get parameter ParamStruct
  this->m_param_ParamStruct_valid =
    this->m_prmGetOut_OutputPort[0].invoke(
      _id,
      _buff
    );

  // Deserialize value
  this->m_paramLock.lock();

  // If there was a deserialization issue, mark it invalid
  if (this->m_param_ParamStruct_valid == Fw::ParamValid::VALID) {
    _stat = _buff.deserializeTo(this->m_ParamStruct);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      this->m_param_ParamStruct_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    // No default
  }

  this->m_paramLock.unLock();

  _id = _baseId + PARAMID_PARAMI32EXT;

  // Get parameter ParamI32Ext
  param_valid = this->m_prmGetOut_OutputPort[0].invoke(
    _id,
    _buff
  );

  // Get the local ID to pass to the delegate
  _id = PARAMID_PARAMI32EXT;
  // If there was a deserialization issue, mark it invalid
  if (param_valid == Fw::ParamValid::VALID) {
    // Pass the local ID to the delegate
    _id = PARAMID_PARAMI32EXT;

    FW_ASSERT(this->paramDelegatePtr != NULL);
    // Call the delegate deserialize function for m_ParamI32Ext
    _stat = this->paramDelegatePtr->deserializeParam(_baseId, _id, param_valid, _buff);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      param_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    param_valid = Fw::ParamValid::INVALID;
  }

  _id = _baseId + PARAMID_PARAMF64EXT;

  // Get parameter ParamF64Ext
  param_valid = this->m_prmGetOut_OutputPort[0].invoke(
    _id,
    _buff
  );

  // Get the local ID to pass to the delegate
  _id = PARAMID_PARAMF64EXT;
  // If there was a deserialization issue, mark it invalid
  if (param_valid == Fw::ParamValid::VALID) {
    // Pass the local ID to the delegate
    _id = PARAMID_PARAMF64EXT;

    FW_ASSERT(this->paramDelegatePtr != NULL);
    // Call the delegate deserialize function for m_ParamF64Ext
    _stat = this->paramDelegatePtr->deserializeParam(_baseId, _id, param_valid, _buff);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      param_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    param_valid = Fw::ParamValid::INVALID;
  }

  _id = _baseId + PARAMID_PARAMSTRINGEXT;

  // Get parameter ParamStringExt
  param_valid = this->m_prmGetOut_OutputPort[0].invoke(
    _id,
    _buff
  );

  // Get the local ID to pass to the delegate
  _id = PARAMID_PARAMSTRINGEXT;
  // If there was a deserialization issue, mark it invalid
  if (param_valid == Fw::ParamValid::VALID) {
    // Pass the local ID to the delegate
    _id = PARAMID_PARAMSTRINGEXT;

    FW_ASSERT(this->paramDelegatePtr != NULL);
    // Call the delegate deserialize function for m_ParamStringExt
    _stat = this->paramDelegatePtr->deserializeParam(_baseId, _id, param_valid, _buff);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      param_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    param_valid = Fw::ParamValid::INVALID;
  }

  _id = _baseId + PARAMID_PARAMENUMEXT;

  // Get parameter ParamEnumExt
  param_valid = this->m_prmGetOut_OutputPort[0].invoke(
    _id,
    _buff
  );

  // Get the local ID to pass to the delegate
  _id = PARAMID_PARAMENUMEXT;
  // If there was a deserialization issue, mark it invalid
  if (param_valid == Fw::ParamValid::VALID) {
    // Pass the local ID to the delegate
    _id = PARAMID_PARAMENUMEXT;

    FW_ASSERT(this->paramDelegatePtr != NULL);
    // Call the delegate deserialize function for m_ParamEnumExt
    _stat = this->paramDelegatePtr->deserializeParam(_baseId, _id, param_valid, _buff);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      param_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    param_valid = Fw::ParamValid::INVALID;
  }

  _id = _baseId + PARAMID_PARAMARRAYEXT;

  // Get parameter ParamArrayExt
  param_valid = this->m_prmGetOut_OutputPort[0].invoke(
    _id,
    _buff
  );

  // Get the local ID to pass to the delegate
  _id = PARAMID_PARAMARRAYEXT;
  // If there was a deserialization issue, mark it invalid
  if (param_valid == Fw::ParamValid::VALID) {
    // Pass the local ID to the delegate
    _id = PARAMID_PARAMARRAYEXT;

    FW_ASSERT(this->paramDelegatePtr != NULL);
    // Call the delegate deserialize function for m_ParamArrayExt
    _stat = this->paramDelegatePtr->deserializeParam(_baseId, _id, param_valid, _buff);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      param_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    param_valid = Fw::ParamValid::INVALID;
  }

  _id = _baseId + PARAMID_PARAMSTRUCTEXT;

  // Get parameter ParamStructExt
  param_valid = this->m_prmGetOut_OutputPort[0].invoke(
    _id,
    _buff
  );

  // Get the local ID to pass to the delegate
  _id = PARAMID_PARAMSTRUCTEXT;
  // If there was a deserialization issue, mark it invalid
  if (param_valid == Fw::ParamValid::VALID) {
    // Pass the local ID to the delegate
    _id = PARAMID_PARAMSTRUCTEXT;

    FW_ASSERT(this->paramDelegatePtr != NULL);
    // Call the delegate deserialize function for m_ParamStructExt
    _stat = this->paramDelegatePtr->deserializeParam(_baseId, _id, param_valid, _buff);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      param_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    param_valid = Fw::ParamValid::INVALID;
  }

  // Call notifier
  this->parametersLoaded();
}

// ----------------------------------------------------------------------
// Component construction and destruction
// ----------------------------------------------------------------------

QueuedTestComponentBase ::
  QueuedTestComponentBase(const char* compName) :
    Fw::QueuedComponentBase(compName),
    paramDelegatePtr(NULL)
{
  // Write telemetry channel ChannelU32OnChange
  this->m_first_update_ChannelU32OnChange = true;
  this->m_last_ChannelU32OnChange = 0;

  // Write telemetry channel ChannelEnumOnChange
  this->m_first_update_ChannelEnumOnChange = true;

  this->m_EventActivityLowThrottledThrottle = 0;
  this->m_EventFatalThrottledThrottle = 0;
  this->m_EventWarningLowThrottledThrottle = 0;

  this->m_param_ParamU32_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamF64_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamString_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamEnum_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamArray_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamStruct_valid = Fw::ParamValid::UNINIT;
}

QueuedTestComponentBase ::
  ~QueuedTestComponentBase()
{

}

// ----------------------------------------------------------------------
// Getters for numbers of special input ports
// ----------------------------------------------------------------------

FwIndexType QueuedTestComponentBase ::
  getNum_cmdIn_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdIn_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_productRecvIn_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_productRecvIn_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of typed input ports
// ----------------------------------------------------------------------

FwIndexType QueuedTestComponentBase ::
  getNum_aliasTypedAsync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_aliasTypedAsync_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_noArgsAliasStringReturnSync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsAliasStringReturnSync_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_noArgsAsync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsAsync_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_noArgsGuarded_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsGuarded_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_noArgsReturnGuarded_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsReturnGuarded_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_noArgsReturnSync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsReturnSync_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_noArgsStringReturnSync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsStringReturnSync_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_noArgsSync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsSync_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedAliasGuarded_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAliasGuarded_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedAliasReturnSync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAliasReturnSync_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedAliasStringReturnSync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAliasStringReturnSync_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedAsync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAsync_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedAsyncAssert_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAsyncAssert_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedAsyncBlockPriority_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAsyncBlockPriority_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedAsyncDropPriority_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAsyncDropPriority_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedGuarded_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedGuarded_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedReturnGuarded_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnGuarded_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedReturnSync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnSync_InputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedSync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedSync_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of special output ports
// ----------------------------------------------------------------------

FwIndexType QueuedTestComponentBase ::
  getNum_cmdRegOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdRegOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_cmdResponseOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdResponseOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_eventOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_eventOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_prmGetOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_prmGetOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_prmSetOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_prmSetOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_productRequestOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_productRequestOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_productSendOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_productSendOut_OutputPort));
}

#if FW_ENABLE_TEXT_LOGGING == 1

FwIndexType QueuedTestComponentBase ::
  getNum_textEventOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_textEventOut_OutputPort));
}

#endif

FwIndexType QueuedTestComponentBase ::
  getNum_timeGetOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_timeGetOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_tlmOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_tlmOut_OutputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of typed output ports
// ----------------------------------------------------------------------

FwIndexType QueuedTestComponentBase ::
  getNum_noArgsOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_noArgsReturnOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsReturnOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_noArgsStringReturnOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsStringReturnOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedAliasOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAliasOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedAliasReturnOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAliasReturnOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedAliasReturnStringOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAliasReturnStringOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedOut_OutputPort));
}

FwIndexType QueuedTestComponentBase ::
  getNum_typedReturnOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnOut_OutputPort));
}

// ----------------------------------------------------------------------
// Connection status queries for special output ports
// ----------------------------------------------------------------------

bool QueuedTestComponentBase ::
  isConnected_cmdRegOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdRegOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_cmdRegOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_cmdResponseOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_cmdResponseOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_cmdResponseOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_eventOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_eventOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_eventOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_prmGetOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_prmGetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_prmGetOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_prmSetOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_prmSetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_prmSetOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_productRequestOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_productRequestOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_productRequestOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_productSendOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_productSendOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_productSendOut_OutputPort[portNum].isConnected();
}

#if FW_ENABLE_TEXT_LOGGING == 1

bool QueuedTestComponentBase ::
  isConnected_textEventOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_textEventOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_textEventOut_OutputPort[portNum].isConnected();
}

#endif

bool QueuedTestComponentBase ::
  isConnected_timeGetOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_timeGetOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_timeGetOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_tlmOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_tlmOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_tlmOut_OutputPort[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Connection status queries for typed output ports
// ----------------------------------------------------------------------

bool QueuedTestComponentBase ::
  isConnected_noArgsOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_noArgsOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_noArgsReturnOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsReturnOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_noArgsReturnOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_noArgsStringReturnOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsStringReturnOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_noArgsStringReturnOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_typedAliasOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_typedAliasOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_typedAliasReturnOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasReturnOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_typedAliasReturnOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_typedAliasReturnStringOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasReturnStringOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_typedAliasReturnStringOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_typedOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_typedOut_OutputPort[portNum].isConnected();
}

bool QueuedTestComponentBase ::
  isConnected_typedReturnOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedReturnOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_typedReturnOut_OutputPort[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Port handler base-class functions for special input ports
//
// Call these functions directly to bypass the corresponding ports
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  productRecvIn_handlerBase(
      FwIndexType portNum,
      FwDpIdType id,
      const Fw::Buffer& buffer,
      const Fw::Success& status
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_productRecvIn_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  productRecvIn_preMsgHook(
    portNum,
    id,
    buffer,
    status
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serializeFrom(
    static_cast<FwEnumStoreType>(PRODUCTRECVIN_DPRESPONSE)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serializeFrom(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument id
  _status = msg.serializeFrom(id);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument buffer
  _status = msg.serializeFrom(buffer);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument status
  _status = msg.serializeFrom(status);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

// ----------------------------------------------------------------------
// Port handler base-class functions for typed input ports
//
// Call these functions directly to bypass the corresponding ports
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  aliasTypedAsync_handlerBase(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_aliasTypedAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  aliasTypedAsync_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serializeFrom(
    static_cast<FwEnumStoreType>(ALIASTYPEDASYNC_ALIASTYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serializeFrom(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serializeFrom(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serializeFrom(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serializeFrom(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str2
  _status = msg.serializeFrom(str2);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serializeFrom(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serializeFrom(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serializeFrom(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

Fw::String QueuedTestComponentBase ::
  noArgsAliasStringReturnSync_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsAliasStringReturnSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  Fw::String retVal;

  // Call handler function
  retVal = this->noArgsAliasStringReturnSync_handler(portNum);

  return retVal;
}

void QueuedTestComponentBase ::
  noArgsAsync_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  noArgsAsync_preMsgHook(portNum);
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serializeFrom(
    static_cast<FwEnumStoreType>(NOARGSASYNC_NOARGS)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serializeFrom(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  noArgsGuarded_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsGuarded_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Lock guard mutex before calling
  this->lock();

  // Call handler function
  this->noArgsGuarded_handler(portNum);

  // Unlock guard mutex
  this->unLock();
}

U32 QueuedTestComponentBase ::
  noArgsReturnGuarded_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsReturnGuarded_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  U32 retVal;

  // Lock guard mutex before calling
  this->lock();

  // Call handler function
  retVal = this->noArgsReturnGuarded_handler(portNum);

  // Unlock guard mutex
  this->unLock();

  return retVal;
}

U32 QueuedTestComponentBase ::
  noArgsReturnSync_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsReturnSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  U32 retVal;

  // Call handler function
  retVal = this->noArgsReturnSync_handler(portNum);

  return retVal;
}

Fw::String QueuedTestComponentBase ::
  noArgsStringReturnSync_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsStringReturnSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  Fw::String retVal;

  // Call handler function
  retVal = this->noArgsStringReturnSync_handler(portNum);

  return retVal;
}

void QueuedTestComponentBase ::
  noArgsSync_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call handler function
  this->noArgsSync_handler(portNum);
}

void QueuedTestComponentBase ::
  typedAliasGuarded_handlerBase(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasGuarded_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Lock guard mutex before calling
  this->lock();

  // Call handler function
  this->typedAliasGuarded_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );

  // Unlock guard mutex
  this->unLock();
}

AliasPrim2 QueuedTestComponentBase ::
  typedAliasReturnSync_handlerBase(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasReturnSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  AliasPrim2 retVal;

  // Call handler function
  retVal = this->typedAliasReturnSync_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );

  return retVal;
}

Fw::String QueuedTestComponentBase ::
  typedAliasStringReturnSync_handlerBase(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AnotherAliasStruct& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasStringReturnSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  Fw::String retVal;

  // Call handler function
  retVal = this->typedAliasStringReturnSync_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );

  return retVal;
}

void QueuedTestComponentBase ::
  typedAsync_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAsync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  typedAsync_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serializeFrom(
    static_cast<FwEnumStoreType>(TYPEDASYNC_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serializeFrom(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serializeFrom(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serializeFrom(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serializeFrom(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str1
  _status = str1.serializeTo(msg, 80);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serializeFrom(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serializeFrom(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serializeFrom(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  typedAsyncAssert_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAsyncAssert_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  typedAsyncAssert_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serializeFrom(
    static_cast<FwEnumStoreType>(TYPEDASYNCASSERT_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serializeFrom(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serializeFrom(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serializeFrom(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serializeFrom(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str1
  _status = str1.serializeTo(msg, 80);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serializeFrom(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serializeFrom(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serializeFrom(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  typedAsyncBlockPriority_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAsyncBlockPriority_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  typedAsyncBlockPriority_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serializeFrom(
    static_cast<FwEnumStoreType>(TYPEDASYNCBLOCKPRIORITY_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serializeFrom(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serializeFrom(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serializeFrom(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serializeFrom(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str1
  _status = str1.serializeTo(msg, 80);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serializeFrom(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serializeFrom(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serializeFrom(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::BLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 10, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  typedAsyncDropPriority_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAsyncDropPriority_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  typedAsyncDropPriority_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serializeFrom(
    static_cast<FwEnumStoreType>(TYPEDASYNCDROPPRIORITY_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serializeFrom(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serializeFrom(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serializeFrom(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serializeFrom(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str1
  _status = str1.serializeTo(msg, 80);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serializeFrom(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serializeFrom(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serializeFrom(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 5, _block);

  if (qStatus == Os::Queue::Status::FULL) {
    this->incNumMsgDropped();
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  typedGuarded_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedGuarded_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Lock guard mutex before calling
  this->lock();

  // Call handler function
  this->typedGuarded_handler(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );

  // Unlock guard mutex
  this->unLock();
}

F32 QueuedTestComponentBase ::
  typedReturnGuarded_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedReturnGuarded_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  F32 retVal;

  // Lock guard mutex before calling
  this->lock();

  // Call handler function
  retVal = this->typedReturnGuarded_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );

  // Unlock guard mutex
  this->unLock();

  return retVal;
}

F32 QueuedTestComponentBase ::
  typedReturnSync_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedReturnSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  F32 retVal;

  // Call handler function
  retVal = this->typedReturnSync_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );

  return retVal;
}

void QueuedTestComponentBase ::
  typedSync_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedSync_InputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call handler function
  this->typedSync_handler(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Pre-message hooks for special async input ports
//
// Each of these functions is invoked just before processing a message
// on the corresponding port. By default, they do nothing. You can
// override them to provide specific pre-message behavior.
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  productRecvIn_preMsgHook(
      FwIndexType portNum,
      FwDpIdType id,
      const Fw::Buffer& buffer,
      const Fw::Success& status
  )
{
  // Default: no-op
}

// ----------------------------------------------------------------------
// Pre-message hooks for typed async input ports
//
// Each of these functions is invoked just before processing a message
// on the corresponding port. By default, they do nothing. You can
// override them to provide specific pre-message behavior.
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  aliasTypedAsync_preMsgHook(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  // Default: no-op
}

void QueuedTestComponentBase ::
  noArgsAsync_preMsgHook(FwIndexType portNum)
{
  // Default: no-op
}

void QueuedTestComponentBase ::
  typedAsync_preMsgHook(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

void QueuedTestComponentBase ::
  typedAsyncAssert_preMsgHook(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

void QueuedTestComponentBase ::
  typedAsyncBlockPriority_preMsgHook(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

void QueuedTestComponentBase ::
  typedAsyncDropPriority_preMsgHook(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

// ----------------------------------------------------------------------
// Invocation functions for special output ports
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  productRequestOut_out(
      FwIndexType portNum,
      FwDpIdType id,
      FwSizeType dataSize
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_productRequestOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_productRequestOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_productRequestOut_OutputPort[portNum].invoke(
    id,
    dataSize
  );
}

void QueuedTestComponentBase ::
  productSendOut_out(
      FwIndexType portNum,
      FwDpIdType id,
      const Fw::Buffer& buffer
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_productSendOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_productSendOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_productSendOut_OutputPort[portNum].invoke(
    id,
    buffer
  );
}

// ----------------------------------------------------------------------
// Invocation functions for typed output ports
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  noArgsOut_out(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_noArgsOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_noArgsOut_OutputPort[portNum].invoke();
}

U32 QueuedTestComponentBase ::
  noArgsReturnOut_out(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsReturnOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_noArgsReturnOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_noArgsReturnOut_OutputPort[portNum].invoke();
}

Fw::String QueuedTestComponentBase ::
  noArgsStringReturnOut_out(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_noArgsStringReturnOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_noArgsStringReturnOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_noArgsStringReturnOut_OutputPort[portNum].invoke();
}

void QueuedTestComponentBase ::
  typedAliasOut_out(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_typedAliasOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_typedAliasOut_OutputPort[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

AliasPrim2 QueuedTestComponentBase ::
  typedAliasReturnOut_out(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasReturnOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_typedAliasReturnOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_typedAliasReturnOut_OutputPort[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

Fw::String QueuedTestComponentBase ::
  typedAliasReturnStringOut_out(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AnotherAliasStruct& s
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedAliasReturnStringOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_typedAliasReturnStringOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_typedAliasReturnStringOut_OutputPort[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void QueuedTestComponentBase ::
  typedOut_out(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_typedOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_typedOut_OutputPort[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 QueuedTestComponentBase ::
  typedReturnOut_out(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_typedReturnOut_OutputPorts()),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_typedReturnOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_typedReturnOut_OutputPort[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Internal interface base-class functions
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  internalArray_internalInterfaceInvoke(const A& a)
{
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize the message ID
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_INTERNALARRAY));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  _status = msg.serializeFrom(static_cast<FwIndexType>(0));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  internalEnum_internalInterfaceInvoke(const E& e)
{
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize the message ID
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_INTERNALENUM));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  _status = msg.serializeFrom(static_cast<FwIndexType>(0));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  internalPrimitive_internalInterfaceInvoke(
      U32 u32,
      F32 f32,
      bool b
  )
{
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize the message ID
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_INTERNALPRIMITIVE));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  _status = msg.serializeFrom(static_cast<FwIndexType>(0));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 5, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  internalPriorityDrop_internalInterfaceInvoke()
{
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize the message ID
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_INTERNALPRIORITYDROP));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  _status = msg.serializeFrom(static_cast<FwIndexType>(0));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 10, _block);

  if (qStatus == Os::Queue::Status::FULL) {
    this->incNumMsgDropped();
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  internalString_internalInterfaceInvoke(
      const Fw::InternalInterfaceString& str1,
      const Fw::InternalInterfaceString& str2
  )
{
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize the message ID
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_INTERNALSTRING));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  _status = msg.serializeFrom(static_cast<FwIndexType>(0));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(str1);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(str2);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  internalStruct_internalInterfaceInvoke(const S& s)
{
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize the message ID
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_INTERNALSTRUCT));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  _status = msg.serializeFrom(static_cast<FwIndexType>(0));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 20, _block);

  if (qStatus == Os::Queue::Status::FULL) {
    this->incNumMsgDropped();
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

// ----------------------------------------------------------------------
// Command response
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  cmdResponse_out(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdResponse response
  )
{
  FW_ASSERT(this->m_cmdResponseOut_OutputPort[0].isConnected());
  this->m_cmdResponseOut_OutputPort[0].invoke(opCode, cmdSeq, response);
}

// ----------------------------------------------------------------------
// Command handler base-class functions
//
// Call these functions directly to bypass the command input port
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  CMD_SYNC_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
#if FW_CMD_CHECK_RESIDUAL
  // Make sure there was no data left over.
  // That means the argument buffer size was incorrect.
  if (args.getBuffLeft() != 0) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }
#endif

  this->CMD_SYNC_cmdHandler(opCode, cmdSeq);
}

void QueuedTestComponentBase ::
  CMD_SYNC_PRIMITIVE_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Deserialize the arguments
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Reset the buffer
  args.resetDeser();

  U32 u32;
  _status = args.deserializeTo(u32);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

  F32 f32;
  _status = args.deserializeTo(f32);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

  bool b;
  _status = args.deserializeTo(b);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

#if FW_CMD_CHECK_RESIDUAL
  // Make sure there was no data left over.
  // That means the argument buffer size was incorrect.
  if (args.getBuffLeft() != 0) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }
#endif

  this->CMD_SYNC_PRIMITIVE_cmdHandler(
    opCode, cmdSeq,
    u32,
    f32,
    b
  );
}

void QueuedTestComponentBase ::
  CMD_SYNC_STRING_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Deserialize the arguments
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Reset the buffer
  args.resetDeser();

  Fw::CmdStringArg str1;
  _status = args.deserializeTo(str1);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

  Fw::CmdStringArg str2;
  _status = args.deserializeTo(str2);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

#if FW_CMD_CHECK_RESIDUAL
  // Make sure there was no data left over.
  // That means the argument buffer size was incorrect.
  if (args.getBuffLeft() != 0) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }
#endif

  this->CMD_SYNC_STRING_cmdHandler(
    opCode, cmdSeq,
    str1,
    str2
  );
}

void QueuedTestComponentBase ::
  CMD_SYNC_ENUM_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Deserialize the arguments
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Reset the buffer
  args.resetDeser();

  E e;
  _status = args.deserializeTo(e);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

#if FW_CMD_CHECK_RESIDUAL
  // Make sure there was no data left over.
  // That means the argument buffer size was incorrect.
  if (args.getBuffLeft() != 0) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }
#endif

  this->CMD_SYNC_ENUM_cmdHandler(
    opCode, cmdSeq,
    e
  );
}

void QueuedTestComponentBase ::
  CMD_SYNC_ARRAY_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Deserialize the arguments
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Reset the buffer
  args.resetDeser();

  A a;
  _status = args.deserializeTo(a);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

#if FW_CMD_CHECK_RESIDUAL
  // Make sure there was no data left over.
  // That means the argument buffer size was incorrect.
  if (args.getBuffLeft() != 0) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }
#endif

  this->CMD_SYNC_ARRAY_cmdHandler(
    opCode, cmdSeq,
    a
  );
}

void QueuedTestComponentBase ::
  CMD_SYNC_STRUCT_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Deserialize the arguments
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Reset the buffer
  args.resetDeser();

  S s;
  _status = args.deserializeTo(s);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

#if FW_CMD_CHECK_RESIDUAL
  // Make sure there was no data left over.
  // That means the argument buffer size was incorrect.
  if (args.getBuffLeft() != 0) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }
#endif

  this->CMD_SYNC_STRUCT_cmdHandler(
    opCode, cmdSeq,
    s
  );
}

void QueuedTestComponentBase ::
  CMD_GUARDED_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
#if FW_CMD_CHECK_RESIDUAL
  // Make sure there was no data left over.
  // That means the argument buffer size was incorrect.
  if (args.getBuffLeft() != 0) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }
#endif

  this->lock();

  this->CMD_GUARDED_cmdHandler(opCode, cmdSeq);

  this->unLock();
}

void QueuedTestComponentBase ::
  CMD_GUARDED_PRIMITIVE_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Deserialize the arguments
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Reset the buffer
  args.resetDeser();

  U32 u32;
  _status = args.deserializeTo(u32);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

  F32 f32;
  _status = args.deserializeTo(f32);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

  bool b;
  _status = args.deserializeTo(b);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

#if FW_CMD_CHECK_RESIDUAL
  // Make sure there was no data left over.
  // That means the argument buffer size was incorrect.
  if (args.getBuffLeft() != 0) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }
#endif

  this->lock();

  this->CMD_GUARDED_PRIMITIVE_cmdHandler(
    opCode, cmdSeq,
    u32,
    f32,
    b
  );

  this->unLock();
}

void QueuedTestComponentBase ::
  CMD_GUARDED_STRING_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Deserialize the arguments
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Reset the buffer
  args.resetDeser();

  Fw::CmdStringArg str1;
  _status = args.deserializeTo(str1);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

  Fw::CmdStringArg str2;
  _status = args.deserializeTo(str2);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

#if FW_CMD_CHECK_RESIDUAL
  // Make sure there was no data left over.
  // That means the argument buffer size was incorrect.
  if (args.getBuffLeft() != 0) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }
#endif

  this->lock();

  this->CMD_GUARDED_STRING_cmdHandler(
    opCode, cmdSeq,
    str1,
    str2
  );

  this->unLock();
}

void QueuedTestComponentBase ::
  CMD_GUARDED_ENUM_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Deserialize the arguments
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Reset the buffer
  args.resetDeser();

  E e;
  _status = args.deserializeTo(e);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

#if FW_CMD_CHECK_RESIDUAL
  // Make sure there was no data left over.
  // That means the argument buffer size was incorrect.
  if (args.getBuffLeft() != 0) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }
#endif

  this->lock();

  this->CMD_GUARDED_ENUM_cmdHandler(
    opCode, cmdSeq,
    e
  );

  this->unLock();
}

void QueuedTestComponentBase ::
  CMD_GUARDED_ARRAY_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Deserialize the arguments
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Reset the buffer
  args.resetDeser();

  A a;
  _status = args.deserializeTo(a);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

#if FW_CMD_CHECK_RESIDUAL
  // Make sure there was no data left over.
  // That means the argument buffer size was incorrect.
  if (args.getBuffLeft() != 0) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }
#endif

  this->lock();

  this->CMD_GUARDED_ARRAY_cmdHandler(
    opCode, cmdSeq,
    a
  );

  this->unLock();
}

void QueuedTestComponentBase ::
  CMD_GUARDED_STRUCT_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Deserialize the arguments
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Reset the buffer
  args.resetDeser();

  S s;
  _status = args.deserializeTo(s);
  if (_status != Fw::FW_SERIALIZE_OK) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }

#if FW_CMD_CHECK_RESIDUAL
  // Make sure there was no data left over.
  // That means the argument buffer size was incorrect.
  if (args.getBuffLeft() != 0) {
    if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
      this->m_cmdResponseOut_OutputPort[0].invoke(
        opCode,
        cmdSeq,
        Fw::CmdResponse::FORMAT_ERROR
      );
    }
    return;
  }
#endif

  this->lock();

  this->CMD_GUARDED_STRUCT_cmdHandler(
    opCode, cmdSeq,
    s
  );

  this->unLock();
}

void QueuedTestComponentBase ::
  CMD_ASYNC_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Call pre-message hook
  this->CMD_ASYNC_preMsgHook(opCode,cmdSeq);

  // Defer deserializing arguments to the message dispatcher
  // to avoid deserializing and reserializing just for IPC
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize for IPC
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_CMD_ASYNC));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  FwIndexType port = 0;

  _status = msg.serializeFrom(port);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(opCode);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(cmdSeq);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(args);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  CMD_PRIORITY_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Call pre-message hook
  this->CMD_PRIORITY_preMsgHook(opCode,cmdSeq);

  // Defer deserializing arguments to the message dispatcher
  // to avoid deserializing and reserializing just for IPC
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize for IPC
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_CMD_PRIORITY));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  FwIndexType port = 0;

  _status = msg.serializeFrom(port);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(opCode);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(cmdSeq);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(args);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 10, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  CMD_PARAMS_PRIORITY_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Call pre-message hook
  this->CMD_PARAMS_PRIORITY_preMsgHook(opCode,cmdSeq);

  // Defer deserializing arguments to the message dispatcher
  // to avoid deserializing and reserializing just for IPC
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize for IPC
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_CMD_PARAMS_PRIORITY));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  FwIndexType port = 0;

  _status = msg.serializeFrom(port);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(opCode);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(cmdSeq);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(args);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 20, _block);

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  CMD_DROP_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Call pre-message hook
  this->CMD_DROP_preMsgHook(opCode,cmdSeq);

  // Defer deserializing arguments to the message dispatcher
  // to avoid deserializing and reserializing just for IPC
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize for IPC
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_CMD_DROP));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  FwIndexType port = 0;

  _status = msg.serializeFrom(port);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(opCode);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(cmdSeq);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(args);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 0, _block);

  if (qStatus == Os::Queue::Status::FULL) {
    this->incNumMsgDropped();
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedTestComponentBase ::
  CMD_PARAMS_PRIORITY_DROP_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Call pre-message hook
  this->CMD_PARAMS_PRIORITY_DROP_preMsgHook(opCode,cmdSeq);

  // Defer deserializing arguments to the message dispatcher
  // to avoid deserializing and reserializing just for IPC
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize for IPC
  _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_CMD_PARAMS_PRIORITY_DROP));
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Fake port number to make message dequeue work
  FwIndexType port = 0;

  _status = msg.serializeFrom(port);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(opCode);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(cmdSeq);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = msg.serializeFrom(args);
  FW_ASSERT (
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
  Os::Queue::Status qStatus = this->m_queue.send(msg, 30, _block);

  if (qStatus == Os::Queue::Status::FULL) {
    this->incNumMsgDropped();
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::OP_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

// ----------------------------------------------------------------------
// Pre-message hooks for async commands
//
// Each of these functions is invoked just before processing the
// corresponding command. By default they do nothing. You can
// override them to provide specific pre-command behavior.
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  CMD_ASYNC_preMsgHook(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{
  // Defaults to no-op; can be overridden
  (void) opCode;
  (void) cmdSeq;
}

void QueuedTestComponentBase ::
  CMD_PRIORITY_preMsgHook(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{
  // Defaults to no-op; can be overridden
  (void) opCode;
  (void) cmdSeq;
}

void QueuedTestComponentBase ::
  CMD_PARAMS_PRIORITY_preMsgHook(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{
  // Defaults to no-op; can be overridden
  (void) opCode;
  (void) cmdSeq;
}

void QueuedTestComponentBase ::
  CMD_DROP_preMsgHook(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{
  // Defaults to no-op; can be overridden
  (void) opCode;
  (void) cmdSeq;
}

void QueuedTestComponentBase ::
  CMD_PARAMS_PRIORITY_DROP_preMsgHook(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{
  // Defaults to no-op; can be overridden
  (void) opCode;
  (void) cmdSeq;
}

// ----------------------------------------------------------------------
// Event logging functions
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  log_ACTIVITY_HI_EventActivityHigh() const
{
  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTACTIVITYHIGH;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;

#if FW_AMPCS_COMPATIBLE
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
    // Serialize the number of arguments
    _status = _logBuff.serializeFrom(static_cast<U8>(0));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::ACTIVITY_HI,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Activity High occurred";
#else
    const char* _formatString =
      "%s: Event Activity High occurred";
#endif

    Fw::TextLogString _logString;
    _logString.format(
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName.toChar(),
#endif
      "EventActivityHigh "
    );

    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::ACTIVITY_HI,
      _logString
    );
  }
#endif
}

void QueuedTestComponentBase ::
  log_ACTIVITY_LO_EventActivityLowThrottled(
      U32 u32,
      F32 f32,
      bool b
  )
{
  // Check throttle value
  if (this->m_EventActivityLowThrottledThrottle >= EVENTID_EVENTACTIVITYLOWTHROTTLED_THROTTLE) {
    return;
  }
  else {
    (void) this->m_EventActivityLowThrottledThrottle.fetch_add(1);
  }

  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTACTIVITYLOWTHROTTLED;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
    // Serialize the number of arguments
    _status = _logBuff.serializeFrom(static_cast<U8>(3));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

#if FW_AMPCS_COMPATIBLE
    // Serialize the argument size
    _status = _logBuff.serializeFrom(
      static_cast<U8>(sizeof(U32))
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif
    _status = _logBuff.serializeFrom(u32);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

#if FW_AMPCS_COMPATIBLE
    // Serialize the argument size
    _status = _logBuff.serializeFrom(
      static_cast<U8>(sizeof(F32))
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif
    _status = _logBuff.serializeFrom(f32);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

#if FW_AMPCS_COMPATIBLE
    // Serialize the argument size
    _status = _logBuff.serializeFrom(
      static_cast<U8>(sizeof(U8))
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif
    _status = _logBuff.serializeFrom(b);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::ACTIVITY_LO,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Activity Low occurred with arguments: %" PRIu32 ", %f, %d";
#else
    const char* _formatString =
      "%s: Event Activity Low occurred with arguments: %" PRIu32 ", %f, %d";
#endif

    Fw::TextLogString _logString;
    _logString.format(
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName.toChar(),
#endif
      "EventActivityLowThrottled ",
      u32,
      static_cast<F64>(f32),
      b
    );

    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::ACTIVITY_LO,
      _logString
    );
  }
#endif
}

void QueuedTestComponentBase ::
  log_COMMAND_EventCommand(
      const Fw::StringBase& str1,
      const Fw::StringBase& str2
  ) const
{
  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTCOMMAND;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
    // Serialize the number of arguments
    _status = _logBuff.serializeFrom(static_cast<U8>(2));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

    _status = str1.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = str2.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 100));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::COMMAND,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Command occurred with arguments: %s, %s";
#else
    const char* _formatString =
      "%s: Event Command occurred with arguments: %s, %s";
#endif

    Fw::TextLogString _logString;
    _logString.format(
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName.toChar(),
#endif
      "EventCommand ",
      str1.toChar(),
      str2.toChar()
    );

    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::COMMAND,
      _logString
    );
  }
#endif
}

void QueuedTestComponentBase ::
  log_DIAGNOSTIC_EventDiagnostic(E e) const
{
  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTDIAGNOSTIC;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
    // Serialize the number of arguments
    _status = _logBuff.serializeFrom(static_cast<U8>(1));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

#if FW_AMPCS_COMPATIBLE
    // Serialize the argument size
    _status = _logBuff.serializeFrom(
      static_cast<U8>(E::SERIALIZED_SIZE)
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif
    _status = _logBuff.serializeFrom(e);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::DIAGNOSTIC,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Diagnostic occurred with argument: %s";
#else
    const char* _formatString =
      "%s: Event Diagnostic occurred with argument: %s";
#endif

    Fw::String eStr;
    e.toString(eStr);

    Fw::TextLogString _logString;
    _logString.format(
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName.toChar(),
#endif
      "EventDiagnostic ",
      eStr.toChar()
    );

    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::DIAGNOSTIC,
      _logString
    );
  }
#endif
}

void QueuedTestComponentBase ::
  log_FATAL_EventFatalThrottled(A a)
{
  // Check throttle value
  if (this->m_EventFatalThrottledThrottle >= EVENTID_EVENTFATALTHROTTLED_THROTTLE) {
    return;
  }
  else {
    (void) this->m_EventFatalThrottledThrottle.fetch_add(1);
  }

  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTFATALTHROTTLED;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
    // Serialize the number of arguments
    _status = _logBuff.serializeFrom(static_cast<U8>(1 + 1));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // For FATAL, add stack size of 4 and a dummy entry. No support for stacks yet.
    _status = _logBuff.serializeFrom(static_cast<U8>(4));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = _logBuff.serializeFrom(static_cast<U32>(0));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

#if FW_AMPCS_COMPATIBLE
    // Serialize the argument size
    _status = _logBuff.serializeFrom(
      static_cast<U8>(A::SERIALIZED_SIZE)
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif
    _status = _logBuff.serializeFrom(a);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::FATAL,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Fatal occurred with argument: %s";
#else
    const char* _formatString =
      "%s: Event Fatal occurred with argument: %s";
#endif

    Fw::String aStr;
    a.toString(aStr);

    Fw::TextLogString _logString;
    _logString.format(
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName.toChar(),
#endif
      "EventFatalThrottled ",
      aStr.toChar()
    );

    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::FATAL,
      _logString
    );
  }
#endif
}

void QueuedTestComponentBase ::
  log_WARNING_HI_EventWarningHigh(S s) const
{
  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTWARNINGHIGH;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
    // Serialize the number of arguments
    _status = _logBuff.serializeFrom(static_cast<U8>(1));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

#if FW_AMPCS_COMPATIBLE
    // Serialize the argument size
    _status = _logBuff.serializeFrom(
      static_cast<U8>(S::SERIALIZED_SIZE)
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif
    _status = _logBuff.serializeFrom(s);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::WARNING_HI,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Warning High occurred with argument: %s";
#else
    const char* _formatString =
      "%s: Event Warning High occurred with argument: %s";
#endif

    Fw::String sStr;
    s.toString(sStr);

    Fw::TextLogString _logString;
    _logString.format(
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName.toChar(),
#endif
      "EventWarningHigh ",
      sStr.toChar()
    );

    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::WARNING_HI,
      _logString
    );
  }
#endif
}

void QueuedTestComponentBase ::
  log_WARNING_LO_EventWarningLowThrottled()
{
  // Check throttle value
  if (this->m_EventWarningLowThrottledThrottle >= EVENTID_EVENTWARNINGLOWTHROTTLED_THROTTLE) {
    return;
  }
  else {
    (void) this->m_EventWarningLowThrottledThrottle.fetch_add(1);
  }

  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTWARNINGLOWTHROTTLED;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;

#if FW_AMPCS_COMPATIBLE
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
    // Serialize the number of arguments
    _status = _logBuff.serializeFrom(static_cast<U8>(0));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::WARNING_LO,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Warning Low occurred";
#else
    const char* _formatString =
      "%s: Event Warning Low occurred";
#endif

    Fw::TextLogString _logString;
    _logString.format(
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName.toChar(),
#endif
      "EventWarningLowThrottled "
    );

    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::WARNING_LO,
      _logString
    );
  }
#endif
}

// ----------------------------------------------------------------------
// Event throttle reset functions
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  log_ACTIVITY_LO_EventActivityLowThrottled_ThrottleClear()
{
  // Reset throttle counter
  this->m_EventActivityLowThrottledThrottle = 0;
}

void QueuedTestComponentBase ::
  log_FATAL_EventFatalThrottled_ThrottleClear()
{
  // Reset throttle counter
  this->m_EventFatalThrottledThrottle = 0;
}

void QueuedTestComponentBase ::
  log_WARNING_LO_EventWarningLowThrottled_ThrottleClear()
{
  // Reset throttle counter
  this->m_EventWarningLowThrottledThrottle = 0;
}

// ----------------------------------------------------------------------
// Telemetry write functions
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  tlmWrite_ChannelU32Format(
      U32 arg,
      Fw::Time _tlmTime
  ) const
{
  if (this->m_tlmOut_OutputPort[0].isConnected()) {
    if (
      this->m_timeGetOut_OutputPort[0].isConnected() &&
      (_tlmTime ==  Fw::ZERO_TIME)
    ) {
      this->m_timeGetOut_OutputPort[0].invoke(_tlmTime);
    }

    Fw::TlmBuffer _tlmBuff;
    Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
    FW_ASSERT(
      _stat == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_stat)
    );

    FwChanIdType _id;

    _id = this->getIdBase() + CHANNELID_CHANNELU32FORMAT;

    this->m_tlmOut_OutputPort[0].invoke(
      _id,
      _tlmTime,
      _tlmBuff
    );
  }
}

void QueuedTestComponentBase ::
  tlmWrite_ChannelF32Format(
      F32 arg,
      Fw::Time _tlmTime
  ) const
{
  if (this->m_tlmOut_OutputPort[0].isConnected()) {
    if (
      this->m_timeGetOut_OutputPort[0].isConnected() &&
      (_tlmTime ==  Fw::ZERO_TIME)
    ) {
      this->m_timeGetOut_OutputPort[0].invoke(_tlmTime);
    }

    Fw::TlmBuffer _tlmBuff;
    Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
    FW_ASSERT(
      _stat == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_stat)
    );

    FwChanIdType _id;

    _id = this->getIdBase() + CHANNELID_CHANNELF32FORMAT;

    this->m_tlmOut_OutputPort[0].invoke(
      _id,
      _tlmTime,
      _tlmBuff
    );
  }
}

void QueuedTestComponentBase ::
  tlmWrite_ChannelStringFormat(
      const Fw::StringBase& arg,
      Fw::Time _tlmTime
  ) const
{
  if (this->m_tlmOut_OutputPort[0].isConnected()) {
    if (
      this->m_timeGetOut_OutputPort[0].isConnected() &&
      (_tlmTime ==  Fw::ZERO_TIME)
    ) {
      this->m_timeGetOut_OutputPort[0].invoke(_tlmTime);
    }

    Fw::TlmBuffer _tlmBuff;
    Fw::SerializeStatus _stat = arg.serializeTo(_tlmBuff, FW_MIN(FW_TLM_STRING_MAX_SIZE, 80));
    FW_ASSERT(
      _stat == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_stat)
    );

    FwChanIdType _id;

    _id = this->getIdBase() + CHANNELID_CHANNELSTRINGFORMAT;

    this->m_tlmOut_OutputPort[0].invoke(
      _id,
      _tlmTime,
      _tlmBuff
    );
  }
}

void QueuedTestComponentBase ::
  tlmWrite_ChannelEnum(
      const E& arg,
      Fw::Time _tlmTime
  ) const
{
  if (this->m_tlmOut_OutputPort[0].isConnected()) {
    if (
      this->m_timeGetOut_OutputPort[0].isConnected() &&
      (_tlmTime ==  Fw::ZERO_TIME)
    ) {
      this->m_timeGetOut_OutputPort[0].invoke(_tlmTime);
    }

    Fw::TlmBuffer _tlmBuff;
    Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
    FW_ASSERT(
      _stat == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_stat)
    );

    FwChanIdType _id;

    _id = this->getIdBase() + CHANNELID_CHANNELENUM;

    this->m_tlmOut_OutputPort[0].invoke(
      _id,
      _tlmTime,
      _tlmBuff
    );
  }
}

void QueuedTestComponentBase ::
  tlmWrite_ChannelArrayFreq(
      const A& arg,
      Fw::Time _tlmTime
  ) const
{
  if (this->m_tlmOut_OutputPort[0].isConnected()) {
    if (
      this->m_timeGetOut_OutputPort[0].isConnected() &&
      (_tlmTime ==  Fw::ZERO_TIME)
    ) {
      this->m_timeGetOut_OutputPort[0].invoke(_tlmTime);
    }

    Fw::TlmBuffer _tlmBuff;
    Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
    FW_ASSERT(
      _stat == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_stat)
    );

    FwChanIdType _id;

    _id = this->getIdBase() + CHANNELID_CHANNELARRAYFREQ;

    this->m_tlmOut_OutputPort[0].invoke(
      _id,
      _tlmTime,
      _tlmBuff
    );
  }
}

void QueuedTestComponentBase ::
  tlmWrite_ChannelStructFreq(
      const S& arg,
      Fw::Time _tlmTime
  ) const
{
  if (this->m_tlmOut_OutputPort[0].isConnected()) {
    if (
      this->m_timeGetOut_OutputPort[0].isConnected() &&
      (_tlmTime ==  Fw::ZERO_TIME)
    ) {
      this->m_timeGetOut_OutputPort[0].invoke(_tlmTime);
    }

    Fw::TlmBuffer _tlmBuff;
    Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
    FW_ASSERT(
      _stat == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_stat)
    );

    FwChanIdType _id;

    _id = this->getIdBase() + CHANNELID_CHANNELSTRUCTFREQ;

    this->m_tlmOut_OutputPort[0].invoke(
      _id,
      _tlmTime,
      _tlmBuff
    );
  }
}

void QueuedTestComponentBase ::
  tlmWrite_ChannelU32Limits(
      U32 arg,
      Fw::Time _tlmTime
  ) const
{
  if (this->m_tlmOut_OutputPort[0].isConnected()) {
    if (
      this->m_timeGetOut_OutputPort[0].isConnected() &&
      (_tlmTime ==  Fw::ZERO_TIME)
    ) {
      this->m_timeGetOut_OutputPort[0].invoke(_tlmTime);
    }

    Fw::TlmBuffer _tlmBuff;
    Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
    FW_ASSERT(
      _stat == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_stat)
    );

    FwChanIdType _id;

    _id = this->getIdBase() + CHANNELID_CHANNELU32LIMITS;

    this->m_tlmOut_OutputPort[0].invoke(
      _id,
      _tlmTime,
      _tlmBuff
    );
  }
}

void QueuedTestComponentBase ::
  tlmWrite_ChannelF32Limits(
      F32 arg,
      Fw::Time _tlmTime
  ) const
{
  if (this->m_tlmOut_OutputPort[0].isConnected()) {
    if (
      this->m_timeGetOut_OutputPort[0].isConnected() &&
      (_tlmTime ==  Fw::ZERO_TIME)
    ) {
      this->m_timeGetOut_OutputPort[0].invoke(_tlmTime);
    }

    Fw::TlmBuffer _tlmBuff;
    Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
    FW_ASSERT(
      _stat == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_stat)
    );

    FwChanIdType _id;

    _id = this->getIdBase() + CHANNELID_CHANNELF32LIMITS;

    this->m_tlmOut_OutputPort[0].invoke(
      _id,
      _tlmTime,
      _tlmBuff
    );
  }
}

void QueuedTestComponentBase ::
  tlmWrite_ChannelF64(
      F64 arg,
      Fw::Time _tlmTime
  ) const
{
  if (this->m_tlmOut_OutputPort[0].isConnected()) {
    if (
      this->m_timeGetOut_OutputPort[0].isConnected() &&
      (_tlmTime ==  Fw::ZERO_TIME)
    ) {
      this->m_timeGetOut_OutputPort[0].invoke(_tlmTime);
    }

    Fw::TlmBuffer _tlmBuff;
    Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
    FW_ASSERT(
      _stat == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_stat)
    );

    FwChanIdType _id;

    _id = this->getIdBase() + CHANNELID_CHANNELF64;

    this->m_tlmOut_OutputPort[0].invoke(
      _id,
      _tlmTime,
      _tlmBuff
    );
  }
}

void QueuedTestComponentBase ::
  tlmWrite_ChannelU32OnChange(
      U32 arg,
      Fw::Time _tlmTime
  )
{
  // Check to see if it is the first time
  if (not this->m_first_update_ChannelU32OnChange) {
    // Check to see if value has changed. If not, don't write it.
    if (arg == this->m_last_ChannelU32OnChange) {
      return;
    }
    else {
      this->m_last_ChannelU32OnChange = arg;
    }
  }
  else {
    this->m_first_update_ChannelU32OnChange = false;
    this->m_last_ChannelU32OnChange = arg;
  }

  if (this->m_tlmOut_OutputPort[0].isConnected()) {
    if (
      this->m_timeGetOut_OutputPort[0].isConnected() &&
      (_tlmTime ==  Fw::ZERO_TIME)
    ) {
      this->m_timeGetOut_OutputPort[0].invoke(_tlmTime);
    }

    Fw::TlmBuffer _tlmBuff;
    Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
    FW_ASSERT(
      _stat == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_stat)
    );

    FwChanIdType _id;

    _id = this->getIdBase() + CHANNELID_CHANNELU32ONCHANGE;

    this->m_tlmOut_OutputPort[0].invoke(
      _id,
      _tlmTime,
      _tlmBuff
    );
  }
}

void QueuedTestComponentBase ::
  tlmWrite_ChannelEnumOnChange(
      const E& arg,
      Fw::Time _tlmTime
  )
{
  // Check to see if it is the first time
  if (not this->m_first_update_ChannelEnumOnChange) {
    // Check to see if value has changed. If not, don't write it.
    if (arg == this->m_last_ChannelEnumOnChange) {
      return;
    }
    else {
      this->m_last_ChannelEnumOnChange = arg;
    }
  }
  else {
    this->m_first_update_ChannelEnumOnChange = false;
    this->m_last_ChannelEnumOnChange = arg;
  }

  if (this->m_tlmOut_OutputPort[0].isConnected()) {
    if (
      this->m_timeGetOut_OutputPort[0].isConnected() &&
      (_tlmTime ==  Fw::ZERO_TIME)
    ) {
      this->m_timeGetOut_OutputPort[0].invoke(_tlmTime);
    }

    Fw::TlmBuffer _tlmBuff;
    Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
    FW_ASSERT(
      _stat == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_stat)
    );

    FwChanIdType _id;

    _id = this->getIdBase() + CHANNELID_CHANNELENUMONCHANGE;

    this->m_tlmOut_OutputPort[0].invoke(
      _id,
      _tlmTime,
      _tlmBuff
    );
  }
}

// ----------------------------------------------------------------------
// Parameter update hook
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  parameterUpdated(FwPrmIdType id)
{
  // Do nothing by default
}

void QueuedTestComponentBase ::
  parametersLoaded()
{
  // Do nothing by default
}

// ----------------------------------------------------------------------
// Parameter get functions
// ----------------------------------------------------------------------

U32 QueuedTestComponentBase ::
  paramGet_ParamU32(Fw::ParamValid& valid)
{
  U32 _local{};
  this->m_paramLock.lock();
  valid = this->m_param_ParamU32_valid;
  _local = this->m_ParamU32;
  this->m_paramLock.unLock();
  return _local;
}

F64 QueuedTestComponentBase ::
  paramGet_ParamF64(Fw::ParamValid& valid)
{
  F64 _local{};
  this->m_paramLock.lock();
  valid = this->m_param_ParamF64_valid;
  _local = this->m_ParamF64;
  this->m_paramLock.unLock();
  return _local;
}

Fw::ParamString QueuedTestComponentBase ::
  paramGet_ParamString(Fw::ParamValid& valid)
{
  Fw::ParamString _local{};
  this->m_paramLock.lock();
  valid = this->m_param_ParamString_valid;
  _local = this->m_ParamString;
  this->m_paramLock.unLock();
  return _local;
}

E QueuedTestComponentBase ::
  paramGet_ParamEnum(Fw::ParamValid& valid)
{
  E _local{};
  this->m_paramLock.lock();
  valid = this->m_param_ParamEnum_valid;
  _local = this->m_ParamEnum;
  this->m_paramLock.unLock();
  return _local;
}

A QueuedTestComponentBase ::
  paramGet_ParamArray(Fw::ParamValid& valid)
{
  A _local{};
  this->m_paramLock.lock();
  valid = this->m_param_ParamArray_valid;
  _local = this->m_ParamArray;
  this->m_paramLock.unLock();
  return _local;
}

S QueuedTestComponentBase ::
  paramGet_ParamStruct(Fw::ParamValid& valid)
{
  S _local{};
  this->m_paramLock.lock();
  valid = this->m_param_ParamStruct_valid;
  _local = this->m_ParamStruct;
  this->m_paramLock.unLock();
  return _local;
}

I32 QueuedTestComponentBase ::
  paramGet_ParamI32Ext(Fw::ParamValid& valid)
{
  I32 _local{};
  Fw::ParamBuffer _getBuff;
  // Get the base ID
  const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());
  // Get the local ID to pass to the delegate
  const FwPrmIdType _localId = PARAMID_PARAMI32EXT;

  FW_ASSERT(this->paramDelegatePtr != NULL);
  // Get the external parameter from the delegate
  Fw::SerializeStatus _stat = this->paramDelegatePtr->serializeParam(_baseId, _localId, _getBuff);
  if(_stat == Fw::FW_SERIALIZE_OK) {
    _stat = _getBuff.deserializeTo(_local);
    FW_ASSERT(_stat == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_stat));
    valid = Fw::ParamValid::VALID;
  } else {
    valid = Fw::ParamValid::INVALID;
  }
  return _local;
}

F64 QueuedTestComponentBase ::
  paramGet_ParamF64Ext(Fw::ParamValid& valid)
{
  F64 _local{};
  Fw::ParamBuffer _getBuff;
  // Get the base ID
  const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());
  // Get the local ID to pass to the delegate
  const FwPrmIdType _localId = PARAMID_PARAMF64EXT;

  FW_ASSERT(this->paramDelegatePtr != NULL);
  // Get the external parameter from the delegate
  Fw::SerializeStatus _stat = this->paramDelegatePtr->serializeParam(_baseId, _localId, _getBuff);
  if(_stat == Fw::FW_SERIALIZE_OK) {
    _stat = _getBuff.deserializeTo(_local);
    FW_ASSERT(_stat == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_stat));
    valid = Fw::ParamValid::VALID;
  } else {
    valid = Fw::ParamValid::INVALID;
  }
  return _local;
}

Fw::ParamString QueuedTestComponentBase ::
  paramGet_ParamStringExt(Fw::ParamValid& valid)
{
  Fw::ParamString _local{};
  Fw::ParamBuffer _getBuff;
  // Get the base ID
  const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());
  // Get the local ID to pass to the delegate
  const FwPrmIdType _localId = PARAMID_PARAMSTRINGEXT;

  FW_ASSERT(this->paramDelegatePtr != NULL);
  // Get the external parameter from the delegate
  Fw::SerializeStatus _stat = this->paramDelegatePtr->serializeParam(_baseId, _localId, _getBuff);
  if(_stat == Fw::FW_SERIALIZE_OK) {
    _stat = _getBuff.deserializeTo(_local);
    FW_ASSERT(_stat == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_stat));
    valid = Fw::ParamValid::VALID;
  } else {
    valid = Fw::ParamValid::INVALID;
  }
  return _local;
}

E QueuedTestComponentBase ::
  paramGet_ParamEnumExt(Fw::ParamValid& valid)
{
  E _local{};
  Fw::ParamBuffer _getBuff;
  // Get the base ID
  const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());
  // Get the local ID to pass to the delegate
  const FwPrmIdType _localId = PARAMID_PARAMENUMEXT;

  FW_ASSERT(this->paramDelegatePtr != NULL);
  // Get the external parameter from the delegate
  Fw::SerializeStatus _stat = this->paramDelegatePtr->serializeParam(_baseId, _localId, _getBuff);
  if(_stat == Fw::FW_SERIALIZE_OK) {
    _stat = _getBuff.deserializeTo(_local);
    FW_ASSERT(_stat == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_stat));
    valid = Fw::ParamValid::VALID;
  } else {
    valid = Fw::ParamValid::INVALID;
  }
  return _local;
}

A QueuedTestComponentBase ::
  paramGet_ParamArrayExt(Fw::ParamValid& valid)
{
  A _local{};
  Fw::ParamBuffer _getBuff;
  // Get the base ID
  const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());
  // Get the local ID to pass to the delegate
  const FwPrmIdType _localId = PARAMID_PARAMARRAYEXT;

  FW_ASSERT(this->paramDelegatePtr != NULL);
  // Get the external parameter from the delegate
  Fw::SerializeStatus _stat = this->paramDelegatePtr->serializeParam(_baseId, _localId, _getBuff);
  if(_stat == Fw::FW_SERIALIZE_OK) {
    _stat = _getBuff.deserializeTo(_local);
    FW_ASSERT(_stat == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_stat));
    valid = Fw::ParamValid::VALID;
  } else {
    valid = Fw::ParamValid::INVALID;
  }
  return _local;
}

S QueuedTestComponentBase ::
  paramGet_ParamStructExt(Fw::ParamValid& valid)
{
  S _local{};
  Fw::ParamBuffer _getBuff;
  // Get the base ID
  const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());
  // Get the local ID to pass to the delegate
  const FwPrmIdType _localId = PARAMID_PARAMSTRUCTEXT;

  FW_ASSERT(this->paramDelegatePtr != NULL);
  // Get the external parameter from the delegate
  Fw::SerializeStatus _stat = this->paramDelegatePtr->serializeParam(_baseId, _localId, _getBuff);
  if(_stat == Fw::FW_SERIALIZE_OK) {
    _stat = _getBuff.deserializeTo(_local);
    FW_ASSERT(_stat == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_stat));
    valid = Fw::ParamValid::VALID;
  } else {
    valid = Fw::ParamValid::INVALID;
  }
  return _local;
}

// ----------------------------------------------------------------------
// External parameter delegate initialization
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  registerExternalParameters(Fw::ParamExternalDelegate* paramExternalDelegatePtr)
{
  FW_ASSERT(paramExternalDelegatePtr != NULL);
  this->paramDelegatePtr = paramExternalDelegatePtr;
}

// ----------------------------------------------------------------------
// Functions for managing data products
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  dpSend(
      DpContainer& container,
      Fw::Time timeTag
  )
{
  // Update the time tag
  if (timeTag == Fw::ZERO_TIME) {
    // Get the time from the time port
    timeTag = this->getTime();
  }
  container.setTimeTag(timeTag);
  // Serialize the header into the packet
  container.serializeHeader();
  // Update the data hash
  container.updateDataHash();
  // Update the size of the buffer according to the data size
  const FwSizeType packetSize = container.getPacketSize();
  Fw::Buffer buffer = container.getBuffer();
  FW_ASSERT(packetSize <= buffer.getSize(), static_cast<FwAssertArgType>(packetSize),
      static_cast<FwAssertArgType>(buffer.getSize()));
  buffer.setSize(static_cast<U32>(packetSize));
  // Invalidate the buffer in the container, so it can't be reused
  container.invalidateBuffer();
  // Send the buffer
  this->productSendOut_out(0, container.getId(), buffer);
}

// ----------------------------------------------------------------------
// Time
// ----------------------------------------------------------------------

Fw::Time QueuedTestComponentBase ::
  getTime() const
{
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    Fw::Time _time;
    this->m_timeGetOut_OutputPort[0].invoke(_time);
    return _time;
  }
  else {
    return Fw::Time(TimeBase::TB_NONE, 0, 0);
  }
}

// ----------------------------------------------------------------------
// Mutex operations for guarded ports
//
// You can override these operations to provide more sophisticated
// synchronization
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  lock()
{
  this->m_guardedPortMutex.lock();
}

void QueuedTestComponentBase ::
  unLock()
{
  this->m_guardedPortMutex.unLock();
}

// ----------------------------------------------------------------------
// Message dispatch functions
// ----------------------------------------------------------------------

Fw::QueuedComponentBase::MsgDispatchStatus QueuedTestComponentBase ::
  doDispatch()
{
  ComponentIpcSerializableBuffer _msg;
  FwQueuePriorityType _priority = 0;

  Os::Queue::Status _msgStatus = this->m_queue.receive(
    _msg,
    Os::Queue::NONBLOCKING,
    _priority
  );
  if (Os::Queue::Status::EMPTY == _msgStatus) {
    return Fw::QueuedComponentBase::MSG_DISPATCH_EMPTY;
  }
  else {
    FW_ASSERT(
      _msgStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(_msgStatus)
    );
  }

  // Reset to beginning of buffer
  _msg.resetDeser();

  FwEnumStoreType _desMsg = 0;
  Fw::SerializeStatus _deserStatus = _msg.deserializeTo(_desMsg);
  FW_ASSERT(
    _deserStatus == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_deserStatus)
  );

  MsgTypeEnum _msgType = static_cast<MsgTypeEnum>(_desMsg);

  if (_msgType == QUEUEDTEST_COMPONENT_EXIT) {
    return MSG_DISPATCH_EXIT;
  }

  FwIndexType portNum = 0;
  _deserStatus = _msg.deserializeTo(portNum);
  FW_ASSERT(
    _deserStatus == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_deserStatus)
  );

  switch (_msgType) {
    // Handle async input port productRecvIn
    case PRODUCTRECVIN_DPRESPONSE: {
      // Deserialize argument id
      FwDpIdType id;
      _deserStatus = _msg.deserializeTo(id);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument buffer
      Fw::Buffer buffer;
      _deserStatus = _msg.deserializeTo(buffer);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument status
      Fw::Success status;
      _deserStatus = _msg.deserializeTo(status);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );
      // Call handler function
      this->productRecvIn_handler(
        portNum,
        id,
        buffer,
        status
      );

      break;
    }

    // Handle async input port aliasTypedAsync
    case ALIASTYPEDASYNC_ALIASTYPED: {
      // Deserialize argument u32
      AliasPrim1 u32;
      _deserStatus = _msg.deserializeTo(u32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument f32
      AliasPrim2 f32;
      _deserStatus = _msg.deserializeTo(f32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument b
      AliasBool b;
      _deserStatus = _msg.deserializeTo(b);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument str2
      char __fprime_ac_str2_buffer[Fw::StringBase::BUFFER_SIZE(32)];
      Fw::ExternalString str2(__fprime_ac_str2_buffer, sizeof __fprime_ac_str2_buffer);
      _deserStatus = _msg.deserializeTo(str2);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument e
      AliasEnum e;
      _deserStatus = _msg.deserializeTo(e);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument a
      AliasArray a;
      _deserStatus = _msg.deserializeTo(a);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument s
      AliasStruct s;
      _deserStatus = _msg.deserializeTo(s);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );
      // Call handler function
      this->aliasTypedAsync_handler(
        portNum,
        u32,
        f32,
        b,
        str2,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port noArgsAsync
    case NOARGSASYNC_NOARGS: {
      // Call handler function
      this->noArgsAsync_handler(portNum);

      break;
    }

    // Handle async input port typedAsync
    case TYPEDASYNC_TYPED: {
      // Deserialize argument u32
      U32 u32;
      _deserStatus = _msg.deserializeTo(u32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      _deserStatus = _msg.deserializeTo(f32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument b
      bool b;
      _deserStatus = _msg.deserializeTo(b);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument str1
      char __fprime_ac_str1_buffer[Fw::StringBase::BUFFER_SIZE(80)];
      Fw::ExternalString str1(__fprime_ac_str1_buffer, sizeof __fprime_ac_str1_buffer);
      _deserStatus = _msg.deserializeTo(str1);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument e
      E e;
      _deserStatus = _msg.deserializeTo(e);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument a
      A a;
      _deserStatus = _msg.deserializeTo(a);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument s
      S s;
      _deserStatus = _msg.deserializeTo(s);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );
      // Call handler function
      this->typedAsync_handler(
        portNum,
        u32,
        f32,
        b,
        str1,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port typedAsyncAssert
    case TYPEDASYNCASSERT_TYPED: {
      // Deserialize argument u32
      U32 u32;
      _deserStatus = _msg.deserializeTo(u32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      _deserStatus = _msg.deserializeTo(f32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument b
      bool b;
      _deserStatus = _msg.deserializeTo(b);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument str1
      char __fprime_ac_str1_buffer[Fw::StringBase::BUFFER_SIZE(80)];
      Fw::ExternalString str1(__fprime_ac_str1_buffer, sizeof __fprime_ac_str1_buffer);
      _deserStatus = _msg.deserializeTo(str1);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument e
      E e;
      _deserStatus = _msg.deserializeTo(e);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument a
      A a;
      _deserStatus = _msg.deserializeTo(a);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument s
      S s;
      _deserStatus = _msg.deserializeTo(s);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );
      // Call handler function
      this->typedAsyncAssert_handler(
        portNum,
        u32,
        f32,
        b,
        str1,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port typedAsyncBlockPriority
    case TYPEDASYNCBLOCKPRIORITY_TYPED: {
      // Deserialize argument u32
      U32 u32;
      _deserStatus = _msg.deserializeTo(u32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      _deserStatus = _msg.deserializeTo(f32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument b
      bool b;
      _deserStatus = _msg.deserializeTo(b);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument str1
      char __fprime_ac_str1_buffer[Fw::StringBase::BUFFER_SIZE(80)];
      Fw::ExternalString str1(__fprime_ac_str1_buffer, sizeof __fprime_ac_str1_buffer);
      _deserStatus = _msg.deserializeTo(str1);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument e
      E e;
      _deserStatus = _msg.deserializeTo(e);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument a
      A a;
      _deserStatus = _msg.deserializeTo(a);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument s
      S s;
      _deserStatus = _msg.deserializeTo(s);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );
      // Call handler function
      this->typedAsyncBlockPriority_handler(
        portNum,
        u32,
        f32,
        b,
        str1,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port typedAsyncDropPriority
    case TYPEDASYNCDROPPRIORITY_TYPED: {
      // Deserialize argument u32
      U32 u32;
      _deserStatus = _msg.deserializeTo(u32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      _deserStatus = _msg.deserializeTo(f32);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument b
      bool b;
      _deserStatus = _msg.deserializeTo(b);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument str1
      char __fprime_ac_str1_buffer[Fw::StringBase::BUFFER_SIZE(80)];
      Fw::ExternalString str1(__fprime_ac_str1_buffer, sizeof __fprime_ac_str1_buffer);
      _deserStatus = _msg.deserializeTo(str1);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument e
      E e;
      _deserStatus = _msg.deserializeTo(e);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument a
      A a;
      _deserStatus = _msg.deserializeTo(a);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize argument s
      S s;
      _deserStatus = _msg.deserializeTo(s);
      FW_ASSERT(
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );
      // Call handler function
      this->typedAsyncDropPriority_handler(
        portNum,
        u32,
        f32,
        b,
        str1,
        e,
        a,
        s
      );

      break;
    }

    // Handle command CMD_ASYNC
    case CMD_CMD_ASYNC: {
      // Deserialize opcode
      FwOpcodeType _opCode = 0;
      _deserStatus = _msg.deserializeTo(_opCode);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command sequence
      U32 _cmdSeq = 0;
      _deserStatus = _msg.deserializeTo(_cmdSeq);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command argument buffer
      Fw::CmdArgBuffer args;
      _deserStatus = _msg.deserializeTo(args);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Reset buffer
      args.resetDeser();

      // Make sure there was no data left over.
      // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
      if (args.getBuffLeft() != 0) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }
#endif

      // Call handler function
      this->CMD_ASYNC_cmdHandler(_opCode, _cmdSeq);

      break;
    }

    // Handle command CMD_PRIORITY
    case CMD_CMD_PRIORITY: {
      // Deserialize opcode
      FwOpcodeType _opCode = 0;
      _deserStatus = _msg.deserializeTo(_opCode);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command sequence
      U32 _cmdSeq = 0;
      _deserStatus = _msg.deserializeTo(_cmdSeq);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command argument buffer
      Fw::CmdArgBuffer args;
      _deserStatus = _msg.deserializeTo(args);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Reset buffer
      args.resetDeser();

      // Make sure there was no data left over.
      // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
      if (args.getBuffLeft() != 0) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }
#endif

      // Call handler function
      this->CMD_PRIORITY_cmdHandler(_opCode, _cmdSeq);

      break;
    }

    // Handle command CMD_PARAMS_PRIORITY
    case CMD_CMD_PARAMS_PRIORITY: {
      // Deserialize opcode
      FwOpcodeType _opCode = 0;
      _deserStatus = _msg.deserializeTo(_opCode);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command sequence
      U32 _cmdSeq = 0;
      _deserStatus = _msg.deserializeTo(_cmdSeq);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command argument buffer
      Fw::CmdArgBuffer args;
      _deserStatus = _msg.deserializeTo(args);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Reset buffer
      args.resetDeser();

      // Deserialize argument u32
      U32 u32;
      _deserStatus = args.deserializeTo(u32);
      if (_deserStatus != Fw::FW_SERIALIZE_OK) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(
              _opCode,
              _cmdSeq,
              Fw::CmdResponse::FORMAT_ERROR
          );
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }

      // Make sure there was no data left over.
      // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
      if (args.getBuffLeft() != 0) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }
#endif

      // Call handler function
      this->CMD_PARAMS_PRIORITY_cmdHandler(
        _opCode, _cmdSeq,
        u32
      );

      break;
    }

    // Handle command CMD_DROP
    case CMD_CMD_DROP: {
      // Deserialize opcode
      FwOpcodeType _opCode = 0;
      _deserStatus = _msg.deserializeTo(_opCode);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command sequence
      U32 _cmdSeq = 0;
      _deserStatus = _msg.deserializeTo(_cmdSeq);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command argument buffer
      Fw::CmdArgBuffer args;
      _deserStatus = _msg.deserializeTo(args);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Reset buffer
      args.resetDeser();

      // Make sure there was no data left over.
      // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
      if (args.getBuffLeft() != 0) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }
#endif

      // Call handler function
      this->CMD_DROP_cmdHandler(_opCode, _cmdSeq);

      break;
    }

    // Handle command CMD_PARAMS_PRIORITY_DROP
    case CMD_CMD_PARAMS_PRIORITY_DROP: {
      // Deserialize opcode
      FwOpcodeType _opCode = 0;
      _deserStatus = _msg.deserializeTo(_opCode);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command sequence
      U32 _cmdSeq = 0;
      _deserStatus = _msg.deserializeTo(_cmdSeq);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Deserialize command argument buffer
      Fw::CmdArgBuffer args;
      _deserStatus = _msg.deserializeTo(args);
      FW_ASSERT (
        _deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Reset buffer
      args.resetDeser();

      // Deserialize argument u32
      U32 u32;
      _deserStatus = args.deserializeTo(u32);
      if (_deserStatus != Fw::FW_SERIALIZE_OK) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(
              _opCode,
              _cmdSeq,
              Fw::CmdResponse::FORMAT_ERROR
          );
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }

      // Make sure there was no data left over.
      // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
      if (args.getBuffLeft() != 0) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }
#endif

      // Call handler function
      this->CMD_PARAMS_PRIORITY_DROP_cmdHandler(
        _opCode, _cmdSeq,
        u32
      );

      break;
    }

    // Handle internal interface internalArray
    case INT_IF_INTERNALARRAY: {
      A a;
      _deserStatus = _msg.deserializeTo(a);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == _deserStatus,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Make sure there was no data left over.
      // That means the buffer size was incorrect.
      FW_ASSERT(
        _msg.getBuffLeft() == 0,
        static_cast<FwAssertArgType>(_msg.getBuffLeft())
      );

      // Call handler function
      this->internalArray_internalInterfaceHandler(
        a
      );

      break;
    }

    // Handle internal interface internalEnum
    case INT_IF_INTERNALENUM: {
      E e;
      _deserStatus = _msg.deserializeTo(e);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == _deserStatus,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Make sure there was no data left over.
      // That means the buffer size was incorrect.
      FW_ASSERT(
        _msg.getBuffLeft() == 0,
        static_cast<FwAssertArgType>(_msg.getBuffLeft())
      );

      // Call handler function
      this->internalEnum_internalInterfaceHandler(
        e
      );

      break;
    }

    // Handle internal interface internalPrimitive
    case INT_IF_INTERNALPRIMITIVE: {
      U32 u32;
      _deserStatus = _msg.deserializeTo(u32);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == _deserStatus,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      F32 f32;
      _deserStatus = _msg.deserializeTo(f32);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == _deserStatus,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      bool b;
      _deserStatus = _msg.deserializeTo(b);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == _deserStatus,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Make sure there was no data left over.
      // That means the buffer size was incorrect.
      FW_ASSERT(
        _msg.getBuffLeft() == 0,
        static_cast<FwAssertArgType>(_msg.getBuffLeft())
      );

      // Call handler function
      this->internalPrimitive_internalInterfaceHandler(
        u32,
        f32,
        b
      );

      break;
    }

    // Handle internal interface internalPriorityDrop
    case INT_IF_INTERNALPRIORITYDROP: {
      // Make sure there was no data left over.
      // That means the buffer size was incorrect.
      FW_ASSERT(
        _msg.getBuffLeft() == 0,
        static_cast<FwAssertArgType>(_msg.getBuffLeft())
      );

      // Call handler function
      this->internalPriorityDrop_internalInterfaceHandler();

      break;
    }

    // Handle internal interface internalString
    case INT_IF_INTERNALSTRING: {
      Fw::InternalInterfaceString str1;
      _deserStatus = _msg.deserializeTo(str1);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == _deserStatus,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      Fw::InternalInterfaceString str2;
      _deserStatus = _msg.deserializeTo(str2);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == _deserStatus,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Make sure there was no data left over.
      // That means the buffer size was incorrect.
      FW_ASSERT(
        _msg.getBuffLeft() == 0,
        static_cast<FwAssertArgType>(_msg.getBuffLeft())
      );

      // Call handler function
      this->internalString_internalInterfaceHandler(
        str1,
        str2
      );

      break;
    }

    // Handle internal interface internalStruct
    case INT_IF_INTERNALSTRUCT: {
      S s;
      _deserStatus = _msg.deserializeTo(s);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == _deserStatus,
        static_cast<FwAssertArgType>(_deserStatus)
      );

      // Make sure there was no data left over.
      // That means the buffer size was incorrect.
      FW_ASSERT(
        _msg.getBuffLeft() == 0,
        static_cast<FwAssertArgType>(_msg.getBuffLeft())
      );

      // Call handler function
      this->internalStruct_internalInterfaceHandler(
        s
      );

      break;
    }

    default:
      return MSG_DISPATCH_ERROR;
  }

  return MSG_DISPATCH_OK;
}

// ----------------------------------------------------------------------
// Helper functions for dispatching current messages
// ----------------------------------------------------------------------

Fw::QueuedComponentBase::MsgDispatchStatus QueuedTestComponentBase ::
  dispatchCurrentMessages()
{
  // Dispatch all current messages unless ERROR or EXIT occur
  const FwSizeType currentMessageCount = this->m_queue.getMessagesAvailable();
  MsgDispatchStatus messageStatus = MsgDispatchStatus::MSG_DISPATCH_EMPTY;
  for (FwSizeType i = 0; i < currentMessageCount; i++) {
    messageStatus = this->doDispatch();
    if (messageStatus != QueuedComponentBase::MSG_DISPATCH_OK) {
      break;
    }
  }
  return messageStatus;
}

// ----------------------------------------------------------------------
// Calls for messages received on special input ports
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  m_p_cmdIn_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);

  const U32 idBase = callComp->getIdBase();
  FW_ASSERT(opCode >= idBase, static_cast<FwAssertArgType>(opCode), static_cast<FwAssertArgType>(idBase));

  // Select base class function based on opcode
  switch (opCode - idBase) {
    case OPCODE_CMD_SYNC: {
      compPtr->CMD_SYNC_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_SYNC_PRIMITIVE: {
      compPtr->CMD_SYNC_PRIMITIVE_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_SYNC_STRING: {
      compPtr->CMD_SYNC_STRING_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_SYNC_ENUM: {
      compPtr->CMD_SYNC_ENUM_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_SYNC_ARRAY: {
      compPtr->CMD_SYNC_ARRAY_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_SYNC_STRUCT: {
      compPtr->CMD_SYNC_STRUCT_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_GUARDED: {
      compPtr->CMD_GUARDED_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_GUARDED_PRIMITIVE: {
      compPtr->CMD_GUARDED_PRIMITIVE_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_GUARDED_STRING: {
      compPtr->CMD_GUARDED_STRING_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_GUARDED_ENUM: {
      compPtr->CMD_GUARDED_ENUM_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_GUARDED_ARRAY: {
      compPtr->CMD_GUARDED_ARRAY_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_GUARDED_STRUCT: {
      compPtr->CMD_GUARDED_STRUCT_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_ASYNC: {
      compPtr->CMD_ASYNC_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_PRIORITY: {
      compPtr->CMD_PRIORITY_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_PARAMS_PRIORITY: {
      compPtr->CMD_PARAMS_PRIORITY_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_DROP: {
      compPtr->CMD_DROP_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_PARAMS_PRIORITY_DROP: {
      compPtr->CMD_PARAMS_PRIORITY_DROP_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_PARAMU32_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamU32(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMU32_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamU32();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMF64_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamF64(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMF64_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamF64();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRING_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamString(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRING_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamString();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMENUM_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamEnum(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMENUM_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamEnum();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMARRAY_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamArray(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMARRAY_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamArray();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRUCT_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamStruct(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRUCT_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamStruct();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMI32EXT_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamI32Ext(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMI32EXT_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamI32Ext();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMF64EXT_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamF64Ext(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMF64EXT_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamF64Ext();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRINGEXT_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamStringExt(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRINGEXT_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamStringExt();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMENUMEXT_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamEnumExt(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMENUMEXT_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamEnumExt();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMARRAYEXT_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamArrayExt(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMARRAYEXT_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamArrayExt();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRUCTEXT_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamStructExt(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRUCTEXT_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamStructExt();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }
  }
}

void QueuedTestComponentBase ::
  m_p_productRecvIn_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      FwDpIdType id,
      const Fw::Buffer& buffer,
      const Fw::Success& status
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  compPtr->productRecvIn_handlerBase(
    portNum,
    id,
    buffer,
    status
  );
}

// ----------------------------------------------------------------------
// Calls for messages received on typed input ports
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  m_p_aliasTypedAsync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  compPtr->aliasTypedAsync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

Fw::String QueuedTestComponentBase ::
  m_p_noArgsAliasStringReturnSync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  return compPtr->noArgsAliasStringReturnSync_handlerBase(portNum);
}

void QueuedTestComponentBase ::
  m_p_noArgsAsync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  compPtr->noArgsAsync_handlerBase(portNum);
}

void QueuedTestComponentBase ::
  m_p_noArgsGuarded_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  compPtr->noArgsGuarded_handlerBase(portNum);
}

U32 QueuedTestComponentBase ::
  m_p_noArgsReturnGuarded_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  return compPtr->noArgsReturnGuarded_handlerBase(portNum);
}

U32 QueuedTestComponentBase ::
  m_p_noArgsReturnSync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  return compPtr->noArgsReturnSync_handlerBase(portNum);
}

Fw::String QueuedTestComponentBase ::
  m_p_noArgsStringReturnSync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  return compPtr->noArgsStringReturnSync_handlerBase(portNum);
}

void QueuedTestComponentBase ::
  m_p_noArgsSync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  compPtr->noArgsSync_handlerBase(portNum);
}

void QueuedTestComponentBase ::
  m_p_typedAliasGuarded_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  compPtr->typedAliasGuarded_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

AliasPrim2 QueuedTestComponentBase ::
  m_p_typedAliasReturnSync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  return compPtr->typedAliasReturnSync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

Fw::String QueuedTestComponentBase ::
  m_p_typedAliasStringReturnSync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AnotherAliasStruct& s
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  return compPtr->typedAliasStringReturnSync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void QueuedTestComponentBase ::
  m_p_typedAsync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  compPtr->typedAsync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedTestComponentBase ::
  m_p_typedAsyncAssert_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  compPtr->typedAsyncAssert_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedTestComponentBase ::
  m_p_typedAsyncBlockPriority_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  compPtr->typedAsyncBlockPriority_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedTestComponentBase ::
  m_p_typedAsyncDropPriority_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  compPtr->typedAsyncDropPriority_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedTestComponentBase ::
  m_p_typedGuarded_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  compPtr->typedGuarded_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 QueuedTestComponentBase ::
  m_p_typedReturnGuarded_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  return compPtr->typedReturnGuarded_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

F32 QueuedTestComponentBase ::
  m_p_typedReturnSync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  return compPtr->typedReturnSync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void QueuedTestComponentBase ::
  m_p_typedSync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedTestComponentBase* compPtr = static_cast<QueuedTestComponentBase*>(callComp);
  compPtr->typedSync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Parameter set functions
// ----------------------------------------------------------------------

Fw::CmdResponse QueuedTestComponentBase ::
  paramSet_ParamU32(Fw::SerializeBufferBase& val)
{
  U32 _localVal{};
  const Fw::SerializeStatus _stat = val.deserializeTo(_localVal);
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Assign value only if successfully deserialized
  this->m_paramLock.lock();
  this->m_ParamU32 = _localVal;
  this->m_param_ParamU32_valid = Fw::ParamValid::VALID;
  this->m_paramLock.unLock();

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMU32);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSet_ParamF64(Fw::SerializeBufferBase& val)
{
  F64 _localVal{};
  const Fw::SerializeStatus _stat = val.deserializeTo(_localVal);
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Assign value only if successfully deserialized
  this->m_paramLock.lock();
  this->m_ParamF64 = _localVal;
  this->m_param_ParamF64_valid = Fw::ParamValid::VALID;
  this->m_paramLock.unLock();

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMF64);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSet_ParamString(Fw::SerializeBufferBase& val)
{
  Fw::ParamString _localVal{};
  const Fw::SerializeStatus _stat = val.deserializeTo(_localVal);
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Assign value only if successfully deserialized
  this->m_paramLock.lock();
  this->m_ParamString = _localVal;
  this->m_param_ParamString_valid = Fw::ParamValid::VALID;
  this->m_paramLock.unLock();

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMSTRING);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSet_ParamEnum(Fw::SerializeBufferBase& val)
{
  E _localVal{};
  const Fw::SerializeStatus _stat = val.deserializeTo(_localVal);
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Assign value only if successfully deserialized
  this->m_paramLock.lock();
  this->m_ParamEnum = _localVal;
  this->m_param_ParamEnum_valid = Fw::ParamValid::VALID;
  this->m_paramLock.unLock();

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMENUM);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSet_ParamArray(Fw::SerializeBufferBase& val)
{
  A _localVal{};
  const Fw::SerializeStatus _stat = val.deserializeTo(_localVal);
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Assign value only if successfully deserialized
  this->m_paramLock.lock();
  this->m_ParamArray = _localVal;
  this->m_param_ParamArray_valid = Fw::ParamValid::VALID;
  this->m_paramLock.unLock();

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMARRAY);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSet_ParamStruct(Fw::SerializeBufferBase& val)
{
  S _localVal{};
  const Fw::SerializeStatus _stat = val.deserializeTo(_localVal);
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Assign value only if successfully deserialized
  this->m_paramLock.lock();
  this->m_ParamStruct = _localVal;
  this->m_param_ParamStruct_valid = Fw::ParamValid::VALID;
  this->m_paramLock.unLock();

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMSTRUCT);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSet_ParamI32Ext(Fw::SerializeBufferBase& val)
{
  const FwPrmIdType _localId = PARAMID_PARAMI32EXT;
  const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());

  FW_ASSERT(this->paramDelegatePtr != NULL);
  // Call the delegate serialize function for m_ParamI32Ext
  const Fw::SerializeStatus _stat = this->paramDelegatePtr->deserializeParam(
    _baseId,
    _localId,
    Fw::ParamValid::VALID,
    val
  );
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMI32EXT);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSet_ParamF64Ext(Fw::SerializeBufferBase& val)
{
  const FwPrmIdType _localId = PARAMID_PARAMF64EXT;
  const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());

  FW_ASSERT(this->paramDelegatePtr != NULL);
  // Call the delegate serialize function for m_ParamF64Ext
  const Fw::SerializeStatus _stat = this->paramDelegatePtr->deserializeParam(
    _baseId,
    _localId,
    Fw::ParamValid::VALID,
    val
  );
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMF64EXT);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSet_ParamStringExt(Fw::SerializeBufferBase& val)
{
  const FwPrmIdType _localId = PARAMID_PARAMSTRINGEXT;
  const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());

  FW_ASSERT(this->paramDelegatePtr != NULL);
  // Call the delegate serialize function for m_ParamStringExt
  const Fw::SerializeStatus _stat = this->paramDelegatePtr->deserializeParam(
    _baseId,
    _localId,
    Fw::ParamValid::VALID,
    val
  );
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMSTRINGEXT);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSet_ParamEnumExt(Fw::SerializeBufferBase& val)
{
  const FwPrmIdType _localId = PARAMID_PARAMENUMEXT;
  const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());

  FW_ASSERT(this->paramDelegatePtr != NULL);
  // Call the delegate serialize function for m_ParamEnumExt
  const Fw::SerializeStatus _stat = this->paramDelegatePtr->deserializeParam(
    _baseId,
    _localId,
    Fw::ParamValid::VALID,
    val
  );
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMENUMEXT);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSet_ParamArrayExt(Fw::SerializeBufferBase& val)
{
  const FwPrmIdType _localId = PARAMID_PARAMARRAYEXT;
  const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());

  FW_ASSERT(this->paramDelegatePtr != NULL);
  // Call the delegate serialize function for m_ParamArrayExt
  const Fw::SerializeStatus _stat = this->paramDelegatePtr->deserializeParam(
    _baseId,
    _localId,
    Fw::ParamValid::VALID,
    val
  );
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMARRAYEXT);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSet_ParamStructExt(Fw::SerializeBufferBase& val)
{
  const FwPrmIdType _localId = PARAMID_PARAMSTRUCTEXT;
  const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());

  FW_ASSERT(this->paramDelegatePtr != NULL);
  // Call the delegate serialize function for m_ParamStructExt
  const Fw::SerializeStatus _stat = this->paramDelegatePtr->deserializeParam(
    _baseId,
    _localId,
    Fw::ParamValid::VALID,
    val
  );
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMSTRUCTEXT);
  return Fw::CmdResponse::OK;
}

// ----------------------------------------------------------------------
// Parameter save functions
// ----------------------------------------------------------------------

Fw::CmdResponse QueuedTestComponentBase ::
  paramSave_ParamU32()
{
  Fw::ParamBuffer _saveBuff;
  FwPrmIdType _id;
  Fw::SerializeStatus _stat;
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    this->m_paramLock.lock();

    _stat = _saveBuff.serializeFrom(m_ParamU32);

    this->m_paramLock.unLock();
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_PARAMU32);

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      _id,
      _saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSave_ParamF64()
{
  Fw::ParamBuffer _saveBuff;
  FwPrmIdType _id;
  Fw::SerializeStatus _stat;
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    this->m_paramLock.lock();

    _stat = _saveBuff.serializeFrom(m_ParamF64);

    this->m_paramLock.unLock();
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_PARAMF64);

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      _id,
      _saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSave_ParamString()
{
  Fw::ParamBuffer _saveBuff;
  FwPrmIdType _id;
  Fw::SerializeStatus _stat;
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    this->m_paramLock.lock();

    _stat = _saveBuff.serializeFrom(m_ParamString);

    this->m_paramLock.unLock();
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_PARAMSTRING);

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      _id,
      _saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSave_ParamEnum()
{
  Fw::ParamBuffer _saveBuff;
  FwPrmIdType _id;
  Fw::SerializeStatus _stat;
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    this->m_paramLock.lock();

    _stat = _saveBuff.serializeFrom(m_ParamEnum);

    this->m_paramLock.unLock();
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_PARAMENUM);

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      _id,
      _saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSave_ParamArray()
{
  Fw::ParamBuffer _saveBuff;
  FwPrmIdType _id;
  Fw::SerializeStatus _stat;
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    this->m_paramLock.lock();

    _stat = _saveBuff.serializeFrom(m_ParamArray);

    this->m_paramLock.unLock();
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_PARAMARRAY);

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      _id,
      _saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSave_ParamStruct()
{
  Fw::ParamBuffer _saveBuff;
  FwPrmIdType _id;
  Fw::SerializeStatus _stat;
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    this->m_paramLock.lock();

    _stat = _saveBuff.serializeFrom(m_ParamStruct);

    this->m_paramLock.unLock();
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_PARAMSTRUCT);

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      _id,
      _saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSave_ParamI32Ext()
{
  Fw::ParamBuffer _saveBuff;
  FwPrmIdType _id;
  Fw::SerializeStatus _stat;
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    // Get the local and base ID to pass to the delegate
    _id = PARAMID_PARAMI32EXT;
    const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());

    FW_ASSERT(this->paramDelegatePtr != NULL);
    _stat = this->paramDelegatePtr->serializeParam(_baseId, _id, _saveBuff);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_PARAMI32EXT);

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      _id,
      _saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSave_ParamF64Ext()
{
  Fw::ParamBuffer _saveBuff;
  FwPrmIdType _id;
  Fw::SerializeStatus _stat;
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    // Get the local and base ID to pass to the delegate
    _id = PARAMID_PARAMF64EXT;
    const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());

    FW_ASSERT(this->paramDelegatePtr != NULL);
    _stat = this->paramDelegatePtr->serializeParam(_baseId, _id, _saveBuff);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_PARAMF64EXT);

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      _id,
      _saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSave_ParamStringExt()
{
  Fw::ParamBuffer _saveBuff;
  FwPrmIdType _id;
  Fw::SerializeStatus _stat;
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    // Get the local and base ID to pass to the delegate
    _id = PARAMID_PARAMSTRINGEXT;
    const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());

    FW_ASSERT(this->paramDelegatePtr != NULL);
    _stat = this->paramDelegatePtr->serializeParam(_baseId, _id, _saveBuff);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_PARAMSTRINGEXT);

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      _id,
      _saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSave_ParamEnumExt()
{
  Fw::ParamBuffer _saveBuff;
  FwPrmIdType _id;
  Fw::SerializeStatus _stat;
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    // Get the local and base ID to pass to the delegate
    _id = PARAMID_PARAMENUMEXT;
    const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());

    FW_ASSERT(this->paramDelegatePtr != NULL);
    _stat = this->paramDelegatePtr->serializeParam(_baseId, _id, _saveBuff);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_PARAMENUMEXT);

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      _id,
      _saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSave_ParamArrayExt()
{
  Fw::ParamBuffer _saveBuff;
  FwPrmIdType _id;
  Fw::SerializeStatus _stat;
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    // Get the local and base ID to pass to the delegate
    _id = PARAMID_PARAMARRAYEXT;
    const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());

    FW_ASSERT(this->paramDelegatePtr != NULL);
    _stat = this->paramDelegatePtr->serializeParam(_baseId, _id, _saveBuff);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_PARAMARRAYEXT);

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      _id,
      _saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse QueuedTestComponentBase ::
  paramSave_ParamStructExt()
{
  Fw::ParamBuffer _saveBuff;
  FwPrmIdType _id;
  Fw::SerializeStatus _stat;
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    // Get the local and base ID to pass to the delegate
    _id = PARAMID_PARAMSTRUCTEXT;
    const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());

    FW_ASSERT(this->paramDelegatePtr != NULL);
    _stat = this->paramDelegatePtr->serializeParam(_baseId, _id, _saveBuff);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_PARAMSTRUCTEXT);

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      _id,
      _saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

// ----------------------------------------------------------------------
// Private data product handling functions
// ----------------------------------------------------------------------

void QueuedTestComponentBase ::
  dpRequest(
      ContainerId::T containerId,
      FwSizeType dataSize
  )
{
  const FwDpIdType globalId = this->getIdBase() + containerId;
  const FwSizeType size = DpContainer::getPacketSizeForDataSize(dataSize);
  this->productRequestOut_out(0, globalId, size);
}

void QueuedTestComponentBase ::
  productRecvIn_handler(
      const FwIndexType portNum,
      FwDpIdType id,
      const Fw::Buffer& buffer,
      const Fw::Success& status
  )
{
  DpContainer container(id, buffer, this->getIdBase());
  // Convert global id to local id
  const FwDpIdType idBase = this->getIdBase();
  FW_ASSERT(
    id >= idBase,
    static_cast<FwAssertArgType>(id),
    static_cast<FwAssertArgType>(idBase)
  );
  const FwDpIdType localId = id - idBase;
  // Switch on the local id
  switch (localId) {
    case ContainerId::Container1:
      // Set the priority
      container.setPriority(ContainerPriority::Container1);
      // Call the handler
      this->dpRecv_Container1_handler(container, status.e);
      break;
    case ContainerId::Container2:
      // Set the priority
      container.setPriority(ContainerPriority::Container2);
      // Call the handler
      this->dpRecv_Container2_handler(container, status.e);
      break;
    case ContainerId::Container3:
      // Set the priority
      container.setPriority(ContainerPriority::Container3);
      // Call the handler
      this->dpRecv_Container3_handler(container, status.e);
      break;
    case ContainerId::Container4:
      // Set the priority
      container.setPriority(ContainerPriority::Container4);
      // Call the handler
      this->dpRecv_Container4_handler(container, status.e);
      break;
    case ContainerId::Container5:
      // Set the priority
      container.setPriority(ContainerPriority::Container5);
      // Call the handler
      this->dpRecv_Container5_handler(container, status.e);
      break;
    default:
      FW_ASSERT(0);
      break;
  }
}

// ----------------------------------------------------------------------
// Parameter delegates
// ----------------------------------------------------------------------
