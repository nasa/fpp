// ======================================================================
// \title  TypedPortAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for Typed port
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Fw/Types/ExternalString.hpp"
#include "base/TypedPortAc.hpp"

namespace Ports {

  namespace {

    // ----------------------------------------------------------------------
    // Port buffer class
    // ----------------------------------------------------------------------

    class TypedPortBuffer : public Fw::LinearBufferBase {

      public:

        Fw::Serializable::SizeType getCapacity() const {
          return InputTypedPort::SERIALIZED_SIZE;
        }

        U8* getBuffAddr() {
          return m_buff;
        }

        const U8* getBuffAddr() const {
          return m_buff;
        }

      private:

        U8 m_buff[InputTypedPort::SERIALIZED_SIZE];

    };

  }

  // ----------------------------------------------------------------------
  // Input Port Member functions
  // ----------------------------------------------------------------------

  InputTypedPort ::
    InputTypedPort() :
      Fw::InputPortBase(),
      m_func(nullptr)
  {

  }

  void InputTypedPort ::
    init()
  {
    Fw::InputPortBase::init();
  }

  void InputTypedPort ::
    addCallComp(
        Fw::PassiveComponentBase* callComp,
        CompFuncPtr funcPtr
    )
  {
    FW_ASSERT(callComp != nullptr);
    FW_ASSERT(funcPtr != nullptr);

    this->m_comp = callComp;
    this->m_func = funcPtr;
    this->m_connObj = callComp;
  }

  void InputTypedPort ::
    invoke(
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str1,
        const E& e,
        const A& a,
        const S& s
    )
  {
#if FW_PORT_TRACING == 1
    this->trace();
#endif

    FW_ASSERT(this->m_comp != nullptr);
    FW_ASSERT(this->m_func != nullptr);

    return this->m_func(this->m_comp, this->m_portNum, u32, f32, b, str1, e, a, s);
  }

#if FW_PORT_SERIALIZATION == 1

  Fw::SerializeStatus InputTypedPort ::
    invokeSerial(Fw::LinearBufferBase& _buffer)
  {
    Fw::SerializeStatus _status;

#if FW_PORT_TRACING == 1
    this->trace();
#endif

    FW_ASSERT(this->m_comp != nullptr);
    FW_ASSERT(this->m_func != nullptr);

    U32 u32;
    _status = _buffer.deserializeTo(u32);
    if (_status != Fw::FW_SERIALIZE_OK) {
      return _status;
    }

    F32 f32;
    _status = _buffer.deserializeTo(f32);
    if (_status != Fw::FW_SERIALIZE_OK) {
      return _status;
    }

    bool b;
    _status = _buffer.deserializeTo(b);
    if (_status != Fw::FW_SERIALIZE_OK) {
      return _status;
    }

    char __fprime_ac_str1_buffer[Fw::StringBase::BUFFER_SIZE(static_cast<FwSizeType>(FW_FIXED_LENGTH_STRING_SIZE))];
    Fw::ExternalString str1(__fprime_ac_str1_buffer, sizeof __fprime_ac_str1_buffer);
    _status = _buffer.deserializeTo(str1);
    if (_status != Fw::FW_SERIALIZE_OK) {
      return _status;
    }

    E e;
    _status = _buffer.deserializeTo(e);
    if (_status != Fw::FW_SERIALIZE_OK) {
      return _status;
    }

    A a;
    _status = _buffer.deserializeTo(a);
    if (_status != Fw::FW_SERIALIZE_OK) {
      return _status;
    }

    S s;
    _status = _buffer.deserializeTo(s);
    if (_status != Fw::FW_SERIALIZE_OK) {
      return _status;
    }

    this->m_func(this->m_comp, this->m_portNum, u32, f32, b, str1, e, a, s);

    return Fw::FW_SERIALIZE_OK;
  }

#endif

  // ----------------------------------------------------------------------
  // Output Port Member functions
  // ----------------------------------------------------------------------

  OutputTypedPort ::
    OutputTypedPort() :
      Fw::OutputPortBase(),
      m_port(nullptr)
  {

  }

  void OutputTypedPort ::
    init()
  {
    Fw::OutputPortBase::init();
  }

  void OutputTypedPort ::
    addCallPort(InputTypedPort* callPort)
  {
    FW_ASSERT(callPort != nullptr);

    this->m_port = callPort;
    this->m_connObj = callPort;

#if FW_PORT_SERIALIZATION == 1
    this->m_serPort = nullptr;
#endif
  }

  void OutputTypedPort ::
    invoke(
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str1,
        const E& e,
        const A& a,
        const S& s
    ) const
  {
#if FW_PORT_TRACING == 1
    this->trace();
#endif

#if FW_PORT_SERIALIZATION
    FW_ASSERT((this->m_port != nullptr) || (this->m_serPort != nullptr));

    if (this->m_port != nullptr) {
      this->m_port->invoke(u32, f32, b, str1, e, a, s);
    }
    else {
      Fw::SerializeStatus _status;
      TypedPortBuffer _buffer;

      _status = _buffer.serializeFrom(u32);
      FW_ASSERT(_status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_status));

      _status = _buffer.serializeFrom(f32);
      FW_ASSERT(_status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_status));

      _status = _buffer.serializeFrom(b);
      FW_ASSERT(_status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_status));

      _status = _buffer.serializeFrom(str1);
      FW_ASSERT(_status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_status));

      _status = _buffer.serializeFrom(e);
      FW_ASSERT(_status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_status));

      _status = _buffer.serializeFrom(a);
      FW_ASSERT(_status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_status));

      _status = _buffer.serializeFrom(s);
      FW_ASSERT(_status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_status));

      _status = this->m_serPort->invokeSerial(_buffer);
      FW_ASSERT(_status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_status));
    }
#else
    FW_ASSERT(this->m_port != nullptr);
    this->m_port->invoke(u32, f32, b, str1, e, a, s);
#endif
  }

}
