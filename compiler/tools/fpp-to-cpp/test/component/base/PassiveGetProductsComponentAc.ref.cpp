// ======================================================================
// \title  PassiveGetProductsComponentAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for PassiveGetProducts component base class
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Fw/Types/ExternalString.hpp"
#if FW_ENABLE_TEXT_LOGGING
#include "Fw/Types/String.hpp"
#endif
#include "base/PassiveGetProductsComponentAc.hpp"

// ----------------------------------------------------------------------
// Types for data products
// ----------------------------------------------------------------------

PassiveGetProductsComponentBase::DpContainer ::
  DpContainer(
      FwDpIdType id,
      const Fw::Buffer& buffer,
      FwDpIdType baseId
  ) :
    Fw::DpContainer(id, buffer),
    m_baseId(baseId)
{

}

PassiveGetProductsComponentBase::DpContainer ::
  DpContainer() :
    Fw::DpContainer(),
    m_baseId(0)
{

}

Fw::SerializeStatus PassiveGetProductsComponentBase::DpContainer ::
  serializeRecord_DataArrayRecord(
      const PassiveGetProducts_Data* array,
      FwSizeType size
  )
{
  FW_ASSERT(array != nullptr);
  // Compute the size delta
  const FwSizeType sizeDelta =
    sizeof(FwDpIdType) +
    sizeof(FwSizeStoreType) +
    size * PassiveGetProducts_Data::SERIALIZED_SIZE;
  // Serialize the elements if they will fit
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if ((this->m_dataBuffer.getBuffLength() + sizeDelta) <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::DataArrayRecord;
    status = this->m_dataBuffer.serialize(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serializeSize(size);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    for (FwSizeType i = 0; i < size; i++) {
      status = this->m_dataBuffer.serialize(array[i]);
      FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    }
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

Fw::SerializeStatus PassiveGetProductsComponentBase::DpContainer ::
  serializeRecord_DataRecord(const PassiveGetProducts_Data& elt)
{
  const FwSizeType sizeDelta =
    sizeof(FwDpIdType) +
    PassiveGetProducts_Data::SERIALIZED_SIZE;
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if (this->m_dataBuffer.getBuffLength() + sizeDelta <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::DataRecord;
    status = this->m_dataBuffer.serialize(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serialize(elt);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

Fw::SerializeStatus PassiveGetProductsComponentBase::DpContainer ::
  serializeRecord_StringArrayRecord(
      const Fw::StringBase** array,
      FwSizeType size
  )
{
  FW_ASSERT(array != nullptr);
  // Compute the size delta
  const FwSizeType stringSize = 80;
  FwSizeType sizeDelta =
    sizeof(FwDpIdType) +
    sizeof(FwSizeStoreType);
  for (FwSizeType i = 0; i < size; i++) {
    const Fw::StringBase *const sbPtr = array[i];
    FW_ASSERT(sbPtr != nullptr);
    sizeDelta += sbPtr->serializedTruncatedSize(stringSize);
  }
  // Serialize the elements if they will fit
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if ((this->m_dataBuffer.getBuffLength() + sizeDelta) <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::StringArrayRecord;
    status = this->m_dataBuffer.serialize(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serializeSize(size);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    for (FwSizeType i = 0; i < size; i++) {
      const Fw::StringBase *const sbPtr = array[i];
      FW_ASSERT(sbPtr != nullptr);
      status = sbPtr->serialize(this->m_dataBuffer, stringSize);
      FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    }
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

Fw::SerializeStatus PassiveGetProductsComponentBase::DpContainer ::
  serializeRecord_StringRecord(const Fw::StringBase& elt)
{
  const FwSizeType stringSize = 80;
  const FwSizeType sizeDelta =
    sizeof(FwDpIdType) +
    elt.serializedTruncatedSize(stringSize);
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if (this->m_dataBuffer.getBuffLength() + sizeDelta <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::StringRecord;
    status = this->m_dataBuffer.serialize(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = elt.serialize(this->m_dataBuffer, stringSize);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

Fw::SerializeStatus PassiveGetProductsComponentBase::DpContainer ::
  serializeRecord_U32ArrayRecord(
      const U32* array,
      FwSizeType size
  )
{
  FW_ASSERT(array != nullptr);
  // Compute the size delta
  const FwSizeType sizeDelta =
    sizeof(FwDpIdType) +
    sizeof(FwSizeStoreType) +
    size * sizeof(U32);
  // Serialize the elements if they will fit
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if ((this->m_dataBuffer.getBuffLength() + sizeDelta) <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::U32ArrayRecord;
    status = this->m_dataBuffer.serialize(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serializeSize(size);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    for (FwSizeType i = 0; i < size; i++) {
      status = this->m_dataBuffer.serialize(array[i]);
      FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    }
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

Fw::SerializeStatus PassiveGetProductsComponentBase::DpContainer ::
  serializeRecord_U32Record(U32 elt)
{
  const FwSizeType sizeDelta =
    sizeof(FwDpIdType) +
    sizeof(U32);
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if (this->m_dataBuffer.getBuffLength() + sizeDelta <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::U32Record;
    status = this->m_dataBuffer.serialize(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serialize(elt);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

Fw::SerializeStatus PassiveGetProductsComponentBase::DpContainer ::
  serializeRecord_U8ArrayRecord(
      const U8* array,
      FwSizeType size
  )
{
  FW_ASSERT(array != nullptr);
  // Compute the size delta
  const FwSizeType sizeDelta =
    sizeof(FwDpIdType) +
    sizeof(FwSizeStoreType) +
    size * sizeof(U8);
  // Serialize the elements if they will fit
  Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
  if ((this->m_dataBuffer.getBuffLength() + sizeDelta) <= this->m_dataBuffer.getBuffCapacity()) {
    const FwDpIdType id = this->m_baseId + RecordId::U8ArrayRecord;
    status = this->m_dataBuffer.serialize(id);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serializeSize(size);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    status = this->m_dataBuffer.serialize(array, size, Fw::Serialization::OMIT_LENGTH);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    this->m_dataSize += sizeDelta;
  }
  else {
    status = Fw::FW_SERIALIZE_NO_ROOM_LEFT;
  }
  return status;
}

// ----------------------------------------------------------------------
// Component initialization
// ----------------------------------------------------------------------

void PassiveGetProductsComponentBase ::
  init(FwEnumStoreType instance)
{
  // Initialize base class
  Fw::PassiveComponentBase::init(instance);

  // Connect input port cmdIn
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_cmdIn_InputPorts());
    port++
  ) {
    this->m_cmdIn_InputPort[port].init();
    this->m_cmdIn_InputPort[port].addCallComp(
      this,
      m_p_cmdIn_in
    );
    this->m_cmdIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_cmdIn_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_cmdIn_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsGuarded_InputPorts());
    port++
  ) {
    this->m_noArgsGuarded_InputPort[port].init();
    this->m_noArgsGuarded_InputPort[port].addCallComp(
      this,
      m_p_noArgsGuarded_in
    );
    this->m_noArgsGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsGuarded_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsReturnGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsReturnGuarded_InputPorts());
    port++
  ) {
    this->m_noArgsReturnGuarded_InputPort[port].init();
    this->m_noArgsReturnGuarded_InputPort[port].addCallComp(
      this,
      m_p_noArgsReturnGuarded_in
    );
    this->m_noArgsReturnGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsReturnGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsReturnGuarded_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsReturnSync_InputPorts());
    port++
  ) {
    this->m_noArgsReturnSync_InputPort[port].init();
    this->m_noArgsReturnSync_InputPort[port].addCallComp(
      this,
      m_p_noArgsReturnSync_in
    );
    this->m_noArgsReturnSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsReturnSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsReturnSync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsSync_InputPorts());
    port++
  ) {
    this->m_noArgsSync_InputPort[port].init();
    this->m_noArgsSync_InputPort[port].addCallComp(
      this,
      m_p_noArgsSync_in
    );
    this->m_noArgsSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsSync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedGuarded_InputPorts());
    port++
  ) {
    this->m_typedGuarded_InputPort[port].init();
    this->m_typedGuarded_InputPort[port].addCallComp(
      this,
      m_p_typedGuarded_in
    );
    this->m_typedGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedGuarded_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedReturnGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedReturnGuarded_InputPorts());
    port++
  ) {
    this->m_typedReturnGuarded_InputPort[port].init();
    this->m_typedReturnGuarded_InputPort[port].addCallComp(
      this,
      m_p_typedReturnGuarded_in
    );
    this->m_typedReturnGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedReturnGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedReturnGuarded_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedReturnSync_InputPorts());
    port++
  ) {
    this->m_typedReturnSync_InputPort[port].init();
    this->m_typedReturnSync_InputPort[port].addCallComp(
      this,
      m_p_typedReturnSync_in
    );
    this->m_typedReturnSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedReturnSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedReturnSync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedSync_InputPorts());
    port++
  ) {
    this->m_typedSync_InputPort[port].init();
    this->m_typedSync_InputPort[port].addCallComp(
      this,
      m_p_typedSync_in
    );
    this->m_typedSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedSync_InputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port cmdRegOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_cmdRegOut_OutputPorts());
    port++
  ) {
    this->m_cmdRegOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_cmdRegOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_cmdRegOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port cmdResponseOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_cmdResponseOut_OutputPorts());
    port++
  ) {
    this->m_cmdResponseOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_cmdResponseOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_cmdResponseOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port eventOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_eventOut_OutputPorts());
    port++
  ) {
    this->m_eventOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_eventOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_eventOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port prmGetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_prmGetOut_OutputPorts());
    port++
  ) {
    this->m_prmGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_prmGetOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_prmGetOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port prmSetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_prmSetOut_OutputPorts());
    port++
  ) {
    this->m_prmSetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_prmSetOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_prmSetOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port productGetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_productGetOut_OutputPorts());
    port++
  ) {
    this->m_productGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_productGetOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_productGetOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port productSendOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_productSendOut_OutputPorts());
    port++
  ) {
    this->m_productSendOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_productSendOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_productSendOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

#if FW_ENABLE_TEXT_LOGGING == 1
  // Connect output port textEventOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_textEventOut_OutputPorts());
    port++
  ) {
    this->m_textEventOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_textEventOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_textEventOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }
#endif

  // Connect output port timeGetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_timeGetOut_OutputPorts());
    port++
  ) {
    this->m_timeGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_timeGetOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_timeGetOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port tlmOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_tlmOut_OutputPorts());
    port++
  ) {
    this->m_tlmOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_tlmOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_tlmOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsOut_OutputPorts());
    port++
  ) {
    this->m_noArgsOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsReturnOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_noArgsReturnOut_OutputPorts());
    port++
  ) {
    this->m_noArgsReturnOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_noArgsReturnOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_noArgsReturnOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedOut_OutputPorts());
    port++
  ) {
    this->m_typedOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedReturnOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_typedReturnOut_OutputPorts());
    port++
  ) {
    this->m_typedReturnOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_typedReturnOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_typedReturnOut_OutputPort[port].setObjName(portName.toChar());
#endif
  }
}

// ----------------------------------------------------------------------
// Getters for special input ports
// ----------------------------------------------------------------------

Fw::InputCmdPort* PassiveGetProductsComponentBase ::
  get_cmdIn_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_cmdIn_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_cmdIn_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Getters for typed input ports
// ----------------------------------------------------------------------

Ports::InputNoArgsPort* PassiveGetProductsComponentBase ::
  get_noArgsGuarded_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsGuarded_InputPort[portNum];
}

Ports::InputNoArgsReturnPort* PassiveGetProductsComponentBase ::
  get_noArgsReturnGuarded_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsReturnGuarded_InputPort[portNum];
}

Ports::InputNoArgsReturnPort* PassiveGetProductsComponentBase ::
  get_noArgsReturnSync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsReturnSync_InputPort[portNum];
}

Ports::InputNoArgsPort* PassiveGetProductsComponentBase ::
  get_noArgsSync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsSync_InputPort[portNum];
}

Ports::InputTypedPort* PassiveGetProductsComponentBase ::
  get_typedGuarded_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedGuarded_InputPort[portNum];
}

Ports::InputTypedReturnPort* PassiveGetProductsComponentBase ::
  get_typedReturnGuarded_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedReturnGuarded_InputPort[portNum];
}

Ports::InputTypedReturnPort* PassiveGetProductsComponentBase ::
  get_typedReturnSync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedReturnSync_InputPort[portNum];
}

Ports::InputTypedPort* PassiveGetProductsComponentBase ::
  get_typedSync_InputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedSync_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Connect input ports to special output ports
// ----------------------------------------------------------------------

void PassiveGetProductsComponentBase ::
  set_cmdRegOut_OutputPort(
      FwIndexType portNum,
      Fw::InputCmdRegPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdRegOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdRegOut_OutputPort[portNum].addCallPort(port);
}

void PassiveGetProductsComponentBase ::
  set_cmdResponseOut_OutputPort(
      FwIndexType portNum,
      Fw::InputCmdResponsePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdResponseOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdResponseOut_OutputPort[portNum].addCallPort(port);
}

void PassiveGetProductsComponentBase ::
  set_eventOut_OutputPort(
      FwIndexType portNum,
      Fw::InputLogPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_eventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_eventOut_OutputPort[portNum].addCallPort(port);
}

void PassiveGetProductsComponentBase ::
  set_prmGetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputPrmGetPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_prmGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmGetOut_OutputPort[portNum].addCallPort(port);
}

void PassiveGetProductsComponentBase ::
  set_prmSetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputPrmSetPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_prmSetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmSetOut_OutputPort[portNum].addCallPort(port);
}

void PassiveGetProductsComponentBase ::
  set_productGetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputDpGetPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_productGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_productGetOut_OutputPort[portNum].addCallPort(port);
}

void PassiveGetProductsComponentBase ::
  set_productSendOut_OutputPort(
      FwIndexType portNum,
      Fw::InputDpSendPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_productSendOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_productSendOut_OutputPort[portNum].addCallPort(port);
}

#if FW_ENABLE_TEXT_LOGGING == 1

void PassiveGetProductsComponentBase ::
  set_textEventOut_OutputPort(
      FwIndexType portNum,
      Fw::InputLogTextPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_textEventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_textEventOut_OutputPort[portNum].addCallPort(port);
}

#endif

void PassiveGetProductsComponentBase ::
  set_timeGetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputTimePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_timeGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_timeGetOut_OutputPort[portNum].addCallPort(port);
}

void PassiveGetProductsComponentBase ::
  set_tlmOut_OutputPort(
      FwIndexType portNum,
      Fw::InputTlmPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_tlmOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_tlmOut_OutputPort[portNum].addCallPort(port);
}

// ----------------------------------------------------------------------
// Connect typed input ports to typed output ports
// ----------------------------------------------------------------------

void PassiveGetProductsComponentBase ::
  set_noArgsOut_OutputPort(
      FwIndexType portNum,
      Ports::InputNoArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_noArgsOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_noArgsOut_OutputPort[portNum].addCallPort(port);
}

void PassiveGetProductsComponentBase ::
  set_noArgsReturnOut_OutputPort(
      FwIndexType portNum,
      Ports::InputNoArgsReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_noArgsReturnOut_OutputPort[portNum].addCallPort(port);
}

void PassiveGetProductsComponentBase ::
  set_typedOut_OutputPort(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedOut_OutputPort[portNum].addCallPort(port);
}

void PassiveGetProductsComponentBase ::
  set_typedReturnOut_OutputPort(
      FwIndexType portNum,
      Ports::InputTypedReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedReturnOut_OutputPort[portNum].addCallPort(port);
}

#if FW_PORT_SERIALIZATION

// ----------------------------------------------------------------------
// Connect serial input ports to special output ports
// ----------------------------------------------------------------------

void PassiveGetProductsComponentBase ::
  set_cmdRegOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdRegOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdRegOut_OutputPort[portNum].registerSerialPort(port);
}

void PassiveGetProductsComponentBase ::
  set_cmdResponseOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdResponseOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdResponseOut_OutputPort[portNum].registerSerialPort(port);
}

void PassiveGetProductsComponentBase ::
  set_eventOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_eventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_eventOut_OutputPort[portNum].registerSerialPort(port);
}

void PassiveGetProductsComponentBase ::
  set_prmSetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_prmSetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmSetOut_OutputPort[portNum].registerSerialPort(port);
}

void PassiveGetProductsComponentBase ::
  set_productSendOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_productSendOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_productSendOut_OutputPort[portNum].registerSerialPort(port);
}

#if FW_ENABLE_TEXT_LOGGING == 1

void PassiveGetProductsComponentBase ::
  set_textEventOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_textEventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_textEventOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

void PassiveGetProductsComponentBase ::
  set_timeGetOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_timeGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_timeGetOut_OutputPort[portNum].registerSerialPort(port);
}

void PassiveGetProductsComponentBase ::
  set_tlmOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_tlmOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_tlmOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

#if FW_PORT_SERIALIZATION

// ----------------------------------------------------------------------
// Connect serial input ports to typed output ports
// ----------------------------------------------------------------------

void PassiveGetProductsComponentBase ::
  set_noArgsOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_noArgsOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_noArgsOut_OutputPort[portNum].registerSerialPort(port);
}

void PassiveGetProductsComponentBase ::
  set_typedOut_OutputPort(
      FwIndexType portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

// ----------------------------------------------------------------------
// Component construction and destruction
// ----------------------------------------------------------------------

PassiveGetProductsComponentBase ::
  PassiveGetProductsComponentBase(const char* compName) :
    Fw::PassiveComponentBase(compName)
{

}

PassiveGetProductsComponentBase ::
  ~PassiveGetProductsComponentBase()
{

}

// ----------------------------------------------------------------------
// Getters for numbers of special input ports
// ----------------------------------------------------------------------

FwIndexType PassiveGetProductsComponentBase ::
  getNum_cmdIn_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdIn_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of typed input ports
// ----------------------------------------------------------------------

FwIndexType PassiveGetProductsComponentBase ::
  getNum_noArgsGuarded_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsGuarded_InputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_noArgsReturnGuarded_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsReturnGuarded_InputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_noArgsReturnSync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsReturnSync_InputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_noArgsSync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsSync_InputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_typedGuarded_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedGuarded_InputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_typedReturnGuarded_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnGuarded_InputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_typedReturnSync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnSync_InputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_typedSync_InputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedSync_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of special output ports
// ----------------------------------------------------------------------

FwIndexType PassiveGetProductsComponentBase ::
  getNum_cmdRegOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdRegOut_OutputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_cmdResponseOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdResponseOut_OutputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_eventOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_eventOut_OutputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_prmGetOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_prmGetOut_OutputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_prmSetOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_prmSetOut_OutputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_productGetOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_productGetOut_OutputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_productSendOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_productSendOut_OutputPort));
}

#if FW_ENABLE_TEXT_LOGGING == 1

FwIndexType PassiveGetProductsComponentBase ::
  getNum_textEventOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_textEventOut_OutputPort));
}

#endif

FwIndexType PassiveGetProductsComponentBase ::
  getNum_timeGetOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_timeGetOut_OutputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_tlmOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_tlmOut_OutputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of typed output ports
// ----------------------------------------------------------------------

FwIndexType PassiveGetProductsComponentBase ::
  getNum_noArgsOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsOut_OutputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_noArgsReturnOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsReturnOut_OutputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_typedOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedOut_OutputPort));
}

FwIndexType PassiveGetProductsComponentBase ::
  getNum_typedReturnOut_OutputPorts() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnOut_OutputPort));
}

// ----------------------------------------------------------------------
// Connection status queries for special output ports
// ----------------------------------------------------------------------

bool PassiveGetProductsComponentBase ::
  isConnected_cmdRegOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_cmdRegOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_cmdRegOut_OutputPort[portNum].isConnected();
}

bool PassiveGetProductsComponentBase ::
  isConnected_cmdResponseOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_cmdResponseOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_cmdResponseOut_OutputPort[portNum].isConnected();
}

bool PassiveGetProductsComponentBase ::
  isConnected_eventOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_eventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_eventOut_OutputPort[portNum].isConnected();
}

bool PassiveGetProductsComponentBase ::
  isConnected_prmGetOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_prmGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_prmGetOut_OutputPort[portNum].isConnected();
}

bool PassiveGetProductsComponentBase ::
  isConnected_prmSetOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_prmSetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_prmSetOut_OutputPort[portNum].isConnected();
}

bool PassiveGetProductsComponentBase ::
  isConnected_productGetOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_productGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_productGetOut_OutputPort[portNum].isConnected();
}

bool PassiveGetProductsComponentBase ::
  isConnected_productSendOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_productSendOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_productSendOut_OutputPort[portNum].isConnected();
}

#if FW_ENABLE_TEXT_LOGGING == 1

bool PassiveGetProductsComponentBase ::
  isConnected_textEventOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_textEventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_textEventOut_OutputPort[portNum].isConnected();
}

#endif

bool PassiveGetProductsComponentBase ::
  isConnected_timeGetOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_timeGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_timeGetOut_OutputPort[portNum].isConnected();
}

bool PassiveGetProductsComponentBase ::
  isConnected_tlmOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_tlmOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_tlmOut_OutputPort[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Connection status queries for typed output ports
// ----------------------------------------------------------------------

bool PassiveGetProductsComponentBase ::
  isConnected_noArgsOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_noArgsOut_OutputPort[portNum].isConnected();
}

bool PassiveGetProductsComponentBase ::
  isConnected_noArgsReturnOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_noArgsReturnOut_OutputPort[portNum].isConnected();
}

bool PassiveGetProductsComponentBase ::
  isConnected_typedOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_typedOut_OutputPort[portNum].isConnected();
}

bool PassiveGetProductsComponentBase ::
  isConnected_typedReturnOut_OutputPort(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_typedReturnOut_OutputPort[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Port handler base-class functions for typed input ports
//
// Call these functions directly to bypass the corresponding ports
// ----------------------------------------------------------------------

void PassiveGetProductsComponentBase ::
  noArgsGuarded_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_noArgsGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Lock guard mutex before calling
  this->lock();

  // Call handler function
  this->noArgsGuarded_handler(portNum);

  // Unlock guard mutex
  this->unLock();
}

U32 PassiveGetProductsComponentBase ::
  noArgsReturnGuarded_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  U32 retVal;

  // Lock guard mutex before calling
  this->lock();

  // Call handler function
  retVal = this->noArgsReturnGuarded_handler(portNum);

  // Unlock guard mutex
  this->unLock();

  return retVal;
}

U32 PassiveGetProductsComponentBase ::
  noArgsReturnSync_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  U32 retVal;

  // Call handler function
  retVal = this->noArgsReturnSync_handler(portNum);

  return retVal;
}

void PassiveGetProductsComponentBase ::
  noArgsSync_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_noArgsSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call handler function
  this->noArgsSync_handler(portNum);
}

void PassiveGetProductsComponentBase ::
  typedGuarded_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Lock guard mutex before calling
  this->lock();

  // Call handler function
  this->typedGuarded_handler(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );

  // Unlock guard mutex
  this->unLock();
}

F32 PassiveGetProductsComponentBase ::
  typedReturnGuarded_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  F32 retVal;

  // Lock guard mutex before calling
  this->lock();

  // Call handler function
  retVal = this->typedReturnGuarded_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );

  // Unlock guard mutex
  this->unLock();

  return retVal;
}

F32 PassiveGetProductsComponentBase ::
  typedReturnSync_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  F32 retVal;

  // Call handler function
  retVal = this->typedReturnSync_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );

  return retVal;
}

void PassiveGetProductsComponentBase ::
  typedSync_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call handler function
  this->typedSync_handler(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Invocation functions for special output ports
// ----------------------------------------------------------------------

Fw::Success PassiveGetProductsComponentBase ::
  productGetOut_out(
      FwIndexType portNum,
      FwDpIdType id,
      FwSizeType dataSize,
      Fw::Buffer& buffer
  )
{
  FW_ASSERT(
    portNum < this->getNum_productGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_productGetOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_productGetOut_OutputPort[portNum].invoke(
    id,
    dataSize,
    buffer
  );
}

void PassiveGetProductsComponentBase ::
  productSendOut_out(
      FwIndexType portNum,
      FwDpIdType id,
      const Fw::Buffer& buffer
  )
{
  FW_ASSERT(
    portNum < this->getNum_productSendOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_productSendOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_productSendOut_OutputPort[portNum].invoke(
    id,
    buffer
  );
}

// ----------------------------------------------------------------------
// Invocation functions for typed output ports
// ----------------------------------------------------------------------

void PassiveGetProductsComponentBase ::
  noArgsOut_out(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_noArgsOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_noArgsOut_OutputPort[portNum].invoke();
}

U32 PassiveGetProductsComponentBase ::
  noArgsReturnOut_out(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_noArgsReturnOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_noArgsReturnOut_OutputPort[portNum].invoke();
}

void PassiveGetProductsComponentBase ::
  typedOut_out(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_typedOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_typedOut_OutputPort[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 PassiveGetProductsComponentBase ::
  typedReturnOut_out(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  FW_ASSERT(
    this->m_typedReturnOut_OutputPort[portNum].isConnected(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_typedReturnOut_OutputPort[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Functions for managing data products
// ----------------------------------------------------------------------

void PassiveGetProductsComponentBase ::
  dpSend(
      DpContainer& container,
      Fw::Time timeTag
  )
{
  // Update the time tag
  if (timeTag == Fw::ZERO_TIME) {
    // Get the time from the time port
    timeTag = this->getTime();
  }
  container.setTimeTag(timeTag);
  // Serialize the header into the packet
  container.serializeHeader();
  // Update the data hash
  container.updateDataHash();
  // Update the size of the buffer according to the data size
  const FwSizeType packetSize = container.getPacketSize();
  Fw::Buffer buffer = container.getBuffer();
  FW_ASSERT(packetSize <= buffer.getSize(), static_cast<FwAssertArgType>(packetSize),
      static_cast<FwAssertArgType>(buffer.getSize()));
  buffer.setSize(static_cast<U32>(packetSize));
  // Invalidate the buffer in the container, so it can't be reused
  container.invalidateBuffer();
  // Send the buffer
  this->productSendOut_out(0, container.getId(), buffer);
}

// ----------------------------------------------------------------------
// Time
// ----------------------------------------------------------------------

Fw::Time PassiveGetProductsComponentBase ::
  getTime()
{
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    Fw::Time _time;
    this->m_timeGetOut_OutputPort[0].invoke(_time);
    return _time;
  }
  else {
    return Fw::Time(TB_NONE, 0, 0);
  }
}

// ----------------------------------------------------------------------
// Mutex operations for guarded ports
//
// You can override these operations to provide more sophisticated
// synchronization
// ----------------------------------------------------------------------

void PassiveGetProductsComponentBase ::
  lock()
{
  this->m_guardedPortMutex.lock();
}

void PassiveGetProductsComponentBase ::
  unLock()
{
  this->m_guardedPortMutex.unLock();
}

// ----------------------------------------------------------------------
// Calls for messages received on special input ports
// ----------------------------------------------------------------------

void PassiveGetProductsComponentBase ::
  m_p_cmdIn_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  FW_ASSERT(callComp);

  const U32 idBase = callComp->getIdBase();
  FW_ASSERT(opCode >= idBase, static_cast<FwAssertArgType>(opCode), static_cast<FwAssertArgType>(idBase));
}

// ----------------------------------------------------------------------
// Calls for messages received on typed input ports
// ----------------------------------------------------------------------

void PassiveGetProductsComponentBase ::
  m_p_noArgsGuarded_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp);
  PassiveGetProductsComponentBase* compPtr = static_cast<PassiveGetProductsComponentBase*>(callComp);
  compPtr->noArgsGuarded_handlerBase(portNum);
}

U32 PassiveGetProductsComponentBase ::
  m_p_noArgsReturnGuarded_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp);
  PassiveGetProductsComponentBase* compPtr = static_cast<PassiveGetProductsComponentBase*>(callComp);
  return compPtr->noArgsReturnGuarded_handlerBase(portNum);
}

U32 PassiveGetProductsComponentBase ::
  m_p_noArgsReturnSync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp);
  PassiveGetProductsComponentBase* compPtr = static_cast<PassiveGetProductsComponentBase*>(callComp);
  return compPtr->noArgsReturnSync_handlerBase(portNum);
}

void PassiveGetProductsComponentBase ::
  m_p_noArgsSync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp);
  PassiveGetProductsComponentBase* compPtr = static_cast<PassiveGetProductsComponentBase*>(callComp);
  compPtr->noArgsSync_handlerBase(portNum);
}

void PassiveGetProductsComponentBase ::
  m_p_typedGuarded_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  PassiveGetProductsComponentBase* compPtr = static_cast<PassiveGetProductsComponentBase*>(callComp);
  compPtr->typedGuarded_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 PassiveGetProductsComponentBase ::
  m_p_typedReturnGuarded_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  PassiveGetProductsComponentBase* compPtr = static_cast<PassiveGetProductsComponentBase*>(callComp);
  return compPtr->typedReturnGuarded_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

F32 PassiveGetProductsComponentBase ::
  m_p_typedReturnSync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  PassiveGetProductsComponentBase* compPtr = static_cast<PassiveGetProductsComponentBase*>(callComp);
  return compPtr->typedReturnSync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void PassiveGetProductsComponentBase ::
  m_p_typedSync_in(
      Fw::PassiveComponentBase* callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  PassiveGetProductsComponentBase* compPtr = static_cast<PassiveGetProductsComponentBase*>(callComp);
  compPtr->typedSync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Private data product handling functions
// ----------------------------------------------------------------------

Fw::Success::T PassiveGetProductsComponentBase ::
  dpGet(
      ContainerId::T containerId,
      FwSizeType dataSize,
      FwDpPriorityType priority,
      DpContainer& container
  )
{
  const FwDpIdType baseId = this->getIdBase();
  const FwDpIdType globalId = baseId + containerId;
  const FwSizeType size = DpContainer::getPacketSizeForDataSize(dataSize);
  Fw::Buffer buffer;
  const Fw::Success::T status = this->productGetOut_out(0, globalId, size, buffer);
  if (status == Fw::Success::SUCCESS) {
    // Assign a fresh DpContainer into container
    // This action clears out all the container state
    container = DpContainer(globalId, buffer, baseId);
    container.setPriority(priority);
  }
  return status;
}
