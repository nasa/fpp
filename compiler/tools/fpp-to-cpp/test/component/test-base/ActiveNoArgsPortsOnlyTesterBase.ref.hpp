// ======================================================================
// \title  ActiveNoArgsPortsOnlyTesterBase.hpp
// \author Generated by fpp-to-cpp
// \brief  hpp file for ActiveNoArgsPortsOnly component test harness base class
// ======================================================================

#ifndef ActiveNoArgsPortsOnlyTesterBase_HPP
#define ActiveNoArgsPortsOnlyTesterBase_HPP

#include <cstdio>

#include "Fw/Comp/PassiveComponentBase.hpp"
#include "Fw/Port/InputSerializePort.hpp"
#include "Fw/Types/Assert.hpp"
#include "Fw/Types/ExternalString.hpp"
#include "test-base/ActiveNoArgsPortsOnlyComponentAc.hpp"

//! \class ActiveNoArgsPortsOnlyTesterBase
//! \brief Auto-generated base for ActiveNoArgsPortsOnly component test harness
class ActiveNoArgsPortsOnlyTesterBase :
  public Fw::PassiveComponentBase
{

  protected:

    // ----------------------------------------------------------------------
    // History class
    // ----------------------------------------------------------------------

    //! \class History
    //! \brief A history of port inputs
    //!
    template<typename T>
    class History
    {

      public:

        //! Create a History
        History(
           const U32 maxSize //!< The maximum history size
        ) :
          m_numEntries(0),
          m_maxSize(maxSize)
        {
          this->m_entries = new T[maxSize];
        }

        //! Destroy a History
        ~History()
        {
          delete[] this->m_entries;
        }

        //! Clear the history
        //!
        void clear()
        {
          this->m_numEntries = 0;
        }

        //! Push an item onto the history
        //!
        void push_back(
            const T& entry //!< The item
        )
        {
          FW_ASSERT(this->m_numEntries < this->m_maxSize);
          this->m_entries[this->m_numEntries++] = entry;
        }

        //! Get an item at an index
        //!
        //! \return The item at index i
        const T& at(
            const U32 i //!< The index
        ) const
        {
          FW_ASSERT(i < this->m_numEntries);
          return this->m_entries[i];
        }

        //! Get the number of entries in the history
        //!
        //! \return The number of entries in the history
        U32 size() const
        {
          return this->m_numEntries;
        }

      private:

        //! The number of entries in the history
        U32 m_numEntries;

        //! The maximum history size
        const U32 m_maxSize;

        //! The entries
        T* m_entries;

    };

  protected:

    // ----------------------------------------------------------------------
    // History types
    // ----------------------------------------------------------------------

  public:

    // ----------------------------------------------------------------------
    // Component initialization
    // ----------------------------------------------------------------------

    //! Initialize object ActiveNoArgsPortsOnlyTesterBase
    virtual void init(
        FwEnumStoreType instance = 0 //!< The instance number
    );

  public:

    // ----------------------------------------------------------------------
    // Connectors for to ports
    // ----------------------------------------------------------------------

    //! Connect port to noArgsAsync[portNum]
    void connect_to_noArgsAsync(
        FwIndexType portNum, //!< The port number
        Ports::InputNoArgsPort* port //!< The input port
    );

    //! Connect port to noArgsGuarded[portNum]
    void connect_to_noArgsGuarded(
        FwIndexType portNum, //!< The port number
        Ports::InputNoArgsPort* port //!< The input port
    );

    //! Connect port to noArgsReturnGuarded[portNum]
    void connect_to_noArgsReturnGuarded(
        FwIndexType portNum, //!< The port number
        Ports::InputNoArgsReturnPort* port //!< The input port
    );

    //! Connect port to noArgsReturnSync[portNum]
    void connect_to_noArgsReturnSync(
        FwIndexType portNum, //!< The port number
        Ports::InputNoArgsReturnPort* port //!< The input port
    );

#ifndef FW_DIRECT_PORT_CALLS

  public:

    // ----------------------------------------------------------------------
    // Getters for from ports
    // ----------------------------------------------------------------------

    //! Get from port at index
    //!
    //! \return from_noArgsOut[portNum]
    Ports::InputNoArgsPort* get_from_noArgsOut(
        FwIndexType portNum //!< The port number
    );

    //! Get from port at index
    //!
    //! \return from_noArgsReturnOut[portNum]
    Ports::InputNoArgsReturnPort* get_from_noArgsReturnOut(
        FwIndexType portNum //!< The port number
    );

#endif

  protected:

    // ----------------------------------------------------------------------
    // Component construction and destruction
    // ----------------------------------------------------------------------

    //! Construct object ActiveNoArgsPortsOnlyTesterBase
    ActiveNoArgsPortsOnlyTesterBase(
        const char* const compName, //!< The component name
        const U32 maxHistorySize //!< The maximum size of each history
    );

    //! Destroy object ActiveNoArgsPortsOnlyTesterBase
    virtual ~ActiveNoArgsPortsOnlyTesterBase();

  protected:

    // ----------------------------------------------------------------------
    // Default handler implementations for typed from ports
    // You can override these implementation with more specific behavior
    // ----------------------------------------------------------------------

    //! Default handler implementation for from_noArgsOut
    virtual void from_noArgsOut_handler(
        FwIndexType portNum //!< The port number
    );

    //! Default handler implementation for from_noArgsReturnOut
    virtual U32 from_noArgsReturnOut_handler(
        FwIndexType portNum //!< The port number
    );

  protected:

    // ----------------------------------------------------------------------
    // Handler base-class functions for from ports
    // ----------------------------------------------------------------------

    //! Handler base-class function for from_noArgsOut
    void from_noArgsOut_handlerBase(
        FwIndexType portNum //!< The port number
    );

    //! Handler base-class function for from_noArgsReturnOut
    U32 from_noArgsReturnOut_handlerBase(
        FwIndexType portNum //!< The port number
    );

  protected:

    // ----------------------------------------------------------------------
    // Invocation functions for to ports
    // ----------------------------------------------------------------------

    //! Invoke the to port connected to noArgsAsync
    void invoke_to_noArgsAsync(
        FwIndexType portNum //!< The port number
    );

    //! Invoke the to port connected to noArgsGuarded
    void invoke_to_noArgsGuarded(
        FwIndexType portNum //!< The port number
    );

    //! Invoke the to port connected to noArgsReturnGuarded
    U32 invoke_to_noArgsReturnGuarded(
        FwIndexType portNum //!< The port number
    );

    //! Invoke the to port connected to noArgsReturnSync
    U32 invoke_to_noArgsReturnSync(
        FwIndexType portNum //!< The port number
    );

  protected:

    // ----------------------------------------------------------------------
    // Getters for port counts
    // ----------------------------------------------------------------------

    //! Get the number of to_noArgsAsync ports
    //!
    //! \return The number of to_noArgsAsync ports
    static constexpr FwIndexType getNum_to_noArgsAsync() {
      return ActiveNoArgsPortsOnlyComponentBase::NUM_NOARGSASYNC_INPUT_PORTS;
    }

    //! Get the number of to_noArgsGuarded ports
    //!
    //! \return The number of to_noArgsGuarded ports
    static constexpr FwIndexType getNum_to_noArgsGuarded() {
      return ActiveNoArgsPortsOnlyComponentBase::NUM_NOARGSGUARDED_INPUT_PORTS;
    }

    //! Get the number of to_noArgsReturnGuarded ports
    //!
    //! \return The number of to_noArgsReturnGuarded ports
    static constexpr FwIndexType getNum_to_noArgsReturnGuarded() {
      return ActiveNoArgsPortsOnlyComponentBase::NUM_NOARGSRETURNGUARDED_INPUT_PORTS;
    }

    //! Get the number of to_noArgsReturnSync ports
    //!
    //! \return The number of to_noArgsReturnSync ports
    static constexpr FwIndexType getNum_to_noArgsReturnSync() {
      return ActiveNoArgsPortsOnlyComponentBase::NUM_NOARGSRETURNSYNC_INPUT_PORTS;
    }

    //! Get the number of from_noArgsOut ports
    //!
    //! \return The number of from_noArgsOut ports
    static constexpr FwIndexType getNum_from_noArgsOut() {
      return ActiveNoArgsPortsOnlyComponentBase::NUM_NOARGSOUT_OUTPUT_PORTS;
    }

    //! Get the number of from_noArgsReturnOut ports
    //!
    //! \return The number of from_noArgsReturnOut ports
    static constexpr FwIndexType getNum_from_noArgsReturnOut() {
      return ActiveNoArgsPortsOnlyComponentBase::NUM_NOARGSRETURNOUT_OUTPUT_PORTS;
    }

  protected:

    // ----------------------------------------------------------------------
    // Connection status queries for to ports
    // ----------------------------------------------------------------------

    //! Check whether port to_noArgsAsync is connected
    //!
    //! \return Whether port to_noArgsAsync is connected
    bool isConnected_to_noArgsAsync(
        FwIndexType portNum //!< The port number
    );

    //! Check whether port to_noArgsGuarded is connected
    //!
    //! \return Whether port to_noArgsGuarded is connected
    bool isConnected_to_noArgsGuarded(
        FwIndexType portNum //!< The port number
    );

    //! Check whether port to_noArgsReturnGuarded is connected
    //!
    //! \return Whether port to_noArgsReturnGuarded is connected
    bool isConnected_to_noArgsReturnGuarded(
        FwIndexType portNum //!< The port number
    );

    //! Check whether port to_noArgsReturnSync is connected
    //!
    //! \return Whether port to_noArgsReturnSync is connected
    bool isConnected_to_noArgsReturnSync(
        FwIndexType portNum //!< The port number
    );

  protected:

    // ----------------------------------------------------------------------
    // History functions
    // ----------------------------------------------------------------------

    //! Clear all history
    void clearHistory();

    //! Clear from port history
    void clearFromPortHistory();

    //! Push an entry on the history for from_noArgsOut
    void pushFromPortEntry_noArgsOut();

    //! Push an entry on the history for from_noArgsReturnOut
    void pushFromPortEntry_noArgsReturnOut();

  public:

    // ----------------------------------------------------------------------
    // Dispatching helper functions
    // ----------------------------------------------------------------------

    //! Calls component's doDispatch on behalf of the caller
    static ActiveNoArgsPortsOnlyComponentBase::MsgDispatchStatus dispatchOne(
        ActiveNoArgsPortsOnlyComponentBase& component //!< The component to dispatch
    );

    //! Call component's doDispatch for all current messages unless ERROR, or EXIT
    static ActiveNoArgsPortsOnlyComponentBase::MsgDispatchStatus dispatchCurrentMessages(
        ActiveNoArgsPortsOnlyComponentBase& component //!< The component to dispatch
    );

  private:

    // ----------------------------------------------------------------------
    // Static functions for output ports
    // ----------------------------------------------------------------------

    //! Static function for port from_noArgsOut
    static void from_noArgsOut_static(
        Fw::PassiveComponentBase* const callComp, //!< The component instance
        FwIndexType portNum //!< The port number
    );

    //! Static function for port from_noArgsReturnOut
    static U32 from_noArgsReturnOut_static(
        Fw::PassiveComponentBase* const callComp, //!< The component instance
        FwIndexType portNum //!< The port number
    );

  protected:

    // ----------------------------------------------------------------------
    // History member variables
    // ----------------------------------------------------------------------

    //! The total number of port entries
    U32 fromPortHistorySize;

    //! The size of history for from_noArgsOut
    U32 fromPortHistorySize_noArgsOut;

    //! The size of history for from_noArgsReturnOut
    U32 fromPortHistorySize_noArgsReturnOut;

  private:

    // ----------------------------------------------------------------------
    // To ports
    // ----------------------------------------------------------------------

    //! To port connected to noArgsAsync
    Ports::OutputNoArgsPort m_to_noArgsAsync[3];

    //! To port connected to noArgsGuarded
    Ports::OutputNoArgsPort m_to_noArgsGuarded[1];

    //! To port connected to noArgsReturnGuarded
    Ports::OutputNoArgsReturnPort m_to_noArgsReturnGuarded[1];

    //! To port connected to noArgsReturnSync
    Ports::OutputNoArgsReturnPort m_to_noArgsReturnSync[3];

  private:

    // ----------------------------------------------------------------------
    // From ports
    // ----------------------------------------------------------------------

    //! From port connected to noArgsOut
    Ports::InputNoArgsPort m_from_noArgsOut[1];

    //! From port connected to noArgsReturnOut
    Ports::InputNoArgsReturnPort m_from_noArgsReturnOut[1];

};

#endif
