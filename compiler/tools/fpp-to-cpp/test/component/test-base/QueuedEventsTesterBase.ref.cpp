// ======================================================================
// \title  QueuedEventsTesterBase.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for QueuedEvents component test harness base class
// ======================================================================

#include <cstdlib>
#include <cstring>

#include "test-base/QueuedEventsTesterBase.hpp"

// ----------------------------------------------------------------------
// Component initialization
// ----------------------------------------------------------------------

void QueuedEventsTesterBase ::
  init(FwEnumStoreType instance)
{
  // Initialize base class
  Fw::PassiveComponentBase::init(instance);

  // Connect input port eventOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_eventOut());
    port++
  ) {
    this->m_from_eventOut[port].init();
    this->m_from_eventOut[port].addCallComp(
      this,
      from_eventOut_static
    );
    this->m_from_eventOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_eventOut[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_eventOut[port].setObjName(portName.toChar());
#endif
  }

#if FW_ENABLE_TEXT_LOGGING == 1
  // Connect input port textEventOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_textEventOut());
    port++
  ) {
    this->m_from_textEventOut[port].init();
    this->m_from_textEventOut[port].addCallComp(
      this,
      from_textEventOut_static
    );
    this->m_from_textEventOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_textEventOut[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_textEventOut[port].setObjName(portName.toChar());
#endif
  }
#endif

  // Connect input port timeGetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_timeGetOut());
    port++
  ) {
    this->m_from_timeGetOut[port].init();
    this->m_from_timeGetOut[port].addCallComp(
      this,
      from_timeGetOut_static
    );
    this->m_from_timeGetOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_timeGetOut[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_timeGetOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_noArgsOut());
    port++
  ) {
    this->m_from_noArgsOut[port].init();
    this->m_from_noArgsOut[port].addCallComp(
      this,
      from_noArgsOut_static
    );
    this->m_from_noArgsOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_noArgsOut[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_noArgsOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsReturnOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_noArgsReturnOut());
    port++
  ) {
    this->m_from_noArgsReturnOut[port].init();
    this->m_from_noArgsReturnOut[port].addCallComp(
      this,
      from_noArgsReturnOut_static
    );
    this->m_from_noArgsReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_noArgsReturnOut[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_noArgsReturnOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_typedOut());
    port++
  ) {
    this->m_from_typedOut[port].init();
    this->m_from_typedOut[port].addCallComp(
      this,
      from_typedOut_static
    );
    this->m_from_typedOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_typedOut[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_typedOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedReturnOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_typedReturnOut());
    port++
  ) {
    this->m_from_typedReturnOut[port].init();
    this->m_from_typedReturnOut[port].addCallComp(
      this,
      from_typedReturnOut_static
    );
    this->m_from_typedReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_typedReturnOut[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_typedReturnOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsAsync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_noArgsAsync());
    port++
  ) {
    this->m_to_noArgsAsync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_noArgsAsync[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_noArgsAsync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_noArgsGuarded());
    port++
  ) {
    this->m_to_noArgsGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_noArgsGuarded[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_noArgsGuarded[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsReturnGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_noArgsReturnGuarded());
    port++
  ) {
    this->m_to_noArgsReturnGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_noArgsReturnGuarded[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_noArgsReturnGuarded[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_noArgsReturnSync());
    port++
  ) {
    this->m_to_noArgsReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_noArgsReturnSync[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_noArgsReturnSync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_noArgsSync());
    port++
  ) {
    this->m_to_noArgsSync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_noArgsSync[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_noArgsSync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAsync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedAsync());
    port++
  ) {
    this->m_to_typedAsync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedAsync[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedAsync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAsyncAssert
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedAsyncAssert());
    port++
  ) {
    this->m_to_typedAsyncAssert[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedAsyncAssert[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedAsyncAssert[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAsyncBlockPriority
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedAsyncBlockPriority());
    port++
  ) {
    this->m_to_typedAsyncBlockPriority[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedAsyncBlockPriority[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedAsyncBlockPriority[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAsyncDropPriority
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedAsyncDropPriority());
    port++
  ) {
    this->m_to_typedAsyncDropPriority[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedAsyncDropPriority[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedAsyncDropPriority[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedGuarded());
    port++
  ) {
    this->m_to_typedGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedGuarded[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedGuarded[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedReturnGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedReturnGuarded());
    port++
  ) {
    this->m_to_typedReturnGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedReturnGuarded[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedReturnGuarded[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedReturnSync());
    port++
  ) {
    this->m_to_typedReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedReturnSync[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedReturnSync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedSync());
    port++
  ) {
    this->m_to_typedSync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedSync[%" PRI_PlatformIntType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedSync[port].setObjName(portName.toChar());
#endif
  }
}

// ----------------------------------------------------------------------
// Connectors for to ports
// ----------------------------------------------------------------------

void QueuedEventsTesterBase ::
  connect_to_cmdIn(
      FwIndexType portNum,
      Fw::InputCmdPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_cmdIn(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_cmdIn[portNum].addCallPort(port);
}

void QueuedEventsTesterBase ::
  connect_to_noArgsAsync(
      FwIndexType portNum,
      Ports::InputNoArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsAsync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsAsync[portNum].addCallPort(port);
}

void QueuedEventsTesterBase ::
  connect_to_noArgsGuarded(
      FwIndexType portNum,
      Ports::InputNoArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsGuarded[portNum].addCallPort(port);
}

void QueuedEventsTesterBase ::
  connect_to_noArgsReturnGuarded(
      FwIndexType portNum,
      Ports::InputNoArgsReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsReturnGuarded[portNum].addCallPort(port);
}

void QueuedEventsTesterBase ::
  connect_to_noArgsReturnSync(
      FwIndexType portNum,
      Ports::InputNoArgsReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsReturnSync[portNum].addCallPort(port);
}

void QueuedEventsTesterBase ::
  connect_to_noArgsSync(
      FwIndexType portNum,
      Ports::InputNoArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsSync[portNum].addCallPort(port);
}

void QueuedEventsTesterBase ::
  connect_to_typedAsync(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAsync[portNum].addCallPort(port);
}

void QueuedEventsTesterBase ::
  connect_to_typedAsyncAssert(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncAssert(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAsyncAssert[portNum].addCallPort(port);
}

void QueuedEventsTesterBase ::
  connect_to_typedAsyncBlockPriority(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncBlockPriority(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAsyncBlockPriority[portNum].addCallPort(port);
}

void QueuedEventsTesterBase ::
  connect_to_typedAsyncDropPriority(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncDropPriority(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAsyncDropPriority[portNum].addCallPort(port);
}

void QueuedEventsTesterBase ::
  connect_to_typedGuarded(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedGuarded[portNum].addCallPort(port);
}

void QueuedEventsTesterBase ::
  connect_to_typedReturnGuarded(
      FwIndexType portNum,
      Ports::InputTypedReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedReturnGuarded[portNum].addCallPort(port);
}

void QueuedEventsTesterBase ::
  connect_to_typedReturnSync(
      FwIndexType portNum,
      Ports::InputTypedReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedReturnSync[portNum].addCallPort(port);
}

void QueuedEventsTesterBase ::
  connect_to_typedSync(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedSync[portNum].addCallPort(port);
}

// ----------------------------------------------------------------------
// Getters for from ports
// ----------------------------------------------------------------------

Fw::InputCmdRegPort* QueuedEventsTesterBase ::
  get_from_cmdRegOut(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_cmdRegOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_cmdRegOut[portNum];
}

Fw::InputCmdResponsePort* QueuedEventsTesterBase ::
  get_from_cmdResponseOut(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_cmdResponseOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_cmdResponseOut[portNum];
}

Fw::InputLogPort* QueuedEventsTesterBase ::
  get_from_eventOut(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_eventOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_eventOut[portNum];
}

Fw::InputPrmGetPort* QueuedEventsTesterBase ::
  get_from_prmGetOut(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_prmGetOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_prmGetOut[portNum];
}

Fw::InputPrmSetPort* QueuedEventsTesterBase ::
  get_from_prmSetOut(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_prmSetOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_prmSetOut[portNum];
}

#if FW_ENABLE_TEXT_LOGGING == 1

Fw::InputLogTextPort* QueuedEventsTesterBase ::
  get_from_textEventOut(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_textEventOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_textEventOut[portNum];
}

#endif

Fw::InputTimePort* QueuedEventsTesterBase ::
  get_from_timeGetOut(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_timeGetOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_timeGetOut[portNum];
}

Fw::InputTlmPort* QueuedEventsTesterBase ::
  get_from_tlmOut(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_tlmOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_tlmOut[portNum];
}

Ports::InputNoArgsPort* QueuedEventsTesterBase ::
  get_from_noArgsOut(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_noArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_noArgsOut[portNum];
}

Ports::InputNoArgsReturnPort* QueuedEventsTesterBase ::
  get_from_noArgsReturnOut(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_noArgsReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_noArgsReturnOut[portNum];
}

Ports::InputTypedPort* QueuedEventsTesterBase ::
  get_from_typedOut(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_typedOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_typedOut[portNum];
}

Ports::InputTypedReturnPort* QueuedEventsTesterBase ::
  get_from_typedReturnOut(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_typedReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_typedReturnOut[portNum];
}

// ----------------------------------------------------------------------
// Component construction and destruction
// ----------------------------------------------------------------------

QueuedEventsTesterBase ::
  QueuedEventsTesterBase(
      const char* const compName,
      const U32 maxHistorySize
  ) :
    Fw::PassiveComponentBase(compName)
{
  // Initialize port histories
  this->fromPortHistory_typedOut = new History<FromPortEntry_typedOut>(maxHistorySize);
  this->fromPortHistory_typedReturnOut = new History<FromPortEntry_typedReturnOut>(maxHistorySize);

  // Initialize event histories
#if FW_ENABLE_TEXT_LOGGING
  this->textLogHistory = new History<TextLogEntry>(maxHistorySize);
#endif
  this->eventHistory_EventActivityLowThrottled = new History<EventEntry_EventActivityLowThrottled>(maxHistorySize);
  this->eventHistory_EventCommand = new History<EventEntry_EventCommand>(maxHistorySize);
  this->eventHistory_EventDiagnostic = new History<EventEntry_EventDiagnostic>(maxHistorySize);
  this->eventHistory_EventFatalThrottled = new History<EventEntry_EventFatalThrottled>(maxHistorySize);
  this->eventHistory_EventWarningHigh = new History<EventEntry_EventWarningHigh>(maxHistorySize);

  // Clear history
  this->clearHistory();
}

QueuedEventsTesterBase ::
  ~QueuedEventsTesterBase()
{
  // Destroy port histories
  delete this->fromPortHistory_typedOut;
  delete this->fromPortHistory_typedReturnOut;

  // Destroy event histories
#if FW_ENABLE_TEXT_LOGGING
  delete this->textLogHistory;
#endif
  delete this->eventHistory_EventActivityLowThrottled;
  delete this->eventHistory_EventCommand;
  delete this->eventHistory_EventDiagnostic;
  delete this->eventHistory_EventFatalThrottled;
  delete this->eventHistory_EventWarningHigh;
}

// ----------------------------------------------------------------------
// Default handler implementations for typed from ports
// You can override these implementation with more specific behavior
// ----------------------------------------------------------------------

void QueuedEventsTesterBase ::
  from_noArgsOut_handler(FwIndexType portNum)
{
  this->pushFromPortEntry_noArgsOut();
}

U32 QueuedEventsTesterBase ::
  from_noArgsReturnOut_handler(FwIndexType portNum)
{
  this->pushFromPortEntry_noArgsReturnOut();
  return 0;
}

void QueuedEventsTesterBase ::
  from_typedOut_handler(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  this->pushFromPortEntry_typedOut(u32, f32, b, str1, e, a, s);
}

F32 QueuedEventsTesterBase ::
  from_typedReturnOut_handler(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  this->pushFromPortEntry_typedReturnOut(u32, f32, b, str2, e, a, s);
  return 0.0f;
}

// ----------------------------------------------------------------------
// Handler base-class functions for from ports
// ----------------------------------------------------------------------

void QueuedEventsTesterBase ::
  from_noArgsOut_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_noArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_noArgsOut_handler(portNum);
}

U32 QueuedEventsTesterBase ::
  from_noArgsReturnOut_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_noArgsReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_noArgsReturnOut_handler(portNum);
}

void QueuedEventsTesterBase ::
  from_typedOut_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_typedOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_typedOut_handler(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 QueuedEventsTesterBase ::
  from_typedReturnOut_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_typedReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_typedReturnOut_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Invocation functions for to ports
// ----------------------------------------------------------------------

void QueuedEventsTesterBase ::
  invoke_to_noArgsAsync(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsAsync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_noArgsAsync[portNum].invoke();
}

void QueuedEventsTesterBase ::
  invoke_to_noArgsGuarded(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_noArgsGuarded[portNum].invoke();
}

U32 QueuedEventsTesterBase ::
  invoke_to_noArgsReturnGuarded(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_noArgsReturnGuarded[portNum].invoke();
}

U32 QueuedEventsTesterBase ::
  invoke_to_noArgsReturnSync(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_noArgsReturnSync[portNum].invoke();
}

void QueuedEventsTesterBase ::
  invoke_to_noArgsSync(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_noArgsSync[portNum].invoke();
}

void QueuedEventsTesterBase ::
  invoke_to_typedAsync(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedAsync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedAsync[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedEventsTesterBase ::
  invoke_to_typedAsyncAssert(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncAssert(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedAsyncAssert[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedEventsTesterBase ::
  invoke_to_typedAsyncBlockPriority(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncBlockPriority(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedAsyncBlockPriority[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedEventsTesterBase ::
  invoke_to_typedAsyncDropPriority(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncDropPriority(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedAsyncDropPriority[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedEventsTesterBase ::
  invoke_to_typedGuarded(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedGuarded[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 QueuedEventsTesterBase ::
  invoke_to_typedReturnGuarded(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_typedReturnGuarded[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

F32 QueuedEventsTesterBase ::
  invoke_to_typedReturnSync(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_typedReturnSync[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void QueuedEventsTesterBase ::
  invoke_to_typedSync(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedSync[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Getters for port counts
// ----------------------------------------------------------------------

FwIndexType QueuedEventsTesterBase ::
  getNum_to_cmdIn() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_cmdIn));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_to_noArgsAsync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsAsync));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_to_noArgsGuarded() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsGuarded));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_to_noArgsReturnGuarded() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsReturnGuarded));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_to_noArgsReturnSync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsReturnSync));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_to_noArgsSync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsSync));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_to_typedAsync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsync));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_to_typedAsyncAssert() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsyncAssert));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_to_typedAsyncBlockPriority() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsyncBlockPriority));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_to_typedAsyncDropPriority() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsyncDropPriority));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_to_typedGuarded() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedGuarded));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_to_typedReturnGuarded() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedReturnGuarded));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_to_typedReturnSync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedReturnSync));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_to_typedSync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedSync));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_from_cmdRegOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_cmdRegOut));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_from_cmdResponseOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_cmdResponseOut));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_from_eventOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_eventOut));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_from_prmGetOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_prmGetOut));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_from_prmSetOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_prmSetOut));
}

#if FW_ENABLE_TEXT_LOGGING == 1

FwIndexType QueuedEventsTesterBase ::
  getNum_from_textEventOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_textEventOut));
}

#endif

FwIndexType QueuedEventsTesterBase ::
  getNum_from_timeGetOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_timeGetOut));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_from_tlmOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_tlmOut));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_from_noArgsOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_noArgsOut));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_from_noArgsReturnOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_noArgsReturnOut));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_from_typedOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedOut));
}

FwIndexType QueuedEventsTesterBase ::
  getNum_from_typedReturnOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedReturnOut));
}

// ----------------------------------------------------------------------
// Connection status queries for to ports
// ----------------------------------------------------------------------

bool QueuedEventsTesterBase ::
  isConnected_to_cmdIn(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_cmdIn(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_cmdIn[portNum].isConnected();
}

bool QueuedEventsTesterBase ::
  isConnected_to_noArgsAsync(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsAsync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsAsync[portNum].isConnected();
}

bool QueuedEventsTesterBase ::
  isConnected_to_noArgsGuarded(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsGuarded[portNum].isConnected();
}

bool QueuedEventsTesterBase ::
  isConnected_to_noArgsReturnGuarded(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsReturnGuarded[portNum].isConnected();
}

bool QueuedEventsTesterBase ::
  isConnected_to_noArgsReturnSync(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsReturnSync[portNum].isConnected();
}

bool QueuedEventsTesterBase ::
  isConnected_to_noArgsSync(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsSync[portNum].isConnected();
}

bool QueuedEventsTesterBase ::
  isConnected_to_typedAsync(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAsync[portNum].isConnected();
}

bool QueuedEventsTesterBase ::
  isConnected_to_typedAsyncAssert(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncAssert(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAsyncAssert[portNum].isConnected();
}

bool QueuedEventsTesterBase ::
  isConnected_to_typedAsyncBlockPriority(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncBlockPriority(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAsyncBlockPriority[portNum].isConnected();
}

bool QueuedEventsTesterBase ::
  isConnected_to_typedAsyncDropPriority(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncDropPriority(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAsyncDropPriority[portNum].isConnected();
}

bool QueuedEventsTesterBase ::
  isConnected_to_typedGuarded(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedGuarded[portNum].isConnected();
}

bool QueuedEventsTesterBase ::
  isConnected_to_typedReturnGuarded(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedReturnGuarded[portNum].isConnected();
}

bool QueuedEventsTesterBase ::
  isConnected_to_typedReturnSync(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedReturnSync[portNum].isConnected();
}

bool QueuedEventsTesterBase ::
  isConnected_to_typedSync(FwIndexType portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedSync[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Functions for testing events
// ----------------------------------------------------------------------

void QueuedEventsTesterBase ::
  dispatchEvents(
      FwEventIdType id,
      const Fw::Time& timeTag,
      const Fw::LogSeverity severity,
      Fw::LogBuffer& args
  )
{
  args.resetDeser();

  const U32 idBase = this->getIdBase();
  FW_ASSERT(
    id >= idBase,
    static_cast<FwAssertArgType>(id),
    static_cast<FwAssertArgType>(idBase)
  );

  switch (id - idBase) {
    case QueuedEventsComponentBase::EVENTID_EVENTACTIVITYHIGH: {
#if FW_AMPCS_COMPATIBLE
      // For AMPCS, decode zero arguments
      Fw::SerializeStatus _zero_status = Fw::FW_SERIALIZE_OK;
      U8 _noArgs;
      _zero_status = args.deserialize(_noArgs);
      FW_ASSERT(
        _zero_status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_zero_status)
      );
#endif
      this->logIn_ACTIVITY_HI_EventActivityHigh();
      break;
    }

    case QueuedEventsComponentBase::EVENTID_EVENTACTIVITYLOWTHROTTLED: {
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Deserialize the number of arguments.
      U8 _numArgs;
      _status = args.deserialize(_numArgs);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      // Verify they match expected.
      FW_ASSERT(
        _numArgs == 3,
        static_cast<FwAssertArgType>(_numArgs),
        static_cast<FwAssertArgType>(3)
      );
#endif

      U32 _event_arg_u32;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          _argSize == sizeof(U32),
          static_cast<FwAssertArgType>(_argSize),
          static_cast<FwAssertArgType>(sizeof(U32))
        );
      }
#endif
      _status = args.deserialize(_event_arg_u32);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      F32 _event_arg_f32;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          _argSize == sizeof(F32),
          static_cast<FwAssertArgType>(_argSize),
          static_cast<FwAssertArgType>(sizeof(F32))
        );
      }
#endif
      _status = args.deserialize(_event_arg_f32);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      bool _event_arg_b;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          _argSize == sizeof(U8),
          static_cast<FwAssertArgType>(_argSize),
          static_cast<FwAssertArgType>(sizeof(U8))
        );
      }
#endif
      _status = args.deserialize(_event_arg_b);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      this->logIn_ACTIVITY_LO_EventActivityLowThrottled(_event_arg_u32, _event_arg_f32, _event_arg_b);
      break;
    }

    case QueuedEventsComponentBase::EVENTID_EVENTCOMMAND: {
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Deserialize the number of arguments.
      U8 _numArgs;
      _status = args.deserialize(_numArgs);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      // Verify they match expected.
      FW_ASSERT(
        _numArgs == 2,
        static_cast<FwAssertArgType>(_numArgs),
        static_cast<FwAssertArgType>(2)
      );
#endif

      Fw::LogStringArg _event_arg_str1;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          _argSize == Fw::LogStringArg::SERIALIZED_SIZE,
          static_cast<FwAssertArgType>(_argSize),
          static_cast<FwAssertArgType>(Fw::LogStringArg::SERIALIZED_SIZE)
        );
      }
#endif
      _status = args.deserialize(_event_arg_str1);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      Fw::LogStringArg _event_arg_str2;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          _argSize == Fw::LogStringArg::SERIALIZED_SIZE,
          static_cast<FwAssertArgType>(_argSize),
          static_cast<FwAssertArgType>(Fw::LogStringArg::SERIALIZED_SIZE)
        );
      }
#endif
      _status = args.deserialize(_event_arg_str2);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      this->logIn_COMMAND_EventCommand(_event_arg_str1, _event_arg_str2);
      break;
    }

    case QueuedEventsComponentBase::EVENTID_EVENTDIAGNOSTIC: {
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Deserialize the number of arguments.
      U8 _numArgs;
      _status = args.deserialize(_numArgs);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      // Verify they match expected.
      FW_ASSERT(
        _numArgs == 1,
        static_cast<FwAssertArgType>(_numArgs),
        static_cast<FwAssertArgType>(1)
      );
#endif

      E _event_arg_e;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          _argSize == E::SERIALIZED_SIZE,
          static_cast<FwAssertArgType>(_argSize),
          static_cast<FwAssertArgType>(E::SERIALIZED_SIZE)
        );
      }
#endif
      _status = args.deserialize(_event_arg_e);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      this->logIn_DIAGNOSTIC_EventDiagnostic(_event_arg_e);
      break;
    }

    case QueuedEventsComponentBase::EVENTID_EVENTFATALTHROTTLED: {
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Deserialize the number of arguments.
      U8 _numArgs;
      _status = args.deserialize(_numArgs);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      // Verify they match expected.
      FW_ASSERT(
        _numArgs == 1 + 1,
        static_cast<FwAssertArgType>(_numArgs),
        static_cast<FwAssertArgType>(1 + 1)
      );

      // For FATAL, there is a stack size of 4 and a dummy entry
      U8 stackArgLen;
      _status = args.deserialize(stackArgLen);
      FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        stackArgLen == 4,
        static_cast<FwAssertArgType>(stackArgLen)
      );

      U32 dummyStackArg;
      _status = args.deserialize(dummyStackArg);
      FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        dummyStackArg == 0,
        static_cast<FwAssertArgType>(dummyStackArg)
      );
#endif

      A _event_arg_a;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          _argSize == A::SERIALIZED_SIZE,
          static_cast<FwAssertArgType>(_argSize),
          static_cast<FwAssertArgType>(A::SERIALIZED_SIZE)
        );
      }
#endif
      _status = args.deserialize(_event_arg_a);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      this->logIn_FATAL_EventFatalThrottled(_event_arg_a);
      break;
    }

    case QueuedEventsComponentBase::EVENTID_EVENTWARNINGHIGH: {
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Deserialize the number of arguments.
      U8 _numArgs;
      _status = args.deserialize(_numArgs);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      // Verify they match expected.
      FW_ASSERT(
        _numArgs == 1,
        static_cast<FwAssertArgType>(_numArgs),
        static_cast<FwAssertArgType>(1)
      );
#endif

      S _event_arg_s;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          _argSize == S::SERIALIZED_SIZE,
          static_cast<FwAssertArgType>(_argSize),
          static_cast<FwAssertArgType>(S::SERIALIZED_SIZE)
        );
      }
#endif
      _status = args.deserialize(_event_arg_s);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      this->logIn_WARNING_HI_EventWarningHigh(_event_arg_s);
      break;
    }

    case QueuedEventsComponentBase::EVENTID_EVENTWARNINGLOWTHROTTLED: {
#if FW_AMPCS_COMPATIBLE
      // For AMPCS, decode zero arguments
      Fw::SerializeStatus _zero_status = Fw::FW_SERIALIZE_OK;
      U8 _noArgs;
      _zero_status = args.deserialize(_noArgs);
      FW_ASSERT(
        _zero_status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_zero_status)
      );
#endif
      this->logIn_WARNING_LO_EventWarningLowThrottled();
      break;
    }

    default: {
      FW_ASSERT(0, static_cast<FwAssertArgType>(id));
      break;
    }
  }
}

#if FW_ENABLE_TEXT_LOGGING

void QueuedEventsTesterBase ::
  textLogIn(
      FwEventIdType id,
      const Fw::Time& timeTag,
      const Fw::LogSeverity severity,
      const Fw::TextLogString& text
  )
{
  TextLogEntry e = { id, timeTag, severity, text };
  textLogHistory->push_back(e);
}

#endif

void QueuedEventsTesterBase ::
  logIn_ACTIVITY_HI_EventActivityHigh()
{
  this->eventsSize_EventActivityHigh++;
  this->eventsSize++;
}

void QueuedEventsTesterBase ::
  logIn_ACTIVITY_LO_EventActivityLowThrottled(
      U32 u32,
      F32 f32,
      bool b
  )
{
  EventEntry_EventActivityLowThrottled _e = {
    u32,
    f32,
    b
  };
  eventHistory_EventActivityLowThrottled->push_back(_e);
  this->eventsSize++;
}

void QueuedEventsTesterBase ::
  logIn_COMMAND_EventCommand(
      const Fw::StringBase& str1,
      const Fw::StringBase& str2
  )
{
  EventEntry_EventCommand _e = {
    str1,
    str2
  };
  eventHistory_EventCommand->push_back(_e);
  this->eventsSize++;
}

void QueuedEventsTesterBase ::
  logIn_DIAGNOSTIC_EventDiagnostic(E e)
{
  EventEntry_EventDiagnostic _e = {
    e
  };
  eventHistory_EventDiagnostic->push_back(_e);
  this->eventsSize++;
}

void QueuedEventsTesterBase ::
  logIn_FATAL_EventFatalThrottled(A a)
{
  EventEntry_EventFatalThrottled _e = {
    a
  };
  eventHistory_EventFatalThrottled->push_back(_e);
  this->eventsSize++;
}

void QueuedEventsTesterBase ::
  logIn_WARNING_HI_EventWarningHigh(S s)
{
  EventEntry_EventWarningHigh _e = {
    s
  };
  eventHistory_EventWarningHigh->push_back(_e);
  this->eventsSize++;
}

void QueuedEventsTesterBase ::
  logIn_WARNING_LO_EventWarningLowThrottled()
{
  this->eventsSize_EventWarningLowThrottled++;
  this->eventsSize++;
}

// ----------------------------------------------------------------------
// Functions to test time
// ----------------------------------------------------------------------

void QueuedEventsTesterBase ::
  setTestTime(const Fw::Time& timeTag)
{
  this->m_testTime = timeTag;
}

// ----------------------------------------------------------------------
// History functions
// ----------------------------------------------------------------------

void QueuedEventsTesterBase ::
  clearHistory()
{
  this->clearFromPortHistory();
#if FW_ENABLE_TEXT_LOGGING
  this->textLogHistory->clear();
#endif
  this->clearEvents();
}

void QueuedEventsTesterBase ::
  clearFromPortHistory()
{
  this->fromPortHistorySize = 0;
  this->fromPortHistorySize_noArgsOut = 0;
  this->fromPortHistorySize_noArgsReturnOut = 0;
  this->fromPortHistory_typedOut->clear();
  this->fromPortHistory_typedReturnOut->clear();
}

void QueuedEventsTesterBase ::
  pushFromPortEntry_noArgsOut()
{
  this->fromPortHistorySize_noArgsOut++;
  this->fromPortHistorySize++;
}

void QueuedEventsTesterBase ::
  pushFromPortEntry_noArgsReturnOut()
{
  this->fromPortHistorySize_noArgsReturnOut++;
  this->fromPortHistorySize++;
}

void QueuedEventsTesterBase ::
  pushFromPortEntry_typedOut(
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FromPortEntry_typedOut _e;
  _e.u32 = u32;
  _e.f32 = f32;
  _e.b = b;
  _e.str1 = str1;
  _e.e = e;
  _e.a = a;
  _e.s = s;
  this->fromPortHistory_typedOut->push_back(_e);
  this->fromPortHistorySize++;
}

void QueuedEventsTesterBase ::
  pushFromPortEntry_typedReturnOut(
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FromPortEntry_typedReturnOut _e;
  _e.u32 = u32;
  _e.f32 = f32;
  _e.b = b;
  _e.str2 = str2;
  _e.e = e;
  _e.a = a;
  _e.s = s;
  this->fromPortHistory_typedReturnOut->push_back(_e);
  this->fromPortHistorySize++;
}

void QueuedEventsTesterBase ::
  clearEvents()
{
  this->eventsSize = 0;
  this->eventsSize_EventActivityHigh = 0;
  this->eventHistory_EventActivityLowThrottled->clear();
  this->eventHistory_EventCommand->clear();
  this->eventHistory_EventDiagnostic->clear();
  this->eventHistory_EventFatalThrottled->clear();
  this->eventHistory_EventWarningHigh->clear();
  this->eventsSize_EventWarningLowThrottled = 0;
}

#if FW_ENABLE_TEXT_LOGGING

void QueuedEventsTesterBase ::
  printTextLogHistoryEntry(
      const TextLogEntry& e,
      FILE* file
  )
{
  const char* severityString = "UNKNOWN";

  switch (e.severity.e) {
    case Fw::LogSeverity::FATAL:
      severityString = "FATAL";
      break;
    case Fw::LogSeverity::WARNING_HI:
      severityString = "WARNING_HI";
      break;
    case Fw::LogSeverity::WARNING_LO:
      severityString = "WARNING_LO";
      break;
    case Fw::LogSeverity::COMMAND:
      severityString = "COMMAND";
      break;
    case Fw::LogSeverity::ACTIVITY_HI:
      severityString = "ACTIVITY_HI";
      break;
    case Fw::LogSeverity::ACTIVITY_LO:
      severityString = "ACTIVITY_LO";
      break;
    case Fw::LogSeverity::DIAGNOSTIC:
     severityString = "DIAGNOSTIC";
      break;
    default:
      severityString = "SEVERITY ERROR";
      break;
  }

  fprintf(
    file,
    "EVENT: (%" PRI_FwEventIdType ") (%" PRI_FwTimeBaseStoreType ":%" PRIu32 ",%" PRIu32 ") %s: %s\n",
    e.id,
    static_cast<FwTimeBaseStoreType>(e.timeTag.getTimeBase()),
    e.timeTag.getSeconds(),
    e.timeTag.getUSeconds(),
    severityString,
    e.text.toChar()
  );
}

void QueuedEventsTesterBase ::
  printTextLogHistory(FILE* const file)
{
  for (U32 i = 0; i < this->textLogHistory->size(); i++) {
    this->printTextLogHistoryEntry(
      this->textLogHistory->at(i),
      file
    );
  }
}

#endif

// ----------------------------------------------------------------------
// Static functions for output ports
// ----------------------------------------------------------------------

void QueuedEventsTesterBase ::
  from_eventOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      FwEventIdType id,
      Fw::Time& timeTag,
      const Fw::LogSeverity& severity,
      Fw::LogBuffer& args
  )
{
  QueuedEventsTesterBase* _testerBase = static_cast<QueuedEventsTesterBase*>(callComp);
  _testerBase->dispatchEvents(id, timeTag, severity, args);
}

#if FW_ENABLE_TEXT_LOGGING == 1

void QueuedEventsTesterBase ::
  from_textEventOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      FwEventIdType id,
      Fw::Time& timeTag,
      const Fw::LogSeverity& severity,
      Fw::TextLogString& text
  )
{
  QueuedEventsTesterBase* _testerBase = static_cast<QueuedEventsTesterBase*>(callComp);
  _testerBase->textLogIn(id, timeTag, severity, text);
}

#endif

void QueuedEventsTesterBase ::
  from_timeGetOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      Fw::Time& time
  )
{
  QueuedEventsTesterBase* _testerBase = static_cast<QueuedEventsTesterBase*>(callComp);
  time = _testerBase->m_testTime;
}

void QueuedEventsTesterBase ::
  from_noArgsOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp != nullptr);
  QueuedEventsTesterBase* _testerBase = static_cast<QueuedEventsTesterBase*>(callComp);
  _testerBase->from_noArgsOut_handlerBase(portNum);
}

U32 QueuedEventsTesterBase ::
  from_noArgsReturnOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp != nullptr);
  QueuedEventsTesterBase* _testerBase = static_cast<QueuedEventsTesterBase*>(callComp);
  return _testerBase->from_noArgsReturnOut_handlerBase(portNum);
}

void QueuedEventsTesterBase ::
  from_typedOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp != nullptr);
  QueuedEventsTesterBase* _testerBase = static_cast<QueuedEventsTesterBase*>(callComp);
  _testerBase->from_typedOut_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 QueuedEventsTesterBase ::
  from_typedReturnOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp != nullptr);
  QueuedEventsTesterBase* _testerBase = static_cast<QueuedEventsTesterBase*>(callComp);
  return _testerBase->from_typedReturnOut_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}
