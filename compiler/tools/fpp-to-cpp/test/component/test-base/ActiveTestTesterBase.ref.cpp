// ======================================================================
// \title  ActiveTestTesterBase.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for ActiveTest component test harness base class
// ======================================================================

#include <cstdlib>
#include <cstring>

#include "test-base/ActiveTestTesterBase.hpp"

namespace M {

  // ----------------------------------------------------------------------
  // Unit test implementation of external parameter delegate serialization/deserialization
  // ----------------------------------------------------------------------

  Fw::SerializeStatus ActiveTestTesterBase::ActiveTestComponentBaseParamExternalDelegate ::
    deserializeParam(
        const FwPrmIdType base_id,
        const FwPrmIdType local_id,
        const Fw::ParamValid prmStat,
        Fw::SerializeBufferBase& buff
    )
  {
    Fw::SerializeStatus stat;
    (void) base_id;

    // Serialize the parameter based on ID
    switch(local_id)
    {
      // ParamI32Ext
      case ActiveTestComponentBase::PARAMID_PARAMI32EXT:
        stat = buff.deserialize(this->m_param_ParamI32Ext);
        break;
      // ParamF64Ext
      case ActiveTestComponentBase::PARAMID_PARAMF64EXT:
        stat = buff.deserialize(this->m_param_ParamF64Ext);
        break;
      // ParamStringExt
      case ActiveTestComponentBase::PARAMID_PARAMSTRINGEXT:
        stat = buff.deserialize(this->m_param_ParamStringExt);
        break;
      // ParamEnumExt
      case ActiveTestComponentBase::PARAMID_PARAMENUMEXT:
        stat = buff.deserialize(this->m_param_ParamEnumExt);
        break;
      // ParamArrayExt
      case ActiveTestComponentBase::PARAMID_PARAMARRAYEXT:
        stat = buff.deserialize(this->m_param_ParamArrayExt);
        break;
      // ParamStructExt
      case ActiveTestComponentBase::PARAMID_PARAMSTRUCTEXT:
        stat = buff.deserialize(this->m_param_ParamStructExt);
        break;
      default:
        // Unknown ID should not have gotten here
        FW_ASSERT(false, local_id);
    }

    return stat;
  }

  Fw::SerializeStatus ActiveTestTesterBase::ActiveTestComponentBaseParamExternalDelegate ::
    serializeParam(
        const FwPrmIdType base_id,
        const FwPrmIdType local_id,
        Fw::SerializeBufferBase& buff
    ) const
  {
    Fw::SerializeStatus stat;
    (void) base_id;

    // Serialize the parameter based on ID
    switch(local_id)
    {
      // ParamI32Ext
      case ActiveTestComponentBase::PARAMID_PARAMI32EXT:
        stat = buff.serialize(this->m_param_ParamI32Ext);
        break;
      // ParamF64Ext
      case ActiveTestComponentBase::PARAMID_PARAMF64EXT:
        stat = buff.serialize(this->m_param_ParamF64Ext);
        break;
      // ParamStringExt
      case ActiveTestComponentBase::PARAMID_PARAMSTRINGEXT:
        stat = buff.serialize(this->m_param_ParamStringExt);
        break;
      // ParamEnumExt
      case ActiveTestComponentBase::PARAMID_PARAMENUMEXT:
        stat = buff.serialize(this->m_param_ParamEnumExt);
        break;
      // ParamArrayExt
      case ActiveTestComponentBase::PARAMID_PARAMARRAYEXT:
        stat = buff.serialize(this->m_param_ParamArrayExt);
        break;
      // ParamStructExt
      case ActiveTestComponentBase::PARAMID_PARAMSTRUCTEXT:
        stat = buff.serialize(this->m_param_ParamStructExt);
        break;
      default:
        // Unknown ID should not have gotten here
        FW_ASSERT(false, local_id);
    }

    return stat;
  }

  // ----------------------------------------------------------------------
  // Component initialization
  // ----------------------------------------------------------------------

  void ActiveTestTesterBase ::
    init(FwEnumStoreType instance)
  {
    // Initialize base class
    Fw::PassiveComponentBase::init(instance);

    // Connect input port cmdRegOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_cmdRegOut());
      port++
    ) {
      this->m_from_cmdRegOut[port].init();
      this->m_from_cmdRegOut[port].addCallComp(
        this,
        from_cmdRegOut_static
      );
      this->m_from_cmdRegOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_cmdRegOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_cmdRegOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port cmdResponseOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_cmdResponseOut());
      port++
    ) {
      this->m_from_cmdResponseOut[port].init();
      this->m_from_cmdResponseOut[port].addCallComp(
        this,
        from_cmdResponseOut_static
      );
      this->m_from_cmdResponseOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_cmdResponseOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_cmdResponseOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port eventOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_eventOut());
      port++
    ) {
      this->m_from_eventOut[port].init();
      this->m_from_eventOut[port].addCallComp(
        this,
        from_eventOut_static
      );
      this->m_from_eventOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_eventOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_eventOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port prmGetOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_prmGetOut());
      port++
    ) {
      this->m_from_prmGetOut[port].init();
      this->m_from_prmGetOut[port].addCallComp(
        this,
        from_prmGetOut_static
      );
      this->m_from_prmGetOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_prmGetOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_prmGetOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port prmSetOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_prmSetOut());
      port++
    ) {
      this->m_from_prmSetOut[port].init();
      this->m_from_prmSetOut[port].addCallComp(
        this,
        from_prmSetOut_static
      );
      this->m_from_prmSetOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_prmSetOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_prmSetOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port productRequestOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_productRequestOut());
      port++
    ) {
      this->m_from_productRequestOut[port].init();
      this->m_from_productRequestOut[port].addCallComp(
        this,
        from_productRequestOut_static
      );
      this->m_from_productRequestOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_productRequestOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_productRequestOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port productSendOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_productSendOut());
      port++
    ) {
      this->m_from_productSendOut[port].init();
      this->m_from_productSendOut[port].addCallComp(
        this,
        from_productSendOut_static
      );
      this->m_from_productSendOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_productSendOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_productSendOut[port].setObjName(portName.toChar());
#endif
    }

#if FW_ENABLE_TEXT_LOGGING == 1
    // Connect input port textEventOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_textEventOut());
      port++
    ) {
      this->m_from_textEventOut[port].init();
      this->m_from_textEventOut[port].addCallComp(
        this,
        from_textEventOut_static
      );
      this->m_from_textEventOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_textEventOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_textEventOut[port].setObjName(portName.toChar());
#endif
    }
#endif

    // Connect input port timeGetOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_timeGetOut());
      port++
    ) {
      this->m_from_timeGetOut[port].init();
      this->m_from_timeGetOut[port].addCallComp(
        this,
        from_timeGetOut_static
      );
      this->m_from_timeGetOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_timeGetOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_timeGetOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port tlmOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_tlmOut());
      port++
    ) {
      this->m_from_tlmOut[port].init();
      this->m_from_tlmOut[port].addCallComp(
        this,
        from_tlmOut_static
      );
      this->m_from_tlmOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_tlmOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_tlmOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port noArgsOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_noArgsOut());
      port++
    ) {
      this->m_from_noArgsOut[port].init();
      this->m_from_noArgsOut[port].addCallComp(
        this,
        from_noArgsOut_static
      );
      this->m_from_noArgsOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_noArgsOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_noArgsOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port noArgsReturnOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_noArgsReturnOut());
      port++
    ) {
      this->m_from_noArgsReturnOut[port].init();
      this->m_from_noArgsReturnOut[port].addCallComp(
        this,
        from_noArgsReturnOut_static
      );
      this->m_from_noArgsReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_noArgsReturnOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_noArgsReturnOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port noArgsStringReturnOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_noArgsStringReturnOut());
      port++
    ) {
      this->m_from_noArgsStringReturnOut[port].init();
      this->m_from_noArgsStringReturnOut[port].addCallComp(
        this,
        from_noArgsStringReturnOut_static
      );
      this->m_from_noArgsStringReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_noArgsStringReturnOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_noArgsStringReturnOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port typedAliasOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_typedAliasOut());
      port++
    ) {
      this->m_from_typedAliasOut[port].init();
      this->m_from_typedAliasOut[port].addCallComp(
        this,
        from_typedAliasOut_static
      );
      this->m_from_typedAliasOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_typedAliasOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_typedAliasOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port typedAliasReturnOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_typedAliasReturnOut());
      port++
    ) {
      this->m_from_typedAliasReturnOut[port].init();
      this->m_from_typedAliasReturnOut[port].addCallComp(
        this,
        from_typedAliasReturnOut_static
      );
      this->m_from_typedAliasReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_typedAliasReturnOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_typedAliasReturnOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port typedAliasReturnStringOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_typedAliasReturnStringOut());
      port++
    ) {
      this->m_from_typedAliasReturnStringOut[port].init();
      this->m_from_typedAliasReturnStringOut[port].addCallComp(
        this,
        from_typedAliasReturnStringOut_static
      );
      this->m_from_typedAliasReturnStringOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_typedAliasReturnStringOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_typedAliasReturnStringOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port typedOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_typedOut());
      port++
    ) {
      this->m_from_typedOut[port].init();
      this->m_from_typedOut[port].addCallComp(
        this,
        from_typedOut_static
      );
      this->m_from_typedOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_typedOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_typedOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port typedReturnOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_typedReturnOut());
      port++
    ) {
      this->m_from_typedReturnOut[port].init();
      this->m_from_typedReturnOut[port].addCallComp(
        this,
        from_typedReturnOut_static
      );
      this->m_from_typedReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_typedReturnOut[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_typedReturnOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port cmdIn
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_cmdIn());
      port++
    ) {
      this->m_to_cmdIn[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_cmdIn[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_cmdIn[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port productRecvIn
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_productRecvIn());
      port++
    ) {
      this->m_to_productRecvIn[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_productRecvIn[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_productRecvIn[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port aliasTypedAsync
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_aliasTypedAsync());
      port++
    ) {
      this->m_to_aliasTypedAsync[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_aliasTypedAsync[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_aliasTypedAsync[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port noArgsAliasStringReturnSync
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_noArgsAliasStringReturnSync());
      port++
    ) {
      this->m_to_noArgsAliasStringReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_noArgsAliasStringReturnSync[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_noArgsAliasStringReturnSync[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port noArgsAsync
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_noArgsAsync());
      port++
    ) {
      this->m_to_noArgsAsync[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_noArgsAsync[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_noArgsAsync[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port noArgsGuarded
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_noArgsGuarded());
      port++
    ) {
      this->m_to_noArgsGuarded[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_noArgsGuarded[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_noArgsGuarded[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port noArgsReturnGuarded
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_noArgsReturnGuarded());
      port++
    ) {
      this->m_to_noArgsReturnGuarded[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_noArgsReturnGuarded[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_noArgsReturnGuarded[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port noArgsReturnSync
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_noArgsReturnSync());
      port++
    ) {
      this->m_to_noArgsReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_noArgsReturnSync[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_noArgsReturnSync[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port noArgsStringReturnSync
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_noArgsStringReturnSync());
      port++
    ) {
      this->m_to_noArgsStringReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_noArgsStringReturnSync[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_noArgsStringReturnSync[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port noArgsSync
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_noArgsSync());
      port++
    ) {
      this->m_to_noArgsSync[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_noArgsSync[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_noArgsSync[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port typedAliasGuarded
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_typedAliasGuarded());
      port++
    ) {
      this->m_to_typedAliasGuarded[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_typedAliasGuarded[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_typedAliasGuarded[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port typedAliasReturnSync
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_typedAliasReturnSync());
      port++
    ) {
      this->m_to_typedAliasReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_typedAliasReturnSync[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_typedAliasReturnSync[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port typedAliasStringReturnSync
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_typedAliasStringReturnSync());
      port++
    ) {
      this->m_to_typedAliasStringReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_typedAliasStringReturnSync[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_typedAliasStringReturnSync[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port typedAsync
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_typedAsync());
      port++
    ) {
      this->m_to_typedAsync[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_typedAsync[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_typedAsync[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port typedAsyncAssert
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_typedAsyncAssert());
      port++
    ) {
      this->m_to_typedAsyncAssert[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_typedAsyncAssert[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_typedAsyncAssert[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port typedAsyncBlockPriority
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_typedAsyncBlockPriority());
      port++
    ) {
      this->m_to_typedAsyncBlockPriority[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_typedAsyncBlockPriority[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_typedAsyncBlockPriority[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port typedAsyncDropPriority
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_typedAsyncDropPriority());
      port++
    ) {
      this->m_to_typedAsyncDropPriority[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_typedAsyncDropPriority[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_typedAsyncDropPriority[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port typedGuarded
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_typedGuarded());
      port++
    ) {
      this->m_to_typedGuarded[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_typedGuarded[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_typedGuarded[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port typedReturnGuarded
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_typedReturnGuarded());
      port++
    ) {
      this->m_to_typedReturnGuarded[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_typedReturnGuarded[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_typedReturnGuarded[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port typedReturnSync
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_typedReturnSync());
      port++
    ) {
      this->m_to_typedReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_typedReturnSync[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_typedReturnSync[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port typedSync
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_typedSync());
      port++
    ) {
      this->m_to_typedSync[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_typedSync[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_typedSync[port].setObjName(portName.toChar());
#endif
    }
  }

  // ----------------------------------------------------------------------
  // Connectors for to ports
  // ----------------------------------------------------------------------

  void ActiveTestTesterBase ::
    connect_to_cmdIn(
        FwIndexType portNum,
        Fw::InputCmdPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_cmdIn()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_cmdIn[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_productRecvIn(
        FwIndexType portNum,
        Fw::InputDpResponsePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_productRecvIn()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_productRecvIn[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_aliasTypedAsync(
        FwIndexType portNum,
        Ports::InputAliasTypedPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_aliasTypedAsync()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_aliasTypedAsync[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_noArgsAliasStringReturnSync(
        FwIndexType portNum,
        Ports::InputNoArgsAliasStringReturnPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsAliasStringReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_noArgsAliasStringReturnSync[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_noArgsAsync(
        FwIndexType portNum,
        Ports::InputNoArgsPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsAsync()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_noArgsAsync[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_noArgsGuarded(
        FwIndexType portNum,
        Ports::InputNoArgsPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_noArgsGuarded[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_noArgsReturnGuarded(
        FwIndexType portNum,
        Ports::InputNoArgsReturnPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsReturnGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_noArgsReturnGuarded[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_noArgsReturnSync(
        FwIndexType portNum,
        Ports::InputNoArgsReturnPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_noArgsReturnSync[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_noArgsStringReturnSync(
        FwIndexType portNum,
        Ports::InputNoArgsStringReturnPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsStringReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_noArgsStringReturnSync[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_noArgsSync(
        FwIndexType portNum,
        Ports::InputNoArgsPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_noArgsSync[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_typedAliasGuarded(
        FwIndexType portNum,
        Ports::InputAliasTypedPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAliasGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_typedAliasGuarded[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_typedAliasReturnSync(
        FwIndexType portNum,
        Ports::InputAliasTypedReturnPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAliasReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_typedAliasReturnSync[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_typedAliasStringReturnSync(
        FwIndexType portNum,
        Ports::InputAliasTypedReturnStringPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAliasStringReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_typedAliasStringReturnSync[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_typedAsync(
        FwIndexType portNum,
        Ports::InputTypedPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAsync()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_typedAsync[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_typedAsyncAssert(
        FwIndexType portNum,
        Ports::InputTypedPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAsyncAssert()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_typedAsyncAssert[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_typedAsyncBlockPriority(
        FwIndexType portNum,
        Ports::InputTypedPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAsyncBlockPriority()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_typedAsyncBlockPriority[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_typedAsyncDropPriority(
        FwIndexType portNum,
        Ports::InputTypedPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAsyncDropPriority()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_typedAsyncDropPriority[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_typedGuarded(
        FwIndexType portNum,
        Ports::InputTypedPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_typedGuarded[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_typedReturnGuarded(
        FwIndexType portNum,
        Ports::InputTypedReturnPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedReturnGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_typedReturnGuarded[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_typedReturnSync(
        FwIndexType portNum,
        Ports::InputTypedReturnPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_typedReturnSync[portNum].addCallPort(port);
  }

  void ActiveTestTesterBase ::
    connect_to_typedSync(
        FwIndexType portNum,
        Ports::InputTypedPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_typedSync[portNum].addCallPort(port);
  }

  // ----------------------------------------------------------------------
  // Getters for from ports
  // ----------------------------------------------------------------------

  Fw::InputCmdRegPort* ActiveTestTesterBase ::
    get_from_cmdRegOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_cmdRegOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_cmdRegOut[portNum];
  }

  Fw::InputCmdResponsePort* ActiveTestTesterBase ::
    get_from_cmdResponseOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_cmdResponseOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_cmdResponseOut[portNum];
  }

  Fw::InputLogPort* ActiveTestTesterBase ::
    get_from_eventOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_eventOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_eventOut[portNum];
  }

  Fw::InputPrmGetPort* ActiveTestTesterBase ::
    get_from_prmGetOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_prmGetOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_prmGetOut[portNum];
  }

  Fw::InputPrmSetPort* ActiveTestTesterBase ::
    get_from_prmSetOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_prmSetOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_prmSetOut[portNum];
  }

  Fw::InputDpRequestPort* ActiveTestTesterBase ::
    get_from_productRequestOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_productRequestOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_productRequestOut[portNum];
  }

  Fw::InputDpSendPort* ActiveTestTesterBase ::
    get_from_productSendOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_productSendOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_productSendOut[portNum];
  }

#if FW_ENABLE_TEXT_LOGGING == 1

  Fw::InputLogTextPort* ActiveTestTesterBase ::
    get_from_textEventOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_textEventOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_textEventOut[portNum];
  }

#endif

  Fw::InputTimePort* ActiveTestTesterBase ::
    get_from_timeGetOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_timeGetOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_timeGetOut[portNum];
  }

  Fw::InputTlmPort* ActiveTestTesterBase ::
    get_from_tlmOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_tlmOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_tlmOut[portNum];
  }

  Ports::InputNoArgsPort* ActiveTestTesterBase ::
    get_from_noArgsOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_noArgsOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_noArgsOut[portNum];
  }

  Ports::InputNoArgsReturnPort* ActiveTestTesterBase ::
    get_from_noArgsReturnOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_noArgsReturnOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_noArgsReturnOut[portNum];
  }

  Ports::InputNoArgsStringReturnPort* ActiveTestTesterBase ::
    get_from_noArgsStringReturnOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_noArgsStringReturnOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_noArgsStringReturnOut[portNum];
  }

  Ports::InputAliasTypedPort* ActiveTestTesterBase ::
    get_from_typedAliasOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_typedAliasOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_typedAliasOut[portNum];
  }

  Ports::InputAliasTypedReturnPort* ActiveTestTesterBase ::
    get_from_typedAliasReturnOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_typedAliasReturnOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_typedAliasReturnOut[portNum];
  }

  Ports::InputAliasTypedReturnStringPort* ActiveTestTesterBase ::
    get_from_typedAliasReturnStringOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_typedAliasReturnStringOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_typedAliasReturnStringOut[portNum];
  }

  Ports::InputTypedPort* ActiveTestTesterBase ::
    get_from_typedOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_typedOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_typedOut[portNum];
  }

  Ports::InputTypedReturnPort* ActiveTestTesterBase ::
    get_from_typedReturnOut(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_typedReturnOut()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_typedReturnOut[portNum];
  }

  // ----------------------------------------------------------------------
  // Component construction and destruction
  // ----------------------------------------------------------------------

  ActiveTestTesterBase ::
    ActiveTestTesterBase(
        const char* const compName,
        const U32 maxHistorySize
    ) :
      Fw::PassiveComponentBase(compName),
      m_param_ParamU32_valid(Fw::ParamValid::UNINIT),
      m_param_ParamF64_valid(Fw::ParamValid::UNINIT),
      m_param_ParamString_valid(Fw::ParamValid::UNINIT),
      m_param_ParamEnum_valid(Fw::ParamValid::UNINIT),
      m_param_ParamArray_valid(Fw::ParamValid::UNINIT),
      m_param_ParamStruct_valid(Fw::ParamValid::UNINIT)
  {
    // Initialize port histories
    this->fromPortHistory_typedAliasOut = new History<FromPortEntry_typedAliasOut>(maxHistorySize);
    this->fromPortHistory_typedAliasReturnOut = new History<FromPortEntry_typedAliasReturnOut>(maxHistorySize);
    this->fromPortHistory_typedAliasReturnStringOut = new History<FromPortEntry_typedAliasReturnStringOut>(maxHistorySize);
    this->fromPortHistory_typedOut = new History<FromPortEntry_typedOut>(maxHistorySize);
    this->fromPortHistory_typedReturnOut = new History<FromPortEntry_typedReturnOut>(maxHistorySize);

    // Initialize command history
    this->cmdResponseHistory = new History<CmdResponse>(maxHistorySize);

    // Initialize event histories
#if FW_ENABLE_TEXT_LOGGING
    this->textLogHistory = new History<TextLogEntry>(maxHistorySize);
#endif
    this->eventHistory_EventActivityLowThrottled = new History<EventEntry_EventActivityLowThrottled>(maxHistorySize);
    this->eventHistory_EventCommand = new History<EventEntry_EventCommand>(maxHistorySize);
    this->eventHistory_EventDiagnostic = new History<EventEntry_EventDiagnostic>(maxHistorySize);
    this->eventHistory_EventFatalThrottled = new History<EventEntry_EventFatalThrottled>(maxHistorySize);
    this->eventHistory_EventWarningHigh = new History<EventEntry_EventWarningHigh>(maxHistorySize);

    // Initialize telemetry histories
    this->tlmHistory_ChannelU32Format = new History<TlmEntry_ChannelU32Format>(maxHistorySize);
    this->tlmHistory_ChannelF32Format = new History<TlmEntry_ChannelF32Format>(maxHistorySize);
    this->tlmHistory_ChannelStringFormat = new History<TlmEntry_ChannelStringFormat>(maxHistorySize);
    this->tlmHistory_ChannelEnum = new History<TlmEntry_ChannelEnum>(maxHistorySize);
    this->tlmHistory_ChannelArrayFreq = new History<TlmEntry_ChannelArrayFreq>(maxHistorySize);
    this->tlmHistory_ChannelStructFreq = new History<TlmEntry_ChannelStructFreq>(maxHistorySize);
    this->tlmHistory_ChannelU32Limits = new History<TlmEntry_ChannelU32Limits>(maxHistorySize);
    this->tlmHistory_ChannelF32Limits = new History<TlmEntry_ChannelF32Limits>(maxHistorySize);
    this->tlmHistory_ChannelF64 = new History<TlmEntry_ChannelF64>(maxHistorySize);
    this->tlmHistory_ChannelU32OnChange = new History<TlmEntry_ChannelU32OnChange>(maxHistorySize);
    this->tlmHistory_ChannelEnumOnChange = new History<TlmEntry_ChannelEnumOnChange>(maxHistorySize);

    // Initialize data product histories
    this->productRequestHistory = new History<DpRequest>(maxHistorySize);
    this->productSendHistory = new History<DpSend>(maxHistorySize);

    // Clear history
    this->clearHistory();
  }

  ActiveTestTesterBase ::
    ~ActiveTestTesterBase()
  {
    // Destroy port histories
    delete this->fromPortHistory_typedAliasOut;
    delete this->fromPortHistory_typedAliasReturnOut;
    delete this->fromPortHistory_typedAliasReturnStringOut;
    delete this->fromPortHistory_typedOut;
    delete this->fromPortHistory_typedReturnOut;

    // Destroy command history
    delete this->cmdResponseHistory;

    // Destroy event histories
#if FW_ENABLE_TEXT_LOGGING
    delete this->textLogHistory;
#endif
    delete this->eventHistory_EventActivityLowThrottled;
    delete this->eventHistory_EventCommand;
    delete this->eventHistory_EventDiagnostic;
    delete this->eventHistory_EventFatalThrottled;
    delete this->eventHistory_EventWarningHigh;

    // Destroy telemetry histories
    delete this->tlmHistory_ChannelU32Format;
    delete this->tlmHistory_ChannelF32Format;
    delete this->tlmHistory_ChannelStringFormat;
    delete this->tlmHistory_ChannelEnum;
    delete this->tlmHistory_ChannelArrayFreq;
    delete this->tlmHistory_ChannelStructFreq;
    delete this->tlmHistory_ChannelU32Limits;
    delete this->tlmHistory_ChannelF32Limits;
    delete this->tlmHistory_ChannelF64;
    delete this->tlmHistory_ChannelU32OnChange;
    delete this->tlmHistory_ChannelEnumOnChange;

    // Destroy data product histories
    delete this->productRequestHistory;
    delete this->productSendHistory;
  }

  // ----------------------------------------------------------------------
  // Default handler implementations for typed from ports
  // You can override these implementation with more specific behavior
  // ----------------------------------------------------------------------

  void ActiveTestTesterBase ::
    from_noArgsOut_handler(FwIndexType portNum)
  {
    this->pushFromPortEntry_noArgsOut();
  }

  U32 ActiveTestTesterBase ::
    from_noArgsReturnOut_handler(FwIndexType portNum)
  {
    this->pushFromPortEntry_noArgsReturnOut();
    return 0;
  }

  Fw::String ActiveTestTesterBase ::
    from_noArgsStringReturnOut_handler(FwIndexType portNum)
  {
    this->pushFromPortEntry_noArgsStringReturnOut();
    return Fw::String("");
  }

  void ActiveTestTesterBase ::
    from_typedAliasOut_handler(
        FwIndexType portNum,
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AliasStruct& s
    )
  {
    this->pushFromPortEntry_typedAliasOut(u32, f32, b, str2, e, a, s);
  }

  AliasPrim2 ActiveTestTesterBase ::
    from_typedAliasReturnOut_handler(
        FwIndexType portNum,
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AliasStruct& s
    )
  {
    this->pushFromPortEntry_typedAliasReturnOut(u32, f32, b, str2, e, a, s);
    return 0.0f;
  }

  Fw::String ActiveTestTesterBase ::
    from_typedAliasReturnStringOut_handler(
        FwIndexType portNum,
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AnotherAliasStruct& s
    )
  {
    this->pushFromPortEntry_typedAliasReturnStringOut(u32, f32, b, str2, e, a, s);
    return Fw::String("");
  }

  void ActiveTestTesterBase ::
    from_typedOut_handler(
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str1,
        const E& e,
        const A& a,
        const S& s
    )
  {
    this->pushFromPortEntry_typedOut(u32, f32, b, str1, e, a, s);
  }

  F32 ActiveTestTesterBase ::
    from_typedReturnOut_handler(
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str2,
        const E& e,
        const A& a,
        const S& s
    )
  {
    this->pushFromPortEntry_typedReturnOut(u32, f32, b, str2, e, a, s);
    return 0.0f;
  }

  // ----------------------------------------------------------------------
  // Handler base-class functions for from ports
  // ----------------------------------------------------------------------

  void ActiveTestTesterBase ::
    from_noArgsOut_handlerBase(FwIndexType portNum)
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_noArgsOut()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->from_noArgsOut_handler(portNum);
  }

  U32 ActiveTestTesterBase ::
    from_noArgsReturnOut_handlerBase(FwIndexType portNum)
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_noArgsReturnOut()),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->from_noArgsReturnOut_handler(portNum);
  }

  Fw::String ActiveTestTesterBase ::
    from_noArgsStringReturnOut_handlerBase(FwIndexType portNum)
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_noArgsStringReturnOut()),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->from_noArgsStringReturnOut_handler(portNum);
  }

  void ActiveTestTesterBase ::
    from_typedAliasOut_handlerBase(
        FwIndexType portNum,
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AliasStruct& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_typedAliasOut()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->from_typedAliasOut_handler(
      portNum,
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  AliasPrim2 ActiveTestTesterBase ::
    from_typedAliasReturnOut_handlerBase(
        FwIndexType portNum,
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AliasStruct& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_typedAliasReturnOut()),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->from_typedAliasReturnOut_handler(
      portNum,
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  Fw::String ActiveTestTesterBase ::
    from_typedAliasReturnStringOut_handlerBase(
        FwIndexType portNum,
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AnotherAliasStruct& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_typedAliasReturnStringOut()),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->from_typedAliasReturnStringOut_handler(
      portNum,
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  void ActiveTestTesterBase ::
    from_typedOut_handlerBase(
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str1,
        const E& e,
        const A& a,
        const S& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_typedOut()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->from_typedOut_handler(
      portNum,
      u32,
      f32,
      b,
      str1,
      e,
      a,
      s
    );
  }

  F32 ActiveTestTesterBase ::
    from_typedReturnOut_handlerBase(
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str2,
        const E& e,
        const A& a,
        const S& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_from_typedReturnOut()),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->from_typedReturnOut_handler(
      portNum,
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  // ----------------------------------------------------------------------
  // Invocation functions for to ports
  // ----------------------------------------------------------------------

  void ActiveTestTesterBase ::
    invoke_to_aliasTypedAsync(
        FwIndexType portNum,
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AliasStruct& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_aliasTypedAsync()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_aliasTypedAsync[portNum].invoke(
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  Fw::String ActiveTestTesterBase ::
    invoke_to_noArgsAliasStringReturnSync(FwIndexType portNum)
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsAliasStringReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->m_to_noArgsAliasStringReturnSync[portNum].invoke();
  }

  void ActiveTestTesterBase ::
    invoke_to_noArgsAsync(FwIndexType portNum)
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsAsync()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_noArgsAsync[portNum].invoke();
  }

  void ActiveTestTesterBase ::
    invoke_to_noArgsGuarded(FwIndexType portNum)
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_noArgsGuarded[portNum].invoke();
  }

  U32 ActiveTestTesterBase ::
    invoke_to_noArgsReturnGuarded(FwIndexType portNum)
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsReturnGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->m_to_noArgsReturnGuarded[portNum].invoke();
  }

  U32 ActiveTestTesterBase ::
    invoke_to_noArgsReturnSync(FwIndexType portNum)
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->m_to_noArgsReturnSync[portNum].invoke();
  }

  Fw::String ActiveTestTesterBase ::
    invoke_to_noArgsStringReturnSync(FwIndexType portNum)
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsStringReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->m_to_noArgsStringReturnSync[portNum].invoke();
  }

  void ActiveTestTesterBase ::
    invoke_to_noArgsSync(FwIndexType portNum)
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsSync()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_noArgsSync[portNum].invoke();
  }

  void ActiveTestTesterBase ::
    invoke_to_typedAliasGuarded(
        FwIndexType portNum,
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AliasStruct& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAliasGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_typedAliasGuarded[portNum].invoke(
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  AliasPrim2 ActiveTestTesterBase ::
    invoke_to_typedAliasReturnSync(
        FwIndexType portNum,
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AliasStruct& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAliasReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->m_to_typedAliasReturnSync[portNum].invoke(
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  Fw::String ActiveTestTesterBase ::
    invoke_to_typedAliasStringReturnSync(
        FwIndexType portNum,
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AnotherAliasStruct& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAliasStringReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->m_to_typedAliasStringReturnSync[portNum].invoke(
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  void ActiveTestTesterBase ::
    invoke_to_typedAsync(
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str1,
        const E& e,
        const A& a,
        const S& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAsync()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_typedAsync[portNum].invoke(
      u32,
      f32,
      b,
      str1,
      e,
      a,
      s
    );
  }

  void ActiveTestTesterBase ::
    invoke_to_typedAsyncAssert(
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str1,
        const E& e,
        const A& a,
        const S& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAsyncAssert()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_typedAsyncAssert[portNum].invoke(
      u32,
      f32,
      b,
      str1,
      e,
      a,
      s
    );
  }

  void ActiveTestTesterBase ::
    invoke_to_typedAsyncBlockPriority(
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str1,
        const E& e,
        const A& a,
        const S& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAsyncBlockPriority()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_typedAsyncBlockPriority[portNum].invoke(
      u32,
      f32,
      b,
      str1,
      e,
      a,
      s
    );
  }

  void ActiveTestTesterBase ::
    invoke_to_typedAsyncDropPriority(
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str1,
        const E& e,
        const A& a,
        const S& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAsyncDropPriority()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_typedAsyncDropPriority[portNum].invoke(
      u32,
      f32,
      b,
      str1,
      e,
      a,
      s
    );
  }

  void ActiveTestTesterBase ::
    invoke_to_typedGuarded(
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str1,
        const E& e,
        const A& a,
        const S& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_typedGuarded[portNum].invoke(
      u32,
      f32,
      b,
      str1,
      e,
      a,
      s
    );
  }

  F32 ActiveTestTesterBase ::
    invoke_to_typedReturnGuarded(
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str2,
        const E& e,
        const A& a,
        const S& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedReturnGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->m_to_typedReturnGuarded[portNum].invoke(
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  F32 ActiveTestTesterBase ::
    invoke_to_typedReturnSync(
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str2,
        const E& e,
        const A& a,
        const S& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->m_to_typedReturnSync[portNum].invoke(
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  void ActiveTestTesterBase ::
    invoke_to_typedSync(
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str1,
        const E& e,
        const A& a,
        const S& s
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedSync()),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_typedSync[portNum].invoke(
      u32,
      f32,
      b,
      str1,
      e,
      a,
      s
    );
  }

  // ----------------------------------------------------------------------
  // Getters for port counts
  // ----------------------------------------------------------------------

  FwIndexType ActiveTestTesterBase ::
    getNum_to_cmdIn() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_cmdIn));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_productRecvIn() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_productRecvIn));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_aliasTypedAsync() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_aliasTypedAsync));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_noArgsAliasStringReturnSync() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsAliasStringReturnSync));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_noArgsAsync() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsAsync));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_noArgsGuarded() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsGuarded));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_noArgsReturnGuarded() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsReturnGuarded));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_noArgsReturnSync() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsReturnSync));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_noArgsStringReturnSync() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsStringReturnSync));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_noArgsSync() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsSync));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_typedAliasGuarded() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAliasGuarded));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_typedAliasReturnSync() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAliasReturnSync));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_typedAliasStringReturnSync() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAliasStringReturnSync));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_typedAsync() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsync));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_typedAsyncAssert() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsyncAssert));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_typedAsyncBlockPriority() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsyncBlockPriority));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_typedAsyncDropPriority() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsyncDropPriority));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_typedGuarded() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedGuarded));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_typedReturnGuarded() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedReturnGuarded));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_typedReturnSync() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedReturnSync));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_to_typedSync() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedSync));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_cmdRegOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_cmdRegOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_cmdResponseOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_cmdResponseOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_eventOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_eventOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_prmGetOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_prmGetOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_prmSetOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_prmSetOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_productRequestOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_productRequestOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_productSendOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_productSendOut));
  }

#if FW_ENABLE_TEXT_LOGGING == 1

  FwIndexType ActiveTestTesterBase ::
    getNum_from_textEventOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_textEventOut));
  }

#endif

  FwIndexType ActiveTestTesterBase ::
    getNum_from_timeGetOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_timeGetOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_tlmOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_tlmOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_noArgsOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_noArgsOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_noArgsReturnOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_noArgsReturnOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_noArgsStringReturnOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_noArgsStringReturnOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_typedAliasOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedAliasOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_typedAliasReturnOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedAliasReturnOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_typedAliasReturnStringOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedAliasReturnStringOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_typedOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedOut));
  }

  FwIndexType ActiveTestTesterBase ::
    getNum_from_typedReturnOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedReturnOut));
  }

  // ----------------------------------------------------------------------
  // Connection status queries for to ports
  // ----------------------------------------------------------------------

  bool ActiveTestTesterBase ::
    isConnected_to_cmdIn(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_cmdIn()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_cmdIn[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_productRecvIn(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_productRecvIn()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_productRecvIn[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_aliasTypedAsync(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_aliasTypedAsync()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_aliasTypedAsync[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_noArgsAliasStringReturnSync(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsAliasStringReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_noArgsAliasStringReturnSync[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_noArgsAsync(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsAsync()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_noArgsAsync[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_noArgsGuarded(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_noArgsGuarded[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_noArgsReturnGuarded(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsReturnGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_noArgsReturnGuarded[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_noArgsReturnSync(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_noArgsReturnSync[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_noArgsStringReturnSync(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsStringReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_noArgsStringReturnSync[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_noArgsSync(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_noArgsSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_noArgsSync[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_typedAliasGuarded(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAliasGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_typedAliasGuarded[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_typedAliasReturnSync(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAliasReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_typedAliasReturnSync[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_typedAliasStringReturnSync(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAliasStringReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_typedAliasStringReturnSync[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_typedAsync(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAsync()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_typedAsync[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_typedAsyncAssert(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAsyncAssert()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_typedAsyncAssert[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_typedAsyncBlockPriority(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAsyncBlockPriority()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_typedAsyncBlockPriority[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_typedAsyncDropPriority(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedAsyncDropPriority()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_typedAsyncDropPriority[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_typedGuarded(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_typedGuarded[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_typedReturnGuarded(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedReturnGuarded()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_typedReturnGuarded[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_typedReturnSync(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedReturnSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_typedReturnSync[portNum].isConnected();
  }

  bool ActiveTestTesterBase ::
    isConnected_to_typedSync(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_to_typedSync()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_typedSync[portNum].isConnected();
  }

  // ----------------------------------------------------------------------
  // Functions for testing commands
  // ----------------------------------------------------------------------

  void ActiveTestTesterBase ::
    cmdResponseIn(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdResponse response
    )
  {
    CmdResponse e = { opCode, cmdSeq, response };
    this->cmdResponseHistory->push_back(e);
  }

  void ActiveTestTesterBase ::
    sendRawCmd(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& buf
    )
  {
    const U32 idBase = this->getIdBase();
    FwOpcodeType _opcode = opCode + idBase;
    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_SYNC(
        const FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer buf;

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_SYNC + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_SYNC_PRIMITIVE(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        U32 u32,
        F32 f32,
        bool b
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = buf.serialize(u32);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = buf.serialize(f32);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = buf.serialize(b);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_SYNC_PRIMITIVE + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_SYNC_STRING(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        const Fw::StringBase& str1,
        const Fw::StringBase& str2
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = str1.serialize(buf, FW_CMD_STRING_MAX_SIZE);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = str2.serialize(buf, FW_CMD_STRING_MAX_SIZE);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_SYNC_STRING + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_SYNC_ENUM(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        E e
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = buf.serialize(e);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_SYNC_ENUM + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_SYNC_ARRAY(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        A a
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = buf.serialize(a);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_SYNC_ARRAY + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_SYNC_STRUCT(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        S s
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = buf.serialize(s);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_SYNC_STRUCT + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_GUARDED(
        const FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer buf;

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_GUARDED + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_GUARDED_PRIMITIVE(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        U32 u32,
        F32 f32,
        bool b
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = buf.serialize(u32);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = buf.serialize(f32);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = buf.serialize(b);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_GUARDED_PRIMITIVE + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_GUARDED_STRING(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        const Fw::StringBase& str1,
        const Fw::StringBase& str2
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = str1.serialize(buf, FW_CMD_STRING_MAX_SIZE);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = str2.serialize(buf, FW_CMD_STRING_MAX_SIZE);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_GUARDED_STRING + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_GUARDED_ENUM(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        E e
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = buf.serialize(e);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_GUARDED_ENUM + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_GUARDED_ARRAY(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        A a
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = buf.serialize(a);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_GUARDED_ARRAY + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_GUARDED_STRUCT(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        S s
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = buf.serialize(s);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_GUARDED_STRUCT + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_ASYNC(
        const FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer buf;

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_ASYNC + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_PRIORITY(
        const FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer buf;

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_PRIORITY + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_PARAMS_PRIORITY(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        U32 u32
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = buf.serialize(u32);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_PARAMS_PRIORITY + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_DROP(
        const FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer buf;

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_DROP + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void ActiveTestTesterBase ::
    sendCmd_CMD_PARAMS_PRIORITY_DROP(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        U32 u32
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = buf.serialize(u32);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = ActiveTestComponentBase::OPCODE_CMD_PARAMS_PRIORITY_DROP + idBase;

    if (this->m_to_cmdIn[0].isConnected()) {
      this->m_to_cmdIn[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  // ----------------------------------------------------------------------
  // Functions for testing events
  // ----------------------------------------------------------------------

  void ActiveTestTesterBase ::
    dispatchEvents(
        FwEventIdType id,
        const Fw::Time& timeTag,
        const Fw::LogSeverity severity,
        Fw::LogBuffer& args
    )
  {
    args.resetDeser();

    const U32 idBase = this->getIdBase();
    FW_ASSERT(
      id >= idBase,
      static_cast<FwAssertArgType>(id),
      static_cast<FwAssertArgType>(idBase)
    );

    switch (id - idBase) {
      case ActiveTestComponentBase::EVENTID_EVENTACTIVITYHIGH: {
#if FW_AMPCS_COMPATIBLE
        // For AMPCS, decode zero arguments
        Fw::SerializeStatus _zero_status = Fw::FW_SERIALIZE_OK;
        U8 _noArgs;
        _zero_status = args.deserialize(_noArgs);
        FW_ASSERT(
          _zero_status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_zero_status)
        );
#endif
        this->logIn_ACTIVITY_HI_EventActivityHigh();
        break;
      }

      case ActiveTestComponentBase::EVENTID_EVENTACTIVITYLOWTHROTTLED: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(
          _numArgs == 3,
          static_cast<FwAssertArgType>(_numArgs),
          static_cast<FwAssertArgType>(3)
        );
#endif

        U32 _event_arg_u32;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(
            _argSize == sizeof(U32),
            static_cast<FwAssertArgType>(_argSize),
            static_cast<FwAssertArgType>(sizeof(U32))
          );
        }
#endif
        _status = args.deserialize(_event_arg_u32);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        F32 _event_arg_f32;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(
            _argSize == sizeof(F32),
            static_cast<FwAssertArgType>(_argSize),
            static_cast<FwAssertArgType>(sizeof(F32))
          );
        }
#endif
        _status = args.deserialize(_event_arg_f32);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        bool _event_arg_b;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(
            _argSize == sizeof(U8),
            static_cast<FwAssertArgType>(_argSize),
            static_cast<FwAssertArgType>(sizeof(U8))
          );
        }
#endif
        _status = args.deserialize(_event_arg_b);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_ACTIVITY_LO_EventActivityLowThrottled(_event_arg_u32, _event_arg_f32, _event_arg_b);
        break;
      }

      case ActiveTestComponentBase::EVENTID_EVENTCOMMAND: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(
          _numArgs == 2,
          static_cast<FwAssertArgType>(_numArgs),
          static_cast<FwAssertArgType>(2)
        );
#endif

        Fw::LogStringArg _event_arg_str1;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(
            _argSize == Fw::LogStringArg::SERIALIZED_SIZE,
            static_cast<FwAssertArgType>(_argSize),
            static_cast<FwAssertArgType>(Fw::LogStringArg::SERIALIZED_SIZE)
          );
        }
#endif
        _status = args.deserialize(_event_arg_str1);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        Fw::LogStringArg _event_arg_str2;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(
            _argSize == Fw::LogStringArg::SERIALIZED_SIZE,
            static_cast<FwAssertArgType>(_argSize),
            static_cast<FwAssertArgType>(Fw::LogStringArg::SERIALIZED_SIZE)
          );
        }
#endif
        _status = args.deserialize(_event_arg_str2);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_COMMAND_EventCommand(_event_arg_str1, _event_arg_str2);
        break;
      }

      case ActiveTestComponentBase::EVENTID_EVENTDIAGNOSTIC: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(
          _numArgs == 1,
          static_cast<FwAssertArgType>(_numArgs),
          static_cast<FwAssertArgType>(1)
        );
#endif

        E _event_arg_e;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(
            _argSize == E::SERIALIZED_SIZE,
            static_cast<FwAssertArgType>(_argSize),
            static_cast<FwAssertArgType>(E::SERIALIZED_SIZE)
          );
        }
#endif
        _status = args.deserialize(_event_arg_e);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_DIAGNOSTIC_EventDiagnostic(_event_arg_e);
        break;
      }

      case ActiveTestComponentBase::EVENTID_EVENTFATALTHROTTLED: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(
          _numArgs == 1 + 1,
          static_cast<FwAssertArgType>(_numArgs),
          static_cast<FwAssertArgType>(1 + 1)
        );

        // For FATAL, there is a stack size of 4 and a dummy entry
        U8 stackArgLen;
        _status = args.deserialize(stackArgLen);
        FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          stackArgLen == 4,
          static_cast<FwAssertArgType>(stackArgLen)
        );

        U32 dummyStackArg;
        _status = args.deserialize(dummyStackArg);
        FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          dummyStackArg == 0,
          static_cast<FwAssertArgType>(dummyStackArg)
        );
#endif

        A _event_arg_a;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(
            _argSize == A::SERIALIZED_SIZE,
            static_cast<FwAssertArgType>(_argSize),
            static_cast<FwAssertArgType>(A::SERIALIZED_SIZE)
          );
        }
#endif
        _status = args.deserialize(_event_arg_a);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_FATAL_EventFatalThrottled(_event_arg_a);
        break;
      }

      case ActiveTestComponentBase::EVENTID_EVENTWARNINGHIGH: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(
          _numArgs == 1,
          static_cast<FwAssertArgType>(_numArgs),
          static_cast<FwAssertArgType>(1)
        );
#endif

        S _event_arg_s;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(
            _argSize == S::SERIALIZED_SIZE,
            static_cast<FwAssertArgType>(_argSize),
            static_cast<FwAssertArgType>(S::SERIALIZED_SIZE)
          );
        }
#endif
        _status = args.deserialize(_event_arg_s);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_WARNING_HI_EventWarningHigh(_event_arg_s);
        break;
      }

      case ActiveTestComponentBase::EVENTID_EVENTWARNINGLOWTHROTTLED: {
#if FW_AMPCS_COMPATIBLE
        // For AMPCS, decode zero arguments
        Fw::SerializeStatus _zero_status = Fw::FW_SERIALIZE_OK;
        U8 _noArgs;
        _zero_status = args.deserialize(_noArgs);
        FW_ASSERT(
          _zero_status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_zero_status)
        );
#endif
        this->logIn_WARNING_LO_EventWarningLowThrottled();
        break;
      }

      default: {
        FW_ASSERT(0, static_cast<FwAssertArgType>(id));
        break;
      }
    }
  }

#if FW_ENABLE_TEXT_LOGGING

  void ActiveTestTesterBase ::
    textLogIn(
        FwEventIdType id,
        const Fw::Time& timeTag,
        const Fw::LogSeverity severity,
        const Fw::TextLogString& text
    )
  {
    TextLogEntry e = { id, timeTag, severity, text };
    textLogHistory->push_back(e);
  }

#endif

  void ActiveTestTesterBase ::
    logIn_ACTIVITY_HI_EventActivityHigh()
  {
    this->eventsSize_EventActivityHigh++;
    this->eventsSize++;
  }

  void ActiveTestTesterBase ::
    logIn_ACTIVITY_LO_EventActivityLowThrottled(
        U32 u32,
        F32 f32,
        bool b
    )
  {
    EventEntry_EventActivityLowThrottled _e = {
      u32,
      f32,
      b
    };
    eventHistory_EventActivityLowThrottled->push_back(_e);
    this->eventsSize++;
  }

  void ActiveTestTesterBase ::
    logIn_COMMAND_EventCommand(
        const Fw::StringBase& str1,
        const Fw::StringBase& str2
    )
  {
    EventEntry_EventCommand _e = {
      str1,
      str2
    };
    eventHistory_EventCommand->push_back(_e);
    this->eventsSize++;
  }

  void ActiveTestTesterBase ::
    logIn_DIAGNOSTIC_EventDiagnostic(E e)
  {
    EventEntry_EventDiagnostic _e = {
      e
    };
    eventHistory_EventDiagnostic->push_back(_e);
    this->eventsSize++;
  }

  void ActiveTestTesterBase ::
    logIn_FATAL_EventFatalThrottled(A a)
  {
    EventEntry_EventFatalThrottled _e = {
      a
    };
    eventHistory_EventFatalThrottled->push_back(_e);
    this->eventsSize++;
  }

  void ActiveTestTesterBase ::
    logIn_WARNING_HI_EventWarningHigh(S s)
  {
    EventEntry_EventWarningHigh _e = {
      s
    };
    eventHistory_EventWarningHigh->push_back(_e);
    this->eventsSize++;
  }

  void ActiveTestTesterBase ::
    logIn_WARNING_LO_EventWarningLowThrottled()
  {
    this->eventsSize_EventWarningLowThrottled++;
    this->eventsSize++;
  }

  // ----------------------------------------------------------------------
  // Functions for testing telemetry
  // ----------------------------------------------------------------------

  void ActiveTestTesterBase ::
    dispatchTlm(
        FwChanIdType id,
        const Fw::Time& timeTag,
        Fw::TlmBuffer& val
    )
  {
    val.resetDeser();

    const U32 idBase = this->getIdBase();
    FW_ASSERT(
      id >= idBase,
      static_cast<FwAssertArgType>(id),
      static_cast<FwAssertArgType>(idBase)
    );

    switch (id - idBase) {
      case ActiveTestComponentBase::CHANNELID_CHANNELU32FORMAT: {
        U32 arg;
        const Fw::SerializeStatus _status = val.deserialize(arg);

        if (_status != Fw::FW_SERIALIZE_OK) {
          printf("Error deserializing ChannelU32Format: %d\n", _status);
          return;
        }

        this->tlmInput_ChannelU32Format(timeTag, arg);
        break;
      }

      case ActiveTestComponentBase::CHANNELID_CHANNELF32FORMAT: {
        F32 arg;
        const Fw::SerializeStatus _status = val.deserialize(arg);

        if (_status != Fw::FW_SERIALIZE_OK) {
          printf("Error deserializing ChannelF32Format: %d\n", _status);
          return;
        }

        this->tlmInput_ChannelF32Format(timeTag, arg);
        break;
      }

      case ActiveTestComponentBase::CHANNELID_CHANNELSTRINGFORMAT: {
        Fw::TlmString arg;
        const Fw::SerializeStatus _status = val.deserialize(arg);

        if (_status != Fw::FW_SERIALIZE_OK) {
          printf("Error deserializing ChannelStringFormat: %d\n", _status);
          return;
        }

        this->tlmInput_ChannelStringFormat(timeTag, arg);
        break;
      }

      case ActiveTestComponentBase::CHANNELID_CHANNELENUM: {
        E arg;
        const Fw::SerializeStatus _status = val.deserialize(arg);

        if (_status != Fw::FW_SERIALIZE_OK) {
          printf("Error deserializing ChannelEnum: %d\n", _status);
          return;
        }

        this->tlmInput_ChannelEnum(timeTag, arg);
        break;
      }

      case ActiveTestComponentBase::CHANNELID_CHANNELARRAYFREQ: {
        A arg;
        const Fw::SerializeStatus _status = val.deserialize(arg);

        if (_status != Fw::FW_SERIALIZE_OK) {
          printf("Error deserializing ChannelArrayFreq: %d\n", _status);
          return;
        }

        this->tlmInput_ChannelArrayFreq(timeTag, arg);
        break;
      }

      case ActiveTestComponentBase::CHANNELID_CHANNELSTRUCTFREQ: {
        S arg;
        const Fw::SerializeStatus _status = val.deserialize(arg);

        if (_status != Fw::FW_SERIALIZE_OK) {
          printf("Error deserializing ChannelStructFreq: %d\n", _status);
          return;
        }

        this->tlmInput_ChannelStructFreq(timeTag, arg);
        break;
      }

      case ActiveTestComponentBase::CHANNELID_CHANNELU32LIMITS: {
        U32 arg;
        const Fw::SerializeStatus _status = val.deserialize(arg);

        if (_status != Fw::FW_SERIALIZE_OK) {
          printf("Error deserializing ChannelU32Limits: %d\n", _status);
          return;
        }

        this->tlmInput_ChannelU32Limits(timeTag, arg);
        break;
      }

      case ActiveTestComponentBase::CHANNELID_CHANNELF32LIMITS: {
        F32 arg;
        const Fw::SerializeStatus _status = val.deserialize(arg);

        if (_status != Fw::FW_SERIALIZE_OK) {
          printf("Error deserializing ChannelF32Limits: %d\n", _status);
          return;
        }

        this->tlmInput_ChannelF32Limits(timeTag, arg);
        break;
      }

      case ActiveTestComponentBase::CHANNELID_CHANNELF64: {
        F64 arg;
        const Fw::SerializeStatus _status = val.deserialize(arg);

        if (_status != Fw::FW_SERIALIZE_OK) {
          printf("Error deserializing ChannelF64: %d\n", _status);
          return;
        }

        this->tlmInput_ChannelF64(timeTag, arg);
        break;
      }

      case ActiveTestComponentBase::CHANNELID_CHANNELU32ONCHANGE: {
        U32 arg;
        const Fw::SerializeStatus _status = val.deserialize(arg);

        if (_status != Fw::FW_SERIALIZE_OK) {
          printf("Error deserializing ChannelU32OnChange: %d\n", _status);
          return;
        }

        this->tlmInput_ChannelU32OnChange(timeTag, arg);
        break;
      }

      case ActiveTestComponentBase::CHANNELID_CHANNELENUMONCHANGE: {
        E arg;
        const Fw::SerializeStatus _status = val.deserialize(arg);

        if (_status != Fw::FW_SERIALIZE_OK) {
          printf("Error deserializing ChannelEnumOnChange: %d\n", _status);
          return;
        }

        this->tlmInput_ChannelEnumOnChange(timeTag, arg);
        break;
      }

      default: {
        FW_ASSERT(0, static_cast<FwAssertArgType>(id));
        break;
      }
    }
  }

  void ActiveTestTesterBase ::
    tlmInput_ChannelU32Format(
        const Fw::Time& timeTag,
        const U32 val
    )
  {
    TlmEntry_ChannelU32Format e = { timeTag, val };
    this->tlmHistory_ChannelU32Format->push_back(e);
    this->tlmSize++;
  }

  void ActiveTestTesterBase ::
    tlmInput_ChannelF32Format(
        const Fw::Time& timeTag,
        const F32 val
    )
  {
    TlmEntry_ChannelF32Format e = { timeTag, val };
    this->tlmHistory_ChannelF32Format->push_back(e);
    this->tlmSize++;
  }

  void ActiveTestTesterBase ::
    tlmInput_ChannelStringFormat(
        const Fw::Time& timeTag,
        const Fw::StringBase& val
    )
  {
    TlmEntry_ChannelStringFormat e = { timeTag, val };
    this->tlmHistory_ChannelStringFormat->push_back(e);
    this->tlmSize++;
  }

  void ActiveTestTesterBase ::
    tlmInput_ChannelEnum(
        const Fw::Time& timeTag,
        const E& val
    )
  {
    TlmEntry_ChannelEnum e = { timeTag, val };
    this->tlmHistory_ChannelEnum->push_back(e);
    this->tlmSize++;
  }

  void ActiveTestTesterBase ::
    tlmInput_ChannelArrayFreq(
        const Fw::Time& timeTag,
        const A& val
    )
  {
    TlmEntry_ChannelArrayFreq e = { timeTag, val };
    this->tlmHistory_ChannelArrayFreq->push_back(e);
    this->tlmSize++;
  }

  void ActiveTestTesterBase ::
    tlmInput_ChannelStructFreq(
        const Fw::Time& timeTag,
        const S& val
    )
  {
    TlmEntry_ChannelStructFreq e = { timeTag, val };
    this->tlmHistory_ChannelStructFreq->push_back(e);
    this->tlmSize++;
  }

  void ActiveTestTesterBase ::
    tlmInput_ChannelU32Limits(
        const Fw::Time& timeTag,
        const U32 val
    )
  {
    TlmEntry_ChannelU32Limits e = { timeTag, val };
    this->tlmHistory_ChannelU32Limits->push_back(e);
    this->tlmSize++;
  }

  void ActiveTestTesterBase ::
    tlmInput_ChannelF32Limits(
        const Fw::Time& timeTag,
        const F32 val
    )
  {
    TlmEntry_ChannelF32Limits e = { timeTag, val };
    this->tlmHistory_ChannelF32Limits->push_back(e);
    this->tlmSize++;
  }

  void ActiveTestTesterBase ::
    tlmInput_ChannelF64(
        const Fw::Time& timeTag,
        const F64 val
    )
  {
    TlmEntry_ChannelF64 e = { timeTag, val };
    this->tlmHistory_ChannelF64->push_back(e);
    this->tlmSize++;
  }

  void ActiveTestTesterBase ::
    tlmInput_ChannelU32OnChange(
        const Fw::Time& timeTag,
        const U32 val
    )
  {
    TlmEntry_ChannelU32OnChange e = { timeTag, val };
    this->tlmHistory_ChannelU32OnChange->push_back(e);
    this->tlmSize++;
  }

  void ActiveTestTesterBase ::
    tlmInput_ChannelEnumOnChange(
        const Fw::Time& timeTag,
        const E& val
    )
  {
    TlmEntry_ChannelEnumOnChange e = { timeTag, val };
    this->tlmHistory_ChannelEnumOnChange->push_back(e);
    this->tlmSize++;
  }

  // ----------------------------------------------------------------------
  // Functions to test parameters
  // ----------------------------------------------------------------------

  void ActiveTestTesterBase ::
    paramSet_ParamU32(
        const U32& val,
        Fw::ParamValid valid
    )
  {
    this->m_param_ParamU32 = val;
    this->m_param_ParamU32_valid = valid;
  }

  void ActiveTestTesterBase ::
    paramSend_ParamU32(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    // Build command for parameter set
    Fw::CmdArgBuffer args;
    FW_ASSERT(
      args.serialize(this->m_param_ParamU32) == Fw::FW_SERIALIZE_OK
    );

    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode =  ActiveTestComponentBase::OPCODE_PARAMU32_SET + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSave_ParamU32(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer args;
    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode = ActiveTestComponentBase::OPCODE_PARAMU32_SAVE + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSet_ParamF64(
        const F64& val,
        Fw::ParamValid valid
    )
  {
    this->m_param_ParamF64 = val;
    this->m_param_ParamF64_valid = valid;
  }

  void ActiveTestTesterBase ::
    paramSend_ParamF64(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    // Build command for parameter set
    Fw::CmdArgBuffer args;
    FW_ASSERT(
      args.serialize(this->m_param_ParamF64) == Fw::FW_SERIALIZE_OK
    );

    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode =  ActiveTestComponentBase::OPCODE_PARAMF64_SET + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSave_ParamF64(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer args;
    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode = ActiveTestComponentBase::OPCODE_PARAMF64_SAVE + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSet_ParamString(
        const Fw::StringBase& val,
        Fw::ParamValid valid
    )
  {
    this->m_param_ParamString = val;
    this->m_param_ParamString_valid = valid;
  }

  void ActiveTestTesterBase ::
    paramSend_ParamString(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    // Build command for parameter set
    Fw::CmdArgBuffer args;
    FW_ASSERT(
      args.serialize(this->m_param_ParamString) == Fw::FW_SERIALIZE_OK
    );

    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode =  ActiveTestComponentBase::OPCODE_PARAMSTRING_SET + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSave_ParamString(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer args;
    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode = ActiveTestComponentBase::OPCODE_PARAMSTRING_SAVE + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSet_ParamEnum(
        const E& val,
        Fw::ParamValid valid
    )
  {
    this->m_param_ParamEnum = val;
    this->m_param_ParamEnum_valid = valid;
  }

  void ActiveTestTesterBase ::
    paramSend_ParamEnum(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    // Build command for parameter set
    Fw::CmdArgBuffer args;
    FW_ASSERT(
      args.serialize(this->m_param_ParamEnum) == Fw::FW_SERIALIZE_OK
    );

    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode =  ActiveTestComponentBase::OPCODE_PARAMENUM_SET + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSave_ParamEnum(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer args;
    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode = ActiveTestComponentBase::OPCODE_PARAMENUM_SAVE + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSet_ParamArray(
        const A& val,
        Fw::ParamValid valid
    )
  {
    this->m_param_ParamArray = val;
    this->m_param_ParamArray_valid = valid;
  }

  void ActiveTestTesterBase ::
    paramSend_ParamArray(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    // Build command for parameter set
    Fw::CmdArgBuffer args;
    FW_ASSERT(
      args.serialize(this->m_param_ParamArray) == Fw::FW_SERIALIZE_OK
    );

    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode =  ActiveTestComponentBase::OPCODE_PARAMARRAY_SET + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSave_ParamArray(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer args;
    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode = ActiveTestComponentBase::OPCODE_PARAMARRAY_SAVE + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSet_ParamStruct(
        const S& val,
        Fw::ParamValid valid
    )
  {
    this->m_param_ParamStruct = val;
    this->m_param_ParamStruct_valid = valid;
  }

  void ActiveTestTesterBase ::
    paramSend_ParamStruct(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    // Build command for parameter set
    Fw::CmdArgBuffer args;
    FW_ASSERT(
      args.serialize(this->m_param_ParamStruct) == Fw::FW_SERIALIZE_OK
    );

    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode =  ActiveTestComponentBase::OPCODE_PARAMSTRUCT_SET + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSave_ParamStruct(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer args;
    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode = ActiveTestComponentBase::OPCODE_PARAMSTRUCT_SAVE + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSet_ParamI32Ext(
        const I32& val,
        Fw::ParamValid valid
    )
  {
    this->paramTesterDelegate.m_param_ParamI32Ext = val;
    this->paramTesterDelegate.m_param_ParamI32Ext_valid = valid;
  }

  void ActiveTestTesterBase ::
    paramSend_ParamI32Ext(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    // Build command for parameter set
    Fw::CmdArgBuffer args;
    FW_ASSERT(
      args.serialize(this->paramTesterDelegate.m_param_ParamI32Ext) == Fw::FW_SERIALIZE_OK
    );

    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode =  ActiveTestComponentBase::OPCODE_PARAMI32EXT_SET + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSave_ParamI32Ext(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer args;
    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode = ActiveTestComponentBase::OPCODE_PARAMI32EXT_SAVE + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSet_ParamF64Ext(
        const F64& val,
        Fw::ParamValid valid
    )
  {
    this->paramTesterDelegate.m_param_ParamF64Ext = val;
    this->paramTesterDelegate.m_param_ParamF64Ext_valid = valid;
  }

  void ActiveTestTesterBase ::
    paramSend_ParamF64Ext(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    // Build command for parameter set
    Fw::CmdArgBuffer args;
    FW_ASSERT(
      args.serialize(this->paramTesterDelegate.m_param_ParamF64Ext) == Fw::FW_SERIALIZE_OK
    );

    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode =  ActiveTestComponentBase::OPCODE_PARAMF64EXT_SET + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSave_ParamF64Ext(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer args;
    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode = ActiveTestComponentBase::OPCODE_PARAMF64EXT_SAVE + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSet_ParamStringExt(
        const Fw::StringBase& val,
        Fw::ParamValid valid
    )
  {
    this->paramTesterDelegate.m_param_ParamStringExt = val;
    this->paramTesterDelegate.m_param_ParamStringExt_valid = valid;
  }

  void ActiveTestTesterBase ::
    paramSend_ParamStringExt(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    // Build command for parameter set
    Fw::CmdArgBuffer args;
    FW_ASSERT(
      args.serialize(this->paramTesterDelegate.m_param_ParamStringExt) == Fw::FW_SERIALIZE_OK
    );

    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode =  ActiveTestComponentBase::OPCODE_PARAMSTRINGEXT_SET + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSave_ParamStringExt(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer args;
    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode = ActiveTestComponentBase::OPCODE_PARAMSTRINGEXT_SAVE + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSet_ParamEnumExt(
        const E& val,
        Fw::ParamValid valid
    )
  {
    this->paramTesterDelegate.m_param_ParamEnumExt = val;
    this->paramTesterDelegate.m_param_ParamEnumExt_valid = valid;
  }

  void ActiveTestTesterBase ::
    paramSend_ParamEnumExt(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    // Build command for parameter set
    Fw::CmdArgBuffer args;
    FW_ASSERT(
      args.serialize(this->paramTesterDelegate.m_param_ParamEnumExt) == Fw::FW_SERIALIZE_OK
    );

    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode =  ActiveTestComponentBase::OPCODE_PARAMENUMEXT_SET + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSave_ParamEnumExt(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer args;
    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode = ActiveTestComponentBase::OPCODE_PARAMENUMEXT_SAVE + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSet_ParamArrayExt(
        const A& val,
        Fw::ParamValid valid
    )
  {
    this->paramTesterDelegate.m_param_ParamArrayExt = val;
    this->paramTesterDelegate.m_param_ParamArrayExt_valid = valid;
  }

  void ActiveTestTesterBase ::
    paramSend_ParamArrayExt(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    // Build command for parameter set
    Fw::CmdArgBuffer args;
    FW_ASSERT(
      args.serialize(this->paramTesterDelegate.m_param_ParamArrayExt) == Fw::FW_SERIALIZE_OK
    );

    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode =  ActiveTestComponentBase::OPCODE_PARAMARRAYEXT_SET + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSave_ParamArrayExt(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer args;
    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode = ActiveTestComponentBase::OPCODE_PARAMARRAYEXT_SAVE + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSet_ParamStructExt(
        const S& val,
        Fw::ParamValid valid
    )
  {
    this->paramTesterDelegate.m_param_ParamStructExt = val;
    this->paramTesterDelegate.m_param_ParamStructExt_valid = valid;
  }

  void ActiveTestTesterBase ::
    paramSend_ParamStructExt(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    // Build command for parameter set
    Fw::CmdArgBuffer args;
    FW_ASSERT(
      args.serialize(this->paramTesterDelegate.m_param_ParamStructExt) == Fw::FW_SERIALIZE_OK
    );

    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode =  ActiveTestComponentBase::OPCODE_PARAMSTRUCTEXT_SET + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  void ActiveTestTesterBase ::
    paramSave_ParamStructExt(
        FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer args;
    const U32 idBase = this->getIdBase();
    FwOpcodeType _prmOpcode = ActiveTestComponentBase::OPCODE_PARAMSTRUCTEXT_SAVE + idBase;

    if (not this->m_to_cmdIn[0].isConnected()) {
      printf("Test Command Output port not connected!\n");
    }
    else {
      this->m_to_cmdIn[0].invoke(
        _prmOpcode,
        cmdSeq,
        args
      );
    }
  }

  // ----------------------------------------------------------------------
  // Functions to test time
  // ----------------------------------------------------------------------

  void ActiveTestTesterBase ::
    setTestTime(const Fw::Time& timeTag)
  {
    this->m_testTime = timeTag;
  }

  // ----------------------------------------------------------------------
  // Functions for testing data products
  // ----------------------------------------------------------------------

  void ActiveTestTesterBase ::
    pushProductRequestEntry(
        FwDpIdType id,
        FwSizeType dataSize
    )
  {
    DpRequest e = { id, dataSize };
    this->productRequestHistory->push_back(e);
  }

  void ActiveTestTesterBase ::
    productRequest_handler(
        FwDpIdType id,
        FwSizeType dataSize
    )
  {
    this->pushProductRequestEntry(id, dataSize);
  }

  void ActiveTestTesterBase ::
    sendProductResponse(
        FwDpIdType id,
        const Fw::Buffer& buffer,
        const Fw::Success& status
    )
  {
    FW_ASSERT(this->getNum_to_productRecvIn() > 0);
    FW_ASSERT(this->m_to_productRecvIn[0].isConnected());
    this->m_to_productRecvIn[0].invoke(id, buffer, status);
  }

  void ActiveTestTesterBase ::
    pushProductSendEntry(
        FwDpIdType id,
        const Fw::Buffer& buffer
    )
  {
    DpSend e = { id, buffer };
    this->productSendHistory->push_back(e);
  }

  void ActiveTestTesterBase ::
    productSend_handler(
        FwDpIdType id,
        const Fw::Buffer& buffer
    )
  {
    this->pushProductSendEntry(id, buffer);
  }

  // ----------------------------------------------------------------------
  // History functions
  // ----------------------------------------------------------------------

  void ActiveTestTesterBase ::
    clearHistory()
  {
    this->clearFromPortHistory();
    this->cmdResponseHistory->clear();
#if FW_ENABLE_TEXT_LOGGING
    this->textLogHistory->clear();
#endif
    this->clearEvents();
    this->clearTlm();
    this->productRequestHistory->clear();
    this->productSendHistory->clear();
  }

  void ActiveTestTesterBase ::
    clearFromPortHistory()
  {
    this->fromPortHistorySize = 0;
    this->fromPortHistorySize_noArgsOut = 0;
    this->fromPortHistorySize_noArgsReturnOut = 0;
    this->fromPortHistorySize_noArgsStringReturnOut = 0;
    this->fromPortHistory_typedAliasOut->clear();
    this->fromPortHistory_typedAliasReturnOut->clear();
    this->fromPortHistory_typedAliasReturnStringOut->clear();
    this->fromPortHistory_typedOut->clear();
    this->fromPortHistory_typedReturnOut->clear();
  }

  void ActiveTestTesterBase ::
    pushFromPortEntry_noArgsOut()
  {
    this->fromPortHistorySize_noArgsOut++;
    this->fromPortHistorySize++;
  }

  void ActiveTestTesterBase ::
    pushFromPortEntry_noArgsReturnOut()
  {
    this->fromPortHistorySize_noArgsReturnOut++;
    this->fromPortHistorySize++;
  }

  void ActiveTestTesterBase ::
    pushFromPortEntry_noArgsStringReturnOut()
  {
    this->fromPortHistorySize_noArgsStringReturnOut++;
    this->fromPortHistorySize++;
  }

  void ActiveTestTesterBase ::
    pushFromPortEntry_typedAliasOut(
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AliasStruct& s
    )
  {
    FromPortEntry_typedAliasOut _e;
    _e.u32 = u32;
    _e.f32 = f32;
    _e.b = b;
    _e.str2 = str2;
    _e.e = e;
    _e.a = a;
    _e.s = s;
    this->fromPortHistory_typedAliasOut->push_back(_e);
    this->fromPortHistorySize++;
  }

  void ActiveTestTesterBase ::
    pushFromPortEntry_typedAliasReturnOut(
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AliasStruct& s
    )
  {
    FromPortEntry_typedAliasReturnOut _e;
    _e.u32 = u32;
    _e.f32 = f32;
    _e.b = b;
    _e.str2 = str2;
    _e.e = e;
    _e.a = a;
    _e.s = s;
    this->fromPortHistory_typedAliasReturnOut->push_back(_e);
    this->fromPortHistorySize++;
  }

  void ActiveTestTesterBase ::
    pushFromPortEntry_typedAliasReturnStringOut(
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AnotherAliasStruct& s
    )
  {
    FromPortEntry_typedAliasReturnStringOut _e;
    _e.u32 = u32;
    _e.f32 = f32;
    _e.b = b;
    _e.str2 = str2;
    _e.e = e;
    _e.a = a;
    _e.s = s;
    this->fromPortHistory_typedAliasReturnStringOut->push_back(_e);
    this->fromPortHistorySize++;
  }

  void ActiveTestTesterBase ::
    pushFromPortEntry_typedOut(
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str1,
        const E& e,
        const A& a,
        const S& s
    )
  {
    FromPortEntry_typedOut _e;
    _e.u32 = u32;
    _e.f32 = f32;
    _e.b = b;
    _e.str1 = str1;
    _e.e = e;
    _e.a = a;
    _e.s = s;
    this->fromPortHistory_typedOut->push_back(_e);
    this->fromPortHistorySize++;
  }

  void ActiveTestTesterBase ::
    pushFromPortEntry_typedReturnOut(
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str2,
        const E& e,
        const A& a,
        const S& s
    )
  {
    FromPortEntry_typedReturnOut _e;
    _e.u32 = u32;
    _e.f32 = f32;
    _e.b = b;
    _e.str2 = str2;
    _e.e = e;
    _e.a = a;
    _e.s = s;
    this->fromPortHistory_typedReturnOut->push_back(_e);
    this->fromPortHistorySize++;
  }

  void ActiveTestTesterBase ::
    clearEvents()
  {
    this->eventsSize = 0;
    this->eventsSize_EventActivityHigh = 0;
    this->eventHistory_EventActivityLowThrottled->clear();
    this->eventHistory_EventCommand->clear();
    this->eventHistory_EventDiagnostic->clear();
    this->eventHistory_EventFatalThrottled->clear();
    this->eventHistory_EventWarningHigh->clear();
    this->eventsSize_EventWarningLowThrottled = 0;
  }

#if FW_ENABLE_TEXT_LOGGING

  void ActiveTestTesterBase ::
    printTextLogHistoryEntry(
        const TextLogEntry& e,
        FILE* file
    )
  {
    const char* severityString = "UNKNOWN";

    switch (e.severity.e) {
      case Fw::LogSeverity::FATAL:
        severityString = "FATAL";
        break;
      case Fw::LogSeverity::WARNING_HI:
        severityString = "WARNING_HI";
        break;
      case Fw::LogSeverity::WARNING_LO:
        severityString = "WARNING_LO";
        break;
      case Fw::LogSeverity::COMMAND:
        severityString = "COMMAND";
        break;
      case Fw::LogSeverity::ACTIVITY_HI:
        severityString = "ACTIVITY_HI";
        break;
      case Fw::LogSeverity::ACTIVITY_LO:
        severityString = "ACTIVITY_LO";
        break;
      case Fw::LogSeverity::DIAGNOSTIC:
       severityString = "DIAGNOSTIC";
        break;
      default:
        severityString = "SEVERITY ERROR";
        break;
    }

    fprintf(
      file,
      "EVENT: (%" PRI_FwEventIdType ") (%" PRI_FwTimeBaseStoreType ":%" PRIu32 ",%" PRIu32 ") %s: %s\n",
      e.id,
      static_cast<FwTimeBaseStoreType>(e.timeTag.getTimeBase()),
      e.timeTag.getSeconds(),
      e.timeTag.getUSeconds(),
      severityString,
      e.text.toChar()
    );
  }

  void ActiveTestTesterBase ::
    printTextLogHistory(FILE* const file)
  {
    for (U32 i = 0; i < this->textLogHistory->size(); i++) {
      this->printTextLogHistoryEntry(
        this->textLogHistory->at(i),
        file
      );
    }
  }

#endif

  void ActiveTestTesterBase ::
    clearTlm()
  {
    this->tlmSize = 0;
    this->tlmHistory_ChannelU32Format->clear();
    this->tlmHistory_ChannelF32Format->clear();
    this->tlmHistory_ChannelStringFormat->clear();
    this->tlmHistory_ChannelEnum->clear();
    this->tlmHistory_ChannelArrayFreq->clear();
    this->tlmHistory_ChannelStructFreq->clear();
    this->tlmHistory_ChannelU32Limits->clear();
    this->tlmHistory_ChannelF32Limits->clear();
    this->tlmHistory_ChannelF64->clear();
    this->tlmHistory_ChannelU32OnChange->clear();
    this->tlmHistory_ChannelEnumOnChange->clear();
  }

  // ----------------------------------------------------------------------
  // Dispatching helper functions
  // ----------------------------------------------------------------------

  ActiveTestComponentBase::MsgDispatchStatus ActiveTestTesterBase ::
    dispatchOne(ActiveTestComponentBase& component)
  {
        // Dispatch one message returning status
        return component.doDispatch();
  }

  ActiveTestComponentBase::MsgDispatchStatus ActiveTestTesterBase ::
    dispatchCurrentMessages(ActiveTestComponentBase& component)
  {
        // Dispatch all current messages unless ERROR or EXIT occur
        const FwSizeType currentMessageCount = component.m_queue.getMessagesAvailable();
        ActiveTestComponentBase::MsgDispatchStatus messageStatus = ActiveTestComponentBase::MsgDispatchStatus::MSG_DISPATCH_EMPTY;
        for (FwSizeType i = 0; i < currentMessageCount; i++) {
            messageStatus = component.doDispatch();
            if (messageStatus != ActiveTestComponentBase::MSG_DISPATCH_OK) {
                break;
            }
        }
        return messageStatus;
  }

  // ----------------------------------------------------------------------
  // Static functions for output ports
  // ----------------------------------------------------------------------

  void ActiveTestTesterBase ::
    from_cmdRegOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwOpcodeType opCode
    )
  {

  }

  void ActiveTestTesterBase ::
    from_cmdResponseOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        const Fw::CmdResponse& response
    )
  {
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    _testerBase->cmdResponseIn(opCode, cmdSeq, response);
  }

  void ActiveTestTesterBase ::
    from_eventOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwEventIdType id,
        Fw::Time& timeTag,
        const Fw::LogSeverity& severity,
        Fw::LogBuffer& args
    )
  {
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    _testerBase->dispatchEvents(id, timeTag, severity, args);
  }

  Fw::ParamValid ActiveTestTesterBase ::
    from_prmGetOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwPrmIdType id,
        Fw::ParamBuffer& val
    )
  {
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);

    Fw::SerializeStatus _status;

    Fw::ParamValid _ret = Fw::ParamValid::VALID;
    val.resetSer();

    const U32 idBase = _testerBase->getIdBase();
    FW_ASSERT(
      id >= idBase,
      static_cast<FwAssertArgType>(id),
      static_cast<FwAssertArgType>(idBase)
    );

    switch (id - idBase) {
      case ActiveTestComponentBase::PARAMID_PARAMU32: {
        _status = val.serialize(_testerBase->m_param_ParamU32);
        _ret = _testerBase->m_param_ParamU32_valid;
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMF64: {
        _status = val.serialize(_testerBase->m_param_ParamF64);
        _ret = _testerBase->m_param_ParamF64_valid;
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMSTRING: {
        _status = val.serialize(_testerBase->m_param_ParamString);
        _ret = _testerBase->m_param_ParamString_valid;
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMENUM: {
        _status = val.serialize(_testerBase->m_param_ParamEnum);
        _ret = _testerBase->m_param_ParamEnum_valid;
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMARRAY: {
        _status = val.serialize(_testerBase->m_param_ParamArray);
        _ret = _testerBase->m_param_ParamArray_valid;
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMSTRUCT: {
        _status = val.serialize(_testerBase->m_param_ParamStruct);
        _ret = _testerBase->m_param_ParamStruct_valid;
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMI32EXT: {
        _status = val.serialize(_testerBase->paramTesterDelegate.m_param_ParamI32Ext);
        _ret = _testerBase->paramTesterDelegate.m_param_ParamI32Ext_valid;
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMF64EXT: {
        _status = val.serialize(_testerBase->paramTesterDelegate.m_param_ParamF64Ext);
        _ret = _testerBase->paramTesterDelegate.m_param_ParamF64Ext_valid;
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMSTRINGEXT: {
        _status = val.serialize(_testerBase->paramTesterDelegate.m_param_ParamStringExt);
        _ret = _testerBase->paramTesterDelegate.m_param_ParamStringExt_valid;
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMENUMEXT: {
        _status = val.serialize(_testerBase->paramTesterDelegate.m_param_ParamEnumExt);
        _ret = _testerBase->paramTesterDelegate.m_param_ParamEnumExt_valid;
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMARRAYEXT: {
        _status = val.serialize(_testerBase->paramTesterDelegate.m_param_ParamArrayExt);
        _ret = _testerBase->paramTesterDelegate.m_param_ParamArrayExt_valid;
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMSTRUCTEXT: {
        _status = val.serialize(_testerBase->paramTesterDelegate.m_param_ParamStructExt);
        _ret = _testerBase->paramTesterDelegate.m_param_ParamStructExt_valid;
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        break;
      };

      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(id));
        break;
    }

    return _ret;
  }

  void ActiveTestTesterBase ::
    from_prmSetOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwPrmIdType id,
        Fw::ParamBuffer& val
    )
  {
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    Fw::SerializeStatus _status;

    const U32 idBase = _testerBase->getIdBase();
    FW_ASSERT(
      id >= idBase,
      static_cast<FwAssertArgType>(id),
      static_cast<FwAssertArgType>(idBase)
    );

    switch (id - idBase) {
      case ActiveTestComponentBase::PARAMID_PARAMU32: {
        U32 ParamU32Val;
        _status = val.deserialize(ParamU32Val);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          ParamU32Val ==
          _testerBase->m_param_ParamU32
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMF64: {
        F64 ParamF64Val;
        _status = val.deserialize(ParamF64Val);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          ParamF64Val ==
          _testerBase->m_param_ParamF64
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMSTRING: {
        Fw::ParamString ParamStringVal;
        _status = val.deserialize(ParamStringVal);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          ParamStringVal ==
          _testerBase->m_param_ParamString
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMENUM: {
        E ParamEnumVal;
        _status = val.deserialize(ParamEnumVal);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          ParamEnumVal ==
          _testerBase->m_param_ParamEnum
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMARRAY: {
        A ParamArrayVal;
        _status = val.deserialize(ParamArrayVal);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          ParamArrayVal ==
          _testerBase->m_param_ParamArray
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMSTRUCT: {
        S ParamStructVal;
        _status = val.deserialize(ParamStructVal);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          ParamStructVal ==
          _testerBase->m_param_ParamStruct
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMI32EXT: {
        I32 ParamI32ExtVal;
        _status = val.deserialize(ParamI32ExtVal);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          ParamI32ExtVal ==
          _testerBase->paramTesterDelegate.m_param_ParamI32Ext
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMF64EXT: {
        F64 ParamF64ExtVal;
        _status = val.deserialize(ParamF64ExtVal);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          ParamF64ExtVal ==
          _testerBase->paramTesterDelegate.m_param_ParamF64Ext
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMSTRINGEXT: {
        Fw::ParamString ParamStringExtVal;
        _status = val.deserialize(ParamStringExtVal);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          ParamStringExtVal ==
          _testerBase->paramTesterDelegate.m_param_ParamStringExt
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMENUMEXT: {
        E ParamEnumExtVal;
        _status = val.deserialize(ParamEnumExtVal);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          ParamEnumExtVal ==
          _testerBase->paramTesterDelegate.m_param_ParamEnumExt
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMARRAYEXT: {
        A ParamArrayExtVal;
        _status = val.deserialize(ParamArrayExtVal);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          ParamArrayExtVal ==
          _testerBase->paramTesterDelegate.m_param_ParamArrayExt
        );
        break;
      };

      case ActiveTestComponentBase::PARAMID_PARAMSTRUCTEXT: {
        S ParamStructExtVal;
        _status = val.deserialize(ParamStructExtVal);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(
          ParamStructExtVal ==
          _testerBase->paramTesterDelegate.m_param_ParamStructExt
        );
        break;
      };

      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(id));
        break;
    }
  }

  void ActiveTestTesterBase ::
    from_productRequestOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwDpIdType id,
        FwSizeType dataSize
    )
  {
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    _testerBase->productRequest_handler(id, dataSize);
  }

  void ActiveTestTesterBase ::
    from_productSendOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwDpIdType id,
        const Fw::Buffer& buffer
    )
  {
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    _testerBase->productSend_handler(id, buffer);
  }

#if FW_ENABLE_TEXT_LOGGING == 1

  void ActiveTestTesterBase ::
    from_textEventOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwEventIdType id,
        Fw::Time& timeTag,
        const Fw::LogSeverity& severity,
        Fw::TextLogString& text
    )
  {
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    _testerBase->textLogIn(id, timeTag, severity, text);
  }

#endif

  void ActiveTestTesterBase ::
    from_timeGetOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        Fw::Time& time
    )
  {
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    time = _testerBase->m_testTime;
  }

  void ActiveTestTesterBase ::
    from_tlmOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwChanIdType id,
        Fw::Time& timeTag,
        Fw::TlmBuffer& val
    )
  {
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    _testerBase->dispatchTlm(id, timeTag, val);
  }

  void ActiveTestTesterBase ::
    from_noArgsOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum
    )
  {
    FW_ASSERT(callComp != nullptr);
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    _testerBase->from_noArgsOut_handlerBase(portNum);
  }

  U32 ActiveTestTesterBase ::
    from_noArgsReturnOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum
    )
  {
    FW_ASSERT(callComp != nullptr);
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    return _testerBase->from_noArgsReturnOut_handlerBase(portNum);
  }

  Fw::String ActiveTestTesterBase ::
    from_noArgsStringReturnOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum
    )
  {
    FW_ASSERT(callComp != nullptr);
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    return _testerBase->from_noArgsStringReturnOut_handlerBase(portNum);
  }

  void ActiveTestTesterBase ::
    from_typedAliasOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AliasStruct& s
    )
  {
    FW_ASSERT(callComp != nullptr);
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    _testerBase->from_typedAliasOut_handlerBase(
      portNum,
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  AliasPrim2 ActiveTestTesterBase ::
    from_typedAliasReturnOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AliasStruct& s
    )
  {
    FW_ASSERT(callComp != nullptr);
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    return _testerBase->from_typedAliasReturnOut_handlerBase(
      portNum,
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  Fw::String ActiveTestTesterBase ::
    from_typedAliasReturnStringOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        AliasPrim1 u32,
        AliasPrim2 f32,
        AliasBool b,
        const Fw::StringBase& str2,
        const AliasEnum& e,
        const AliasArray& a,
        const AnotherAliasStruct& s
    )
  {
    FW_ASSERT(callComp != nullptr);
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    return _testerBase->from_typedAliasReturnStringOut_handlerBase(
      portNum,
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  void ActiveTestTesterBase ::
    from_typedOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str1,
        const E& e,
        const A& a,
        const S& s
    )
  {
    FW_ASSERT(callComp != nullptr);
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    _testerBase->from_typedOut_handlerBase(
      portNum,
      u32,
      f32,
      b,
      str1,
      e,
      a,
      s
    );
  }

  F32 ActiveTestTesterBase ::
    from_typedReturnOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        U32 u32,
        F32 f32,
        bool b,
        const Fw::StringBase& str2,
        const E& e,
        const A& a,
        const S& s
    )
  {
    FW_ASSERT(callComp != nullptr);
    ActiveTestTesterBase* _testerBase = static_cast<ActiveTestTesterBase*>(callComp);
    return _testerBase->from_typedReturnOut_handlerBase(
      portNum,
      u32,
      f32,
      b,
      str2,
      e,
      a,
      s
    );
  }

  // ----------------------------------------------------------------------
  // Parameter delegates
  // ----------------------------------------------------------------------

}
