// ======================================================================
// \title  QueuedExternalParamsTesterBase.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for QueuedExternalParams component test harness base class
// ======================================================================

#include <cstdlib>
#include <cstring>

#include "test-base/QueuedExternalParamsTesterBase.hpp"

// ----------------------------------------------------------------------
// Unit test implementation of external parameter delegate serialization/deserialization
// ----------------------------------------------------------------------

Fw::SerializeStatus QueuedExternalParamsTesterBase::QueuedExternalParamsComponentBaseParamExternalDelegate ::
  deserializeParam(
      const FwPrmIdType baseId,
      const FwPrmIdType localId,
      const Fw::ParamValid prmStat,
      Fw::SerializeBufferBase& buff
  )
{
  Fw::SerializeStatus stat;
  (void) baseId;

  // Serialize the parameter based on ID
  switch(localId)
  {
    // ParamI32Ext
    case QueuedExternalParamsComponentBase::PARAMID_PARAMI32EXT:
      stat = buff.deserializeTo(this->m_param_ParamI32Ext);
      break;
    // ParamF64Ext
    case QueuedExternalParamsComponentBase::PARAMID_PARAMF64EXT:
      stat = buff.deserializeTo(this->m_param_ParamF64Ext);
      break;
    // ParamStringExt
    case QueuedExternalParamsComponentBase::PARAMID_PARAMSTRINGEXT:
      stat = buff.deserializeTo(this->m_param_ParamStringExt);
      break;
    // ParamEnumExt
    case QueuedExternalParamsComponentBase::PARAMID_PARAMENUMEXT:
      stat = buff.deserializeTo(this->m_param_ParamEnumExt);
      break;
    // ParamArrayExt
    case QueuedExternalParamsComponentBase::PARAMID_PARAMARRAYEXT:
      stat = buff.deserializeTo(this->m_param_ParamArrayExt);
      break;
    // ParamStructExt
    case QueuedExternalParamsComponentBase::PARAMID_PARAMSTRUCTEXT:
      stat = buff.deserializeTo(this->m_param_ParamStructExt);
      break;
    default:
      // Unknown ID; should not have gotten here
      FW_ASSERT(0, static_cast<FwAssertArgType>(localId));
  }

  return stat;
}

Fw::SerializeStatus QueuedExternalParamsTesterBase::QueuedExternalParamsComponentBaseParamExternalDelegate ::
  serializeParam(
      const FwPrmIdType baseId,
      const FwPrmIdType localId,
      Fw::SerializeBufferBase& buff
  ) const
{
  Fw::SerializeStatus stat;
  (void) baseId;

  // Serialize the parameter based on ID
  switch(localId)
  {
    // ParamI32Ext
    case QueuedExternalParamsComponentBase::PARAMID_PARAMI32EXT:
      stat = buff.serializeFrom(this->m_param_ParamI32Ext);
      break;
    // ParamF64Ext
    case QueuedExternalParamsComponentBase::PARAMID_PARAMF64EXT:
      stat = buff.serializeFrom(this->m_param_ParamF64Ext);
      break;
    // ParamStringExt
    case QueuedExternalParamsComponentBase::PARAMID_PARAMSTRINGEXT:
      stat = buff.serializeFrom(this->m_param_ParamStringExt);
      break;
    // ParamEnumExt
    case QueuedExternalParamsComponentBase::PARAMID_PARAMENUMEXT:
      stat = buff.serializeFrom(this->m_param_ParamEnumExt);
      break;
    // ParamArrayExt
    case QueuedExternalParamsComponentBase::PARAMID_PARAMARRAYEXT:
      stat = buff.serializeFrom(this->m_param_ParamArrayExt);
      break;
    // ParamStructExt
    case QueuedExternalParamsComponentBase::PARAMID_PARAMSTRUCTEXT:
      stat = buff.serializeFrom(this->m_param_ParamStructExt);
      break;
    default:
      // Unknown ID; should not have gotten here
      FW_ASSERT(0, static_cast<FwAssertArgType>(localId));
  }

  return stat;
}

// ----------------------------------------------------------------------
// Component initialization
// ----------------------------------------------------------------------

void QueuedExternalParamsTesterBase ::
  init(FwEnumStoreType instance)
{
  // Initialize base class
  Fw::PassiveComponentBase::init(instance);

  // Connect input port cmdRegOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_cmdRegOut());
    port++
  ) {
    this->m_from_cmdRegOut[port].init();
    this->m_from_cmdRegOut[port].addCallComp(
      this,
      from_cmdRegOut_static
    );
    this->m_from_cmdRegOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_cmdRegOut[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_cmdRegOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port cmdResponseOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_cmdResponseOut());
    port++
  ) {
    this->m_from_cmdResponseOut[port].init();
    this->m_from_cmdResponseOut[port].addCallComp(
      this,
      from_cmdResponseOut_static
    );
    this->m_from_cmdResponseOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_cmdResponseOut[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_cmdResponseOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port prmGetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_prmGetOut());
    port++
  ) {
    this->m_from_prmGetOut[port].init();
    this->m_from_prmGetOut[port].addCallComp(
      this,
      from_prmGetOut_static
    );
    this->m_from_prmGetOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_prmGetOut[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_prmGetOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port prmSetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_prmSetOut());
    port++
  ) {
    this->m_from_prmSetOut[port].init();
    this->m_from_prmSetOut[port].addCallComp(
      this,
      from_prmSetOut_static
    );
    this->m_from_prmSetOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_prmSetOut[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_prmSetOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port timeGetOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_timeGetOut());
    port++
  ) {
    this->m_from_timeGetOut[port].init();
    this->m_from_timeGetOut[port].addCallComp(
      this,
      from_timeGetOut_static
    );
    this->m_from_timeGetOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_timeGetOut[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_timeGetOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_noArgsOut());
    port++
  ) {
    this->m_from_noArgsOut[port].init();
    this->m_from_noArgsOut[port].addCallComp(
      this,
      from_noArgsOut_static
    );
    this->m_from_noArgsOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_noArgsOut[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_noArgsOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsReturnOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_noArgsReturnOut());
    port++
  ) {
    this->m_from_noArgsReturnOut[port].init();
    this->m_from_noArgsReturnOut[port].addCallComp(
      this,
      from_noArgsReturnOut_static
    );
    this->m_from_noArgsReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_noArgsReturnOut[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_noArgsReturnOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port noArgsStringReturnOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_noArgsStringReturnOut());
    port++
  ) {
    this->m_from_noArgsStringReturnOut[port].init();
    this->m_from_noArgsStringReturnOut[port].addCallComp(
      this,
      from_noArgsStringReturnOut_static
    );
    this->m_from_noArgsStringReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_noArgsStringReturnOut[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_noArgsStringReturnOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedAliasOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_typedAliasOut());
    port++
  ) {
    this->m_from_typedAliasOut[port].init();
    this->m_from_typedAliasOut[port].addCallComp(
      this,
      from_typedAliasOut_static
    );
    this->m_from_typedAliasOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_typedAliasOut[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_typedAliasOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedAliasReturnOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_typedAliasReturnOut());
    port++
  ) {
    this->m_from_typedAliasReturnOut[port].init();
    this->m_from_typedAliasReturnOut[port].addCallComp(
      this,
      from_typedAliasReturnOut_static
    );
    this->m_from_typedAliasReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_typedAliasReturnOut[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_typedAliasReturnOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedAliasReturnStringOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_typedAliasReturnStringOut());
    port++
  ) {
    this->m_from_typedAliasReturnStringOut[port].init();
    this->m_from_typedAliasReturnStringOut[port].addCallComp(
      this,
      from_typedAliasReturnStringOut_static
    );
    this->m_from_typedAliasReturnStringOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_typedAliasReturnStringOut[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_typedAliasReturnStringOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_typedOut());
    port++
  ) {
    this->m_from_typedOut[port].init();
    this->m_from_typedOut[port].addCallComp(
      this,
      from_typedOut_static
    );
    this->m_from_typedOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_typedOut[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_typedOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect input port typedReturnOut
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_from_typedReturnOut());
    port++
  ) {
    this->m_from_typedReturnOut[port].init();
    this->m_from_typedReturnOut[port].addCallComp(
      this,
      from_typedReturnOut_static
    );
    this->m_from_typedReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_from_typedReturnOut[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_from_typedReturnOut[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port cmdIn
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_cmdIn());
    port++
  ) {
    this->m_to_cmdIn[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_cmdIn[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_cmdIn[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port aliasTypedAsync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_aliasTypedAsync());
    port++
  ) {
    this->m_to_aliasTypedAsync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_aliasTypedAsync[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_aliasTypedAsync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsAliasStringReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_noArgsAliasStringReturnSync());
    port++
  ) {
    this->m_to_noArgsAliasStringReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_noArgsAliasStringReturnSync[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_noArgsAliasStringReturnSync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsAsync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_noArgsAsync());
    port++
  ) {
    this->m_to_noArgsAsync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_noArgsAsync[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_noArgsAsync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_noArgsGuarded());
    port++
  ) {
    this->m_to_noArgsGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_noArgsGuarded[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_noArgsGuarded[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsReturnGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_noArgsReturnGuarded());
    port++
  ) {
    this->m_to_noArgsReturnGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_noArgsReturnGuarded[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_noArgsReturnGuarded[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_noArgsReturnSync());
    port++
  ) {
    this->m_to_noArgsReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_noArgsReturnSync[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_noArgsReturnSync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsStringReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_noArgsStringReturnSync());
    port++
  ) {
    this->m_to_noArgsStringReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_noArgsStringReturnSync[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_noArgsStringReturnSync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port noArgsSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_noArgsSync());
    port++
  ) {
    this->m_to_noArgsSync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_noArgsSync[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_noArgsSync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAliasGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedAliasGuarded());
    port++
  ) {
    this->m_to_typedAliasGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedAliasGuarded[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedAliasGuarded[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAliasReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedAliasReturnSync());
    port++
  ) {
    this->m_to_typedAliasReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedAliasReturnSync[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedAliasReturnSync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAliasStringReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedAliasStringReturnSync());
    port++
  ) {
    this->m_to_typedAliasStringReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedAliasStringReturnSync[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedAliasStringReturnSync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAsync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedAsync());
    port++
  ) {
    this->m_to_typedAsync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedAsync[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedAsync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAsyncAssert
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedAsyncAssert());
    port++
  ) {
    this->m_to_typedAsyncAssert[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedAsyncAssert[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedAsyncAssert[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAsyncBlockPriority
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedAsyncBlockPriority());
    port++
  ) {
    this->m_to_typedAsyncBlockPriority[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedAsyncBlockPriority[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedAsyncBlockPriority[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedAsyncDropPriority
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedAsyncDropPriority());
    port++
  ) {
    this->m_to_typedAsyncDropPriority[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedAsyncDropPriority[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedAsyncDropPriority[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedGuarded());
    port++
  ) {
    this->m_to_typedGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedGuarded[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedGuarded[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedReturnGuarded
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedReturnGuarded());
    port++
  ) {
    this->m_to_typedReturnGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedReturnGuarded[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedReturnGuarded[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedReturnSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedReturnSync());
    port++
  ) {
    this->m_to_typedReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedReturnSync[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedReturnSync[port].setObjName(portName.toChar());
#endif
  }

  // Connect output port typedSync
  for (
    FwIndexType port = 0;
    port < static_cast<FwIndexType>(this->getNum_to_typedSync());
    port++
  ) {
    this->m_to_typedSync[port].init();

#if FW_OBJECT_NAMES == 1
    Fw::ObjectName portName;
    portName.format(
      "%s_to_typedSync[%" PRI_FwIndexType "]",
      this->m_objName.toChar(),
      port
    );
    this->m_to_typedSync[port].setObjName(portName.toChar());
#endif
  }
}

// ----------------------------------------------------------------------
// Connectors for to ports
// ----------------------------------------------------------------------

void QueuedExternalParamsTesterBase ::
  connect_to_cmdIn(
      FwIndexType portNum,
      Fw::InputCmdPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_cmdIn()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_cmdIn[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_aliasTypedAsync(
      FwIndexType portNum,
      Ports::InputAliasTypedPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_aliasTypedAsync()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_aliasTypedAsync[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_noArgsAliasStringReturnSync(
      FwIndexType portNum,
      Ports::InputNoArgsAliasStringReturnPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsAliasStringReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsAliasStringReturnSync[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_noArgsAsync(
      FwIndexType portNum,
      Ports::InputNoArgsPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsAsync()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsAsync[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_noArgsGuarded(
      FwIndexType portNum,
      Ports::InputNoArgsPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsGuarded[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_noArgsReturnGuarded(
      FwIndexType portNum,
      Ports::InputNoArgsReturnPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsReturnGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsReturnGuarded[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_noArgsReturnSync(
      FwIndexType portNum,
      Ports::InputNoArgsReturnPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsReturnSync[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_noArgsStringReturnSync(
      FwIndexType portNum,
      Ports::InputNoArgsStringReturnPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsStringReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsStringReturnSync[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_noArgsSync(
      FwIndexType portNum,
      Ports::InputNoArgsPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsSync[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_typedAliasGuarded(
      FwIndexType portNum,
      Ports::InputAliasTypedPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAliasGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAliasGuarded[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_typedAliasReturnSync(
      FwIndexType portNum,
      Ports::InputAliasTypedReturnPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAliasReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAliasReturnSync[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_typedAliasStringReturnSync(
      FwIndexType portNum,
      Ports::InputAliasTypedReturnStringPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAliasStringReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAliasStringReturnSync[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_typedAsync(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAsync()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAsync[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_typedAsyncAssert(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAsyncAssert()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAsyncAssert[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_typedAsyncBlockPriority(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAsyncBlockPriority()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAsyncBlockPriority[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_typedAsyncDropPriority(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAsyncDropPriority()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAsyncDropPriority[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_typedGuarded(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedGuarded[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_typedReturnGuarded(
      FwIndexType portNum,
      Ports::InputTypedReturnPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedReturnGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedReturnGuarded[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_typedReturnSync(
      FwIndexType portNum,
      Ports::InputTypedReturnPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedReturnSync[portNum].addCallPort(port);
}

void QueuedExternalParamsTesterBase ::
  connect_to_typedSync(
      FwIndexType portNum,
      Ports::InputTypedPort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedSync[portNum].addCallPort(port);
}

// ----------------------------------------------------------------------
// Getters for from ports
// ----------------------------------------------------------------------

Fw::InputCmdRegPort* QueuedExternalParamsTesterBase ::
  get_from_cmdRegOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_cmdRegOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_cmdRegOut[portNum];
}

Fw::InputCmdResponsePort* QueuedExternalParamsTesterBase ::
  get_from_cmdResponseOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_cmdResponseOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_cmdResponseOut[portNum];
}

Fw::InputLogPort* QueuedExternalParamsTesterBase ::
  get_from_eventOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_eventOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_eventOut[portNum];
}

Fw::InputPrmGetPort* QueuedExternalParamsTesterBase ::
  get_from_prmGetOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_prmGetOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_prmGetOut[portNum];
}

Fw::InputPrmSetPort* QueuedExternalParamsTesterBase ::
  get_from_prmSetOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_prmSetOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_prmSetOut[portNum];
}

#if FW_ENABLE_TEXT_LOGGING == 1

Fw::InputLogTextPort* QueuedExternalParamsTesterBase ::
  get_from_textEventOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_textEventOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_textEventOut[portNum];
}

#endif

Fw::InputTimePort* QueuedExternalParamsTesterBase ::
  get_from_timeGetOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_timeGetOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_timeGetOut[portNum];
}

Fw::InputTlmPort* QueuedExternalParamsTesterBase ::
  get_from_tlmOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_tlmOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_tlmOut[portNum];
}

Ports::InputNoArgsPort* QueuedExternalParamsTesterBase ::
  get_from_noArgsOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_noArgsOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_noArgsOut[portNum];
}

Ports::InputNoArgsReturnPort* QueuedExternalParamsTesterBase ::
  get_from_noArgsReturnOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_noArgsReturnOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_noArgsReturnOut[portNum];
}

Ports::InputNoArgsStringReturnPort* QueuedExternalParamsTesterBase ::
  get_from_noArgsStringReturnOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_noArgsStringReturnOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_noArgsStringReturnOut[portNum];
}

Ports::InputAliasTypedPort* QueuedExternalParamsTesterBase ::
  get_from_typedAliasOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_typedAliasOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_typedAliasOut[portNum];
}

Ports::InputAliasTypedReturnPort* QueuedExternalParamsTesterBase ::
  get_from_typedAliasReturnOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_typedAliasReturnOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_typedAliasReturnOut[portNum];
}

Ports::InputAliasTypedReturnStringPort* QueuedExternalParamsTesterBase ::
  get_from_typedAliasReturnStringOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_typedAliasReturnStringOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_typedAliasReturnStringOut[portNum];
}

Ports::InputTypedPort* QueuedExternalParamsTesterBase ::
  get_from_typedOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_typedOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_typedOut[portNum];
}

Ports::InputTypedReturnPort* QueuedExternalParamsTesterBase ::
  get_from_typedReturnOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_typedReturnOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_typedReturnOut[portNum];
}

// ----------------------------------------------------------------------
// Component construction and destruction
// ----------------------------------------------------------------------

QueuedExternalParamsTesterBase ::
  QueuedExternalParamsTesterBase(
      const char* const compName,
      const U32 maxHistorySize
  ) :
    Fw::PassiveComponentBase(compName)
{
  // Initialize port histories
  this->fromPortHistory_typedAliasOut = new History<FromPortEntry_typedAliasOut>(maxHistorySize);
  this->fromPortHistory_typedAliasReturnOut = new History<FromPortEntry_typedAliasReturnOut>(maxHistorySize);
  this->fromPortHistory_typedAliasReturnStringOut = new History<FromPortEntry_typedAliasReturnStringOut>(maxHistorySize);
  this->fromPortHistory_typedOut = new History<FromPortEntry_typedOut>(maxHistorySize);
  this->fromPortHistory_typedReturnOut = new History<FromPortEntry_typedReturnOut>(maxHistorySize);

  // Initialize command history
  this->cmdResponseHistory = new History<CmdResponse>(maxHistorySize);

  // Clear history
  this->clearHistory();
}

QueuedExternalParamsTesterBase ::
  ~QueuedExternalParamsTesterBase()
{
  // Destroy port histories
  delete this->fromPortHistory_typedAliasOut;
  delete this->fromPortHistory_typedAliasReturnOut;
  delete this->fromPortHistory_typedAliasReturnStringOut;
  delete this->fromPortHistory_typedOut;
  delete this->fromPortHistory_typedReturnOut;

  // Destroy command history
  delete this->cmdResponseHistory;
}

// ----------------------------------------------------------------------
// Default handler implementations for typed from ports
// You can override these implementation with more specific behavior
// ----------------------------------------------------------------------

void QueuedExternalParamsTesterBase ::
  from_noArgsOut_handler(FwIndexType portNum)
{
  this->pushFromPortEntry_noArgsOut();
}

U32 QueuedExternalParamsTesterBase ::
  from_noArgsReturnOut_handler(FwIndexType portNum)
{
  this->pushFromPortEntry_noArgsReturnOut();
  return 0;
}

Fw::String QueuedExternalParamsTesterBase ::
  from_noArgsStringReturnOut_handler(FwIndexType portNum)
{
  this->pushFromPortEntry_noArgsStringReturnOut();
  return Fw::String("");
}

void QueuedExternalParamsTesterBase ::
  from_typedAliasOut_handler(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  this->pushFromPortEntry_typedAliasOut(u32, f32, b, str2, e, a, s);
}

AliasPrim2 QueuedExternalParamsTesterBase ::
  from_typedAliasReturnOut_handler(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  this->pushFromPortEntry_typedAliasReturnOut(u32, f32, b, str2, e, a, s);
  return 0.0f;
}

Fw::String QueuedExternalParamsTesterBase ::
  from_typedAliasReturnStringOut_handler(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AnotherAliasStruct& s
  )
{
  this->pushFromPortEntry_typedAliasReturnStringOut(u32, f32, b, str2, e, a, s);
  return Fw::String("");
}

void QueuedExternalParamsTesterBase ::
  from_typedOut_handler(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  this->pushFromPortEntry_typedOut(u32, f32, b, str1, e, a, s);
}

F32 QueuedExternalParamsTesterBase ::
  from_typedReturnOut_handler(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  this->pushFromPortEntry_typedReturnOut(u32, f32, b, str2, e, a, s);
  return 0.0f;
}

// ----------------------------------------------------------------------
// Handler base-class functions for from ports
// ----------------------------------------------------------------------

void QueuedExternalParamsTesterBase ::
  from_noArgsOut_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_noArgsOut()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_noArgsOut_handler(portNum);
}

U32 QueuedExternalParamsTesterBase ::
  from_noArgsReturnOut_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_noArgsReturnOut()),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_noArgsReturnOut_handler(portNum);
}

Fw::String QueuedExternalParamsTesterBase ::
  from_noArgsStringReturnOut_handlerBase(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_noArgsStringReturnOut()),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_noArgsStringReturnOut_handler(portNum);
}

void QueuedExternalParamsTesterBase ::
  from_typedAliasOut_handlerBase(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_typedAliasOut()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_typedAliasOut_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

AliasPrim2 QueuedExternalParamsTesterBase ::
  from_typedAliasReturnOut_handlerBase(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_typedAliasReturnOut()),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_typedAliasReturnOut_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

Fw::String QueuedExternalParamsTesterBase ::
  from_typedAliasReturnStringOut_handlerBase(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AnotherAliasStruct& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_typedAliasReturnStringOut()),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_typedAliasReturnStringOut_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void QueuedExternalParamsTesterBase ::
  from_typedOut_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_typedOut()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_typedOut_handler(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 QueuedExternalParamsTesterBase ::
  from_typedReturnOut_handlerBase(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_typedReturnOut()),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_typedReturnOut_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Invocation functions for to ports
// ----------------------------------------------------------------------

void QueuedExternalParamsTesterBase ::
  invoke_to_aliasTypedAsync(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_aliasTypedAsync()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_aliasTypedAsync[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

Fw::String QueuedExternalParamsTesterBase ::
  invoke_to_noArgsAliasStringReturnSync(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsAliasStringReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_noArgsAliasStringReturnSync[portNum].invoke();
}

void QueuedExternalParamsTesterBase ::
  invoke_to_noArgsAsync(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsAsync()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_noArgsAsync[portNum].invoke();
}

void QueuedExternalParamsTesterBase ::
  invoke_to_noArgsGuarded(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_noArgsGuarded[portNum].invoke();
}

U32 QueuedExternalParamsTesterBase ::
  invoke_to_noArgsReturnGuarded(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsReturnGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_noArgsReturnGuarded[portNum].invoke();
}

U32 QueuedExternalParamsTesterBase ::
  invoke_to_noArgsReturnSync(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_noArgsReturnSync[portNum].invoke();
}

Fw::String QueuedExternalParamsTesterBase ::
  invoke_to_noArgsStringReturnSync(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsStringReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_noArgsStringReturnSync[portNum].invoke();
}

void QueuedExternalParamsTesterBase ::
  invoke_to_noArgsSync(FwIndexType portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsSync()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_noArgsSync[portNum].invoke();
}

void QueuedExternalParamsTesterBase ::
  invoke_to_typedAliasGuarded(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAliasGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedAliasGuarded[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

AliasPrim2 QueuedExternalParamsTesterBase ::
  invoke_to_typedAliasReturnSync(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAliasReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_typedAliasReturnSync[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

Fw::String QueuedExternalParamsTesterBase ::
  invoke_to_typedAliasStringReturnSync(
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AnotherAliasStruct& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAliasStringReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_typedAliasStringReturnSync[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void QueuedExternalParamsTesterBase ::
  invoke_to_typedAsync(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAsync()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedAsync[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedExternalParamsTesterBase ::
  invoke_to_typedAsyncAssert(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAsyncAssert()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedAsyncAssert[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedExternalParamsTesterBase ::
  invoke_to_typedAsyncBlockPriority(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAsyncBlockPriority()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedAsyncBlockPriority[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedExternalParamsTesterBase ::
  invoke_to_typedAsyncDropPriority(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAsyncDropPriority()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedAsyncDropPriority[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedExternalParamsTesterBase ::
  invoke_to_typedGuarded(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedGuarded[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 QueuedExternalParamsTesterBase ::
  invoke_to_typedReturnGuarded(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedReturnGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_typedReturnGuarded[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

F32 QueuedExternalParamsTesterBase ::
  invoke_to_typedReturnSync(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_typedReturnSync[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void QueuedExternalParamsTesterBase ::
  invoke_to_typedSync(
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedSync()),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedSync[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Getters for port counts
// ----------------------------------------------------------------------

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_cmdIn() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_cmdIn));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_aliasTypedAsync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_aliasTypedAsync));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_noArgsAliasStringReturnSync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsAliasStringReturnSync));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_noArgsAsync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsAsync));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_noArgsGuarded() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsGuarded));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_noArgsReturnGuarded() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsReturnGuarded));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_noArgsReturnSync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsReturnSync));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_noArgsStringReturnSync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsStringReturnSync));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_noArgsSync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsSync));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_typedAliasGuarded() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAliasGuarded));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_typedAliasReturnSync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAliasReturnSync));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_typedAliasStringReturnSync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAliasStringReturnSync));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_typedAsync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsync));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_typedAsyncAssert() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsyncAssert));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_typedAsyncBlockPriority() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsyncBlockPriority));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_typedAsyncDropPriority() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsyncDropPriority));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_typedGuarded() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedGuarded));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_typedReturnGuarded() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedReturnGuarded));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_typedReturnSync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedReturnSync));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_to_typedSync() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedSync));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_cmdRegOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_cmdRegOut));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_cmdResponseOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_cmdResponseOut));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_eventOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_eventOut));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_prmGetOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_prmGetOut));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_prmSetOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_prmSetOut));
}

#if FW_ENABLE_TEXT_LOGGING == 1

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_textEventOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_textEventOut));
}

#endif

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_timeGetOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_timeGetOut));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_tlmOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_tlmOut));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_noArgsOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_noArgsOut));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_noArgsReturnOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_noArgsReturnOut));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_noArgsStringReturnOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_noArgsStringReturnOut));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_typedAliasOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedAliasOut));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_typedAliasReturnOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedAliasReturnOut));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_typedAliasReturnStringOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedAliasReturnStringOut));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_typedOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedOut));
}

FwIndexType QueuedExternalParamsTesterBase ::
  getNum_from_typedReturnOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedReturnOut));
}

// ----------------------------------------------------------------------
// Connection status queries for to ports
// ----------------------------------------------------------------------

bool QueuedExternalParamsTesterBase ::
  isConnected_to_cmdIn(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_cmdIn()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_cmdIn[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_aliasTypedAsync(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_aliasTypedAsync()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_aliasTypedAsync[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_noArgsAliasStringReturnSync(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsAliasStringReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsAliasStringReturnSync[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_noArgsAsync(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsAsync()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsAsync[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_noArgsGuarded(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsGuarded[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_noArgsReturnGuarded(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsReturnGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsReturnGuarded[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_noArgsReturnSync(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsReturnSync[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_noArgsStringReturnSync(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsStringReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsStringReturnSync[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_noArgsSync(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_noArgsSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsSync[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_typedAliasGuarded(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAliasGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAliasGuarded[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_typedAliasReturnSync(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAliasReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAliasReturnSync[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_typedAliasStringReturnSync(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAliasStringReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAliasStringReturnSync[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_typedAsync(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAsync()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAsync[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_typedAsyncAssert(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAsyncAssert()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAsyncAssert[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_typedAsyncBlockPriority(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAsyncBlockPriority()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAsyncBlockPriority[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_typedAsyncDropPriority(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedAsyncDropPriority()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAsyncDropPriority[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_typedGuarded(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedGuarded[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_typedReturnGuarded(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedReturnGuarded()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedReturnGuarded[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_typedReturnSync(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedReturnSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedReturnSync[portNum].isConnected();
}

bool QueuedExternalParamsTesterBase ::
  isConnected_to_typedSync(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_typedSync()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedSync[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Functions for testing commands
// ----------------------------------------------------------------------

void QueuedExternalParamsTesterBase ::
  cmdResponseIn(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdResponse response
  )
{
  CmdResponse e = { opCode, cmdSeq, response };
  this->cmdResponseHistory->push_back(e);
}

void QueuedExternalParamsTesterBase ::
  sendRawCmd(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& buf
  )
{
  const U32 idBase = this->getIdBase();
  FwOpcodeType _opcode = opCode + idBase;
  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

// ----------------------------------------------------------------------
// Functions to test parameters
// ----------------------------------------------------------------------

void QueuedExternalParamsTesterBase ::
  paramSet_ParamI32Ext(
      const I32& val,
      Fw::ParamValid valid
  )
{
  this->paramTesterDelegate.m_param_ParamI32Ext = val;
  this->paramTesterDelegate.m_param_ParamI32Ext_valid = valid;
}

void QueuedExternalParamsTesterBase ::
  paramSend_ParamI32Ext(
      FwEnumStoreType instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serializeFrom(this->paramTesterDelegate.m_param_ParamI32Ext) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  QueuedExternalParamsComponentBase::OPCODE_PARAMI32EXT_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void QueuedExternalParamsTesterBase ::
  paramSave_ParamI32Ext(
      FwEnumStoreType instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = QueuedExternalParamsComponentBase::OPCODE_PARAMI32EXT_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void QueuedExternalParamsTesterBase ::
  paramSet_ParamF64Ext(
      const F64& val,
      Fw::ParamValid valid
  )
{
  this->paramTesterDelegate.m_param_ParamF64Ext = val;
  this->paramTesterDelegate.m_param_ParamF64Ext_valid = valid;
}

void QueuedExternalParamsTesterBase ::
  paramSend_ParamF64Ext(
      FwEnumStoreType instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serializeFrom(this->paramTesterDelegate.m_param_ParamF64Ext) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  QueuedExternalParamsComponentBase::OPCODE_PARAMF64EXT_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void QueuedExternalParamsTesterBase ::
  paramSave_ParamF64Ext(
      FwEnumStoreType instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = QueuedExternalParamsComponentBase::OPCODE_PARAMF64EXT_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void QueuedExternalParamsTesterBase ::
  paramSet_ParamStringExt(
      const Fw::StringBase& val,
      Fw::ParamValid valid
  )
{
  this->paramTesterDelegate.m_param_ParamStringExt = val;
  this->paramTesterDelegate.m_param_ParamStringExt_valid = valid;
}

void QueuedExternalParamsTesterBase ::
  paramSend_ParamStringExt(
      FwEnumStoreType instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serializeFrom(this->paramTesterDelegate.m_param_ParamStringExt) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  QueuedExternalParamsComponentBase::OPCODE_PARAMSTRINGEXT_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void QueuedExternalParamsTesterBase ::
  paramSave_ParamStringExt(
      FwEnumStoreType instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = QueuedExternalParamsComponentBase::OPCODE_PARAMSTRINGEXT_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void QueuedExternalParamsTesterBase ::
  paramSet_ParamEnumExt(
      const E& val,
      Fw::ParamValid valid
  )
{
  this->paramTesterDelegate.m_param_ParamEnumExt = val;
  this->paramTesterDelegate.m_param_ParamEnumExt_valid = valid;
}

void QueuedExternalParamsTesterBase ::
  paramSend_ParamEnumExt(
      FwEnumStoreType instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serializeFrom(this->paramTesterDelegate.m_param_ParamEnumExt) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  QueuedExternalParamsComponentBase::OPCODE_PARAMENUMEXT_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void QueuedExternalParamsTesterBase ::
  paramSave_ParamEnumExt(
      FwEnumStoreType instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = QueuedExternalParamsComponentBase::OPCODE_PARAMENUMEXT_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void QueuedExternalParamsTesterBase ::
  paramSet_ParamArrayExt(
      const A& val,
      Fw::ParamValid valid
  )
{
  this->paramTesterDelegate.m_param_ParamArrayExt = val;
  this->paramTesterDelegate.m_param_ParamArrayExt_valid = valid;
}

void QueuedExternalParamsTesterBase ::
  paramSend_ParamArrayExt(
      FwEnumStoreType instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serializeFrom(this->paramTesterDelegate.m_param_ParamArrayExt) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  QueuedExternalParamsComponentBase::OPCODE_PARAMARRAYEXT_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void QueuedExternalParamsTesterBase ::
  paramSave_ParamArrayExt(
      FwEnumStoreType instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = QueuedExternalParamsComponentBase::OPCODE_PARAMARRAYEXT_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void QueuedExternalParamsTesterBase ::
  paramSet_ParamStructExt(
      const S& val,
      Fw::ParamValid valid
  )
{
  this->paramTesterDelegate.m_param_ParamStructExt = val;
  this->paramTesterDelegate.m_param_ParamStructExt_valid = valid;
}

void QueuedExternalParamsTesterBase ::
  paramSend_ParamStructExt(
      FwEnumStoreType instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serializeFrom(this->paramTesterDelegate.m_param_ParamStructExt) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  QueuedExternalParamsComponentBase::OPCODE_PARAMSTRUCTEXT_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void QueuedExternalParamsTesterBase ::
  paramSave_ParamStructExt(
      FwEnumStoreType instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = QueuedExternalParamsComponentBase::OPCODE_PARAMSTRUCTEXT_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

// ----------------------------------------------------------------------
// Functions to test time
// ----------------------------------------------------------------------

void QueuedExternalParamsTesterBase ::
  setTestTime(const Fw::Time& timeTag)
{
  this->m_testTime = timeTag;
}

// ----------------------------------------------------------------------
// History functions
// ----------------------------------------------------------------------

void QueuedExternalParamsTesterBase ::
  clearHistory()
{
  this->clearFromPortHistory();
  this->cmdResponseHistory->clear();
}

void QueuedExternalParamsTesterBase ::
  clearFromPortHistory()
{
  this->fromPortHistorySize = 0;
  this->fromPortHistorySize_noArgsOut = 0;
  this->fromPortHistorySize_noArgsReturnOut = 0;
  this->fromPortHistorySize_noArgsStringReturnOut = 0;
  this->fromPortHistory_typedAliasOut->clear();
  this->fromPortHistory_typedAliasReturnOut->clear();
  this->fromPortHistory_typedAliasReturnStringOut->clear();
  this->fromPortHistory_typedOut->clear();
  this->fromPortHistory_typedReturnOut->clear();
}

void QueuedExternalParamsTesterBase ::
  pushFromPortEntry_noArgsOut()
{
  this->fromPortHistorySize_noArgsOut++;
  this->fromPortHistorySize++;
}

void QueuedExternalParamsTesterBase ::
  pushFromPortEntry_noArgsReturnOut()
{
  this->fromPortHistorySize_noArgsReturnOut++;
  this->fromPortHistorySize++;
}

void QueuedExternalParamsTesterBase ::
  pushFromPortEntry_noArgsStringReturnOut()
{
  this->fromPortHistorySize_noArgsStringReturnOut++;
  this->fromPortHistorySize++;
}

void QueuedExternalParamsTesterBase ::
  pushFromPortEntry_typedAliasOut(
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  FromPortEntry_typedAliasOut _e;
  _e.u32 = u32;
  _e.f32 = f32;
  _e.b = b;
  _e.str2 = str2;
  _e.e = e;
  _e.a = a;
  _e.s = s;
  this->fromPortHistory_typedAliasOut->push_back(_e);
  this->fromPortHistorySize++;
}

void QueuedExternalParamsTesterBase ::
  pushFromPortEntry_typedAliasReturnOut(
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  FromPortEntry_typedAliasReturnOut _e;
  _e.u32 = u32;
  _e.f32 = f32;
  _e.b = b;
  _e.str2 = str2;
  _e.e = e;
  _e.a = a;
  _e.s = s;
  this->fromPortHistory_typedAliasReturnOut->push_back(_e);
  this->fromPortHistorySize++;
}

void QueuedExternalParamsTesterBase ::
  pushFromPortEntry_typedAliasReturnStringOut(
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AnotherAliasStruct& s
  )
{
  FromPortEntry_typedAliasReturnStringOut _e;
  _e.u32 = u32;
  _e.f32 = f32;
  _e.b = b;
  _e.str2 = str2;
  _e.e = e;
  _e.a = a;
  _e.s = s;
  this->fromPortHistory_typedAliasReturnStringOut->push_back(_e);
  this->fromPortHistorySize++;
}

void QueuedExternalParamsTesterBase ::
  pushFromPortEntry_typedOut(
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FromPortEntry_typedOut _e;
  _e.u32 = u32;
  _e.f32 = f32;
  _e.b = b;
  _e.str1 = str1;
  _e.e = e;
  _e.a = a;
  _e.s = s;
  this->fromPortHistory_typedOut->push_back(_e);
  this->fromPortHistorySize++;
}

void QueuedExternalParamsTesterBase ::
  pushFromPortEntry_typedReturnOut(
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FromPortEntry_typedReturnOut _e;
  _e.u32 = u32;
  _e.f32 = f32;
  _e.b = b;
  _e.str2 = str2;
  _e.e = e;
  _e.a = a;
  _e.s = s;
  this->fromPortHistory_typedReturnOut->push_back(_e);
  this->fromPortHistorySize++;
}

// ----------------------------------------------------------------------
// Static functions for output ports
// ----------------------------------------------------------------------

void QueuedExternalParamsTesterBase ::
  from_cmdRegOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      FwOpcodeType opCode
  )
{

}

void QueuedExternalParamsTesterBase ::
  from_cmdResponseOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      FwOpcodeType opCode,
      U32 cmdSeq,
      const Fw::CmdResponse& response
  )
{
  QueuedExternalParamsTesterBase* _testerBase = static_cast<QueuedExternalParamsTesterBase*>(callComp);
  _testerBase->cmdResponseIn(opCode, cmdSeq, response);
}

Fw::ParamValid QueuedExternalParamsTesterBase ::
  from_prmGetOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      FwPrmIdType id,
      Fw::ParamBuffer& val
  )
{
  QueuedExternalParamsTesterBase* _testerBase = static_cast<QueuedExternalParamsTesterBase*>(callComp);

  Fw::SerializeStatus _status;

  Fw::ParamValid _ret = Fw::ParamValid::VALID;
  val.resetSer();

  const U32 idBase = _testerBase->getIdBase();
  FW_ASSERT(
    id >= idBase,
    static_cast<FwAssertArgType>(id),
    static_cast<FwAssertArgType>(idBase)
  );

  switch (id - idBase) {
    case QueuedExternalParamsComponentBase::PARAMID_PARAMI32EXT: {
      _status = val.serializeFrom(_testerBase->paramTesterDelegate.m_param_ParamI32Ext);
      _ret = _testerBase->paramTesterDelegate.m_param_ParamI32Ext_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case QueuedExternalParamsComponentBase::PARAMID_PARAMF64EXT: {
      _status = val.serializeFrom(_testerBase->paramTesterDelegate.m_param_ParamF64Ext);
      _ret = _testerBase->paramTesterDelegate.m_param_ParamF64Ext_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case QueuedExternalParamsComponentBase::PARAMID_PARAMSTRINGEXT: {
      _status = val.serializeFrom(_testerBase->paramTesterDelegate.m_param_ParamStringExt);
      _ret = _testerBase->paramTesterDelegate.m_param_ParamStringExt_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case QueuedExternalParamsComponentBase::PARAMID_PARAMENUMEXT: {
      _status = val.serializeFrom(_testerBase->paramTesterDelegate.m_param_ParamEnumExt);
      _ret = _testerBase->paramTesterDelegate.m_param_ParamEnumExt_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case QueuedExternalParamsComponentBase::PARAMID_PARAMARRAYEXT: {
      _status = val.serializeFrom(_testerBase->paramTesterDelegate.m_param_ParamArrayExt);
      _ret = _testerBase->paramTesterDelegate.m_param_ParamArrayExt_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case QueuedExternalParamsComponentBase::PARAMID_PARAMSTRUCTEXT: {
      _status = val.serializeFrom(_testerBase->paramTesterDelegate.m_param_ParamStructExt);
      _ret = _testerBase->paramTesterDelegate.m_param_ParamStructExt_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    default:
      FW_ASSERT(0, static_cast<FwAssertArgType>(id));
      break;
  }

  return _ret;
}

void QueuedExternalParamsTesterBase ::
  from_prmSetOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      FwPrmIdType id,
      Fw::ParamBuffer& val
  )
{
  QueuedExternalParamsTesterBase* _testerBase = static_cast<QueuedExternalParamsTesterBase*>(callComp);
  Fw::SerializeStatus _status;

  const U32 idBase = _testerBase->getIdBase();
  FW_ASSERT(
    id >= idBase,
    static_cast<FwAssertArgType>(id),
    static_cast<FwAssertArgType>(idBase)
  );

  switch (id - idBase) {
    case QueuedExternalParamsComponentBase::PARAMID_PARAMI32EXT: {
      I32 ParamI32ExtVal;
      _status = val.deserializeTo(ParamI32ExtVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamI32ExtVal ==
        _testerBase->paramTesterDelegate.m_param_ParamI32Ext
      );
      break;
    };

    case QueuedExternalParamsComponentBase::PARAMID_PARAMF64EXT: {
      F64 ParamF64ExtVal;
      _status = val.deserializeTo(ParamF64ExtVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamF64ExtVal ==
        _testerBase->paramTesterDelegate.m_param_ParamF64Ext
      );
      break;
    };

    case QueuedExternalParamsComponentBase::PARAMID_PARAMSTRINGEXT: {
      Fw::ParamString ParamStringExtVal;
      _status = val.deserializeTo(ParamStringExtVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamStringExtVal ==
        _testerBase->paramTesterDelegate.m_param_ParamStringExt
      );
      break;
    };

    case QueuedExternalParamsComponentBase::PARAMID_PARAMENUMEXT: {
      E ParamEnumExtVal;
      _status = val.deserializeTo(ParamEnumExtVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamEnumExtVal ==
        _testerBase->paramTesterDelegate.m_param_ParamEnumExt
      );
      break;
    };

    case QueuedExternalParamsComponentBase::PARAMID_PARAMARRAYEXT: {
      A ParamArrayExtVal;
      _status = val.deserializeTo(ParamArrayExtVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamArrayExtVal ==
        _testerBase->paramTesterDelegate.m_param_ParamArrayExt
      );
      break;
    };

    case QueuedExternalParamsComponentBase::PARAMID_PARAMSTRUCTEXT: {
      S ParamStructExtVal;
      _status = val.deserializeTo(ParamStructExtVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamStructExtVal ==
        _testerBase->paramTesterDelegate.m_param_ParamStructExt
      );
      break;
    };

    default:
      FW_ASSERT(0, static_cast<FwAssertArgType>(id));
      break;
  }
}

void QueuedExternalParamsTesterBase ::
  from_timeGetOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      Fw::Time& time
  )
{
  QueuedExternalParamsTesterBase* _testerBase = static_cast<QueuedExternalParamsTesterBase*>(callComp);
  time = _testerBase->m_testTime;
}

void QueuedExternalParamsTesterBase ::
  from_noArgsOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp != nullptr);
  QueuedExternalParamsTesterBase* _testerBase = static_cast<QueuedExternalParamsTesterBase*>(callComp);
  _testerBase->from_noArgsOut_handlerBase(portNum);
}

U32 QueuedExternalParamsTesterBase ::
  from_noArgsReturnOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp != nullptr);
  QueuedExternalParamsTesterBase* _testerBase = static_cast<QueuedExternalParamsTesterBase*>(callComp);
  return _testerBase->from_noArgsReturnOut_handlerBase(portNum);
}

Fw::String QueuedExternalParamsTesterBase ::
  from_noArgsStringReturnOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum
  )
{
  FW_ASSERT(callComp != nullptr);
  QueuedExternalParamsTesterBase* _testerBase = static_cast<QueuedExternalParamsTesterBase*>(callComp);
  return _testerBase->from_noArgsStringReturnOut_handlerBase(portNum);
}

void QueuedExternalParamsTesterBase ::
  from_typedAliasOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  FW_ASSERT(callComp != nullptr);
  QueuedExternalParamsTesterBase* _testerBase = static_cast<QueuedExternalParamsTesterBase*>(callComp);
  _testerBase->from_typedAliasOut_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

AliasPrim2 QueuedExternalParamsTesterBase ::
  from_typedAliasReturnOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AliasStruct& s
  )
{
  FW_ASSERT(callComp != nullptr);
  QueuedExternalParamsTesterBase* _testerBase = static_cast<QueuedExternalParamsTesterBase*>(callComp);
  return _testerBase->from_typedAliasReturnOut_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

Fw::String QueuedExternalParamsTesterBase ::
  from_typedAliasReturnStringOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      AliasPrim1 u32,
      AliasPrim2 f32,
      AliasBool b,
      const Fw::StringBase& str2,
      const AliasEnum& e,
      const AliasArray& a,
      const AnotherAliasStruct& s
  )
{
  FW_ASSERT(callComp != nullptr);
  QueuedExternalParamsTesterBase* _testerBase = static_cast<QueuedExternalParamsTesterBase*>(callComp);
  return _testerBase->from_typedAliasReturnStringOut_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void QueuedExternalParamsTesterBase ::
  from_typedOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp != nullptr);
  QueuedExternalParamsTesterBase* _testerBase = static_cast<QueuedExternalParamsTesterBase*>(callComp);
  _testerBase->from_typedOut_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 QueuedExternalParamsTesterBase ::
  from_typedReturnOut_static(
      Fw::PassiveComponentBase* const callComp,
      FwIndexType portNum,
      U32 u32,
      F32 f32,
      bool b,
      const Fw::StringBase& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp != nullptr);
  QueuedExternalParamsTesterBase* _testerBase = static_cast<QueuedExternalParamsTesterBase*>(callComp);
  return _testerBase->from_typedReturnOut_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Parameter delegates
// ----------------------------------------------------------------------
