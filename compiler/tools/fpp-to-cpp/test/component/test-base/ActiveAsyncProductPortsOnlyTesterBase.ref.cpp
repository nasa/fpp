// ======================================================================
// \title  ActiveAsyncProductPortsOnlyTesterBase.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for ActiveAsyncProductPortsOnly component test harness base class
// ======================================================================

#include <cstdlib>
#include <cstring>

#include "test-base/ActiveAsyncProductPortsOnlyTesterBase.hpp"

// ----------------------------------------------------------------------
// Component initialization
// ----------------------------------------------------------------------

void ActiveAsyncProductPortsOnlyTesterBase ::
  init(FwEnumStoreType instance)
{
  // Initialize base class
  Fw::PassiveComponentBase::init(instance);
}

// ----------------------------------------------------------------------
// Connectors for to ports
// ----------------------------------------------------------------------

void ActiveAsyncProductPortsOnlyTesterBase ::
  connect_to_productRecvIn(
      FwIndexType portNum,
      Fw::InputDpResponsePort* port
  )
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_productRecvIn()),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_productRecvIn[portNum].addCallPort(port);
}

// ----------------------------------------------------------------------
// Getters for from ports
// ----------------------------------------------------------------------

Fw::InputDpRequestPort* ActiveAsyncProductPortsOnlyTesterBase ::
  get_from_productRequestOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_productRequestOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_productRequestOut[portNum];
}

Fw::InputDpSendPort* ActiveAsyncProductPortsOnlyTesterBase ::
  get_from_productSendOut(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_from_productSendOut()),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_productSendOut[portNum];
}

// ----------------------------------------------------------------------
// Component construction and destruction
// ----------------------------------------------------------------------

ActiveAsyncProductPortsOnlyTesterBase ::
  ActiveAsyncProductPortsOnlyTesterBase(
      const char* const compName,
      const U32 maxHistorySize
  ) :
    Fw::PassiveComponentBase(compName)
{

}

ActiveAsyncProductPortsOnlyTesterBase ::
  ~ActiveAsyncProductPortsOnlyTesterBase()
{

}

// ----------------------------------------------------------------------
// Getters for port counts
// ----------------------------------------------------------------------

FwIndexType ActiveAsyncProductPortsOnlyTesterBase ::
  getNum_to_productRecvIn() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_productRecvIn));
}

FwIndexType ActiveAsyncProductPortsOnlyTesterBase ::
  getNum_from_productRequestOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_productRequestOut));
}

FwIndexType ActiveAsyncProductPortsOnlyTesterBase ::
  getNum_from_productSendOut() const
{
  return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_productSendOut));
}

// ----------------------------------------------------------------------
// Connection status queries for to ports
// ----------------------------------------------------------------------

bool ActiveAsyncProductPortsOnlyTesterBase ::
  isConnected_to_productRecvIn(FwIndexType portNum)
{
  FW_ASSERT(
    (0 <= portNum) && (portNum < this->getNum_to_productRecvIn()),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_productRecvIn[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Dispatching helper functions
// ----------------------------------------------------------------------

ActiveAsyncProductPortsOnlyComponentBase::MsgDispatchStatus ActiveAsyncProductPortsOnlyTesterBase ::
  dispatchOne(ActiveAsyncProductPortsOnlyComponentBase& component)
{
      // Dispatch one message returning status
      return component.doDispatch();
}

ActiveAsyncProductPortsOnlyComponentBase::MsgDispatchStatus ActiveAsyncProductPortsOnlyTesterBase ::
  dispatchCurrentMessages(ActiveAsyncProductPortsOnlyComponentBase& component)
{
      // Dispatch all current messages unless ERROR or EXIT occur
      const FwSizeType currentMessageCount = component.m_queue.getMessagesAvailable();
      ActiveAsyncProductPortsOnlyComponentBase::MsgDispatchStatus messageStatus = ActiveAsyncProductPortsOnlyComponentBase::MsgDispatchStatus::MSG_DISPATCH_EMPTY;
      for (FwSizeType i = 0; i < currentMessageCount; i++) {
          messageStatus = component.doDispatch();
          if (messageStatus != ActiveAsyncProductPortsOnlyComponentBase::MSG_DISPATCH_OK) {
              break;
          }
      }
      return messageStatus;
}
