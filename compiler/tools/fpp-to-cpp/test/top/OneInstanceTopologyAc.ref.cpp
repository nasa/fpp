// ======================================================================
// \title  OneInstanceTopologyAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for OneInstance topology
// ======================================================================

#include "OneInstanceTopologyAc.hpp"

// ----------------------------------------------------------------------
// Component instances
// ----------------------------------------------------------------------

namespace M {

  C c1(FW_OPTIONAL_NAME("c1"));

}

namespace M {

  // ----------------------------------------------------------------------
  // Helper functions
  // ----------------------------------------------------------------------

  void initComponents(const TopologyState& state) {
    M::c1.init(InstanceIds::M_c1);
  }

  void configComponents(const TopologyState& state) {
    // Nothing to do
  }

  void setBaseIds() {
    M::c1.setIdBase(BaseIds::M_c1);
  }

  void connectComponents() {
    // Nothing to do
  }

  void regCommands() {
    // Nothing to do
  }

  void readParameters() {
    // Nothing to do
  }

  void loadParameters() {
    // Nothing to do
  }

  void startTasks(const TopologyState& state) {
    // Nothing to do
  }

  void stopTasks(const TopologyState& state) {
    // Nothing to do
  }

  void freeThreads(const TopologyState& state) {
    // Nothing to do
  }

  void tearDownComponents(const TopologyState& state) {
    // Nothing to do
  }

  // ----------------------------------------------------------------------
  // Setup and teardown functions
  // ----------------------------------------------------------------------

  void setup(const TopologyState& state) {
    initComponents(state);
    configComponents(state);
    setBaseIds();
    connectComponents();
    regCommands();
    readParameters();
    loadParameters();
    startTasks(state);
  }

  void teardown(const TopologyState& state) {
    stopTasks(state);
    freeThreads(state);
    tearDownComponents(state);
  }

}

#if FW_DIRECT_PORT_CALLS

// ----------------------------------------------------------------------
// Topology-dependent component implementation
// ----------------------------------------------------------------------


bool CComponentBase::isConnected_timeGetOut_OutputPort(FwIndexType portNum) const {
  FW_ASSERT(
    (0 <= portNum) && (portNum < NUM_TIMEGETOUT_OUTPUT_PORTS),
    static_cast<FwAssertArgType>(portNum),
    static_cast<FwAssertArgType>(NUM_TIMEGETOUT_OUTPUT_PORTS)
  );
  bool result = false;
  const auto instance = this->getInstance();
  switch (instance) {
    default:
      FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
      break;
  }
  return result;
}

bool CComponentBase::isConnected_tlmOut_OutputPort(FwIndexType portNum) const {
  FW_ASSERT(
    (0 <= portNum) && (portNum < NUM_TLMOUT_OUTPUT_PORTS),
    static_cast<FwAssertArgType>(portNum),
    static_cast<FwAssertArgType>(NUM_TLMOUT_OUTPUT_PORTS)
  );
  bool result = false;
  const auto instance = this->getInstance();
  switch (instance) {
    default:
      FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
      break;
  }
  return result;
}

void CComponentBase::timeGetOut_out(FwIndexType portNum) const {
  FW_ASSERT(
    (0 <= portNum) && (portNum < NUM_TIMEGETOUT_OUTPUT_PORTS),
    static_cast<FwAssertArgType>(portNum),
    static_cast<FwAssertArgType>(NUM_TIMEGETOUT_OUTPUT_PORTS)
  );
  const auto instance = this->getInstance();
  switch (instance) {
    default:
      FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
      break;
  }
}

void CComponentBase::tlmOut_out(FwIndexType portNum) const {
  FW_ASSERT(
    (0 <= portNum) && (portNum < NUM_TLMOUT_OUTPUT_PORTS),
    static_cast<FwAssertArgType>(portNum),
    static_cast<FwAssertArgType>(NUM_TLMOUT_OUTPUT_PORTS)
  );
  const auto instance = this->getInstance();
  switch (instance) {
    default:
      FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
      break;
  }
}


#endif
