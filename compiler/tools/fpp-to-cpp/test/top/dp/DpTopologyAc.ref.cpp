// ======================================================================
// \title  DpTopologyAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for Dp topology
// ======================================================================

#include "DpTopologyAc.hpp"

// ----------------------------------------------------------------------
// Component instances
// ----------------------------------------------------------------------

namespace M {

  M::C c1(FW_OPTIONAL_NAME("c1"));

}

namespace M {

  M::C c2(FW_OPTIONAL_NAME("c2"));

}

namespace M {

  M::DpManager dpManager(FW_OPTIONAL_NAME("dpManager"));

}

namespace M {

  M::NoDp noDp(FW_OPTIONAL_NAME("noDp"));

}

namespace M {

  // ----------------------------------------------------------------------
  // Helper functions
  // ----------------------------------------------------------------------

  void initComponents(const TopologyState& state) {
    M::c1.init(QueueSizes::M_c1, InstanceIds::M_c1);
    M::c2.init(QueueSizes::M_c2, InstanceIds::M_c2);
    M::dpManager.init(QueueSizes::M_dpManager, InstanceIds::M_dpManager);
    M::noDp.init(InstanceIds::M_noDp);
  }

  void configComponents(const TopologyState& state) {
    // Nothing to do
  }

  void setBaseIds() {
    M::c1.setIdBase(BaseIds::M_c1);
    M::c2.setIdBase(BaseIds::M_c2);
    M::dpManager.setIdBase(BaseIds::M_dpManager);
    M::noDp.setIdBase(BaseIds::M_noDp);
  }

  void connectComponents() {

#if !FW_DIRECT_PORT_CALLS

    // Dp
    M::c1.set_productGetOut_OutputPort(
        0,
        M::dpManager.get_productGetIn_InputPort(0)
    );
    M::c1.set_productRequestOut_OutputPort(
        0,
        M::dpManager.get_productRequestIn_InputPort(0)
    );
    M::c1.set_productSendOut_OutputPort(
        0,
        M::dpManager.get_productSendIn_InputPort(0)
    );
    M::dpManager.set_productResponseOut_OutputPort(
        0,
        M::c1.get_productRecvIn_InputPort(0)
    );

#endif

  }

  void regCommands() {
    // Nothing to do
  }

  void readParameters() {
    // Nothing to do
  }

  void loadParameters() {
    // Nothing to do
  }

  void startTasks(const TopologyState& state) {
    // Nothing to do
  }

  void stopTasks(const TopologyState& state) {
    // Nothing to do
  }

  void freeThreads(const TopologyState& state) {
    // Nothing to do
  }

  void tearDownComponents(const TopologyState& state) {
    // Nothing to do
  }

  // ----------------------------------------------------------------------
  // Setup and teardown functions
  // ----------------------------------------------------------------------

  void setup(const TopologyState& state) {
    initComponents(state);
    configComponents(state);
    setBaseIds();
    connectComponents();
    regCommands();
    readParameters();
    loadParameters();
    startTasks(state);
  }

  void teardown(const TopologyState& state) {
    stopTasks(state);
    freeThreads(state);
    tearDownComponents(state);
  }

}

#if FW_DIRECT_PORT_CALLS

// ----------------------------------------------------------------------
// Topology-dependent component implementation
// ----------------------------------------------------------------------

namespace M {

  bool CComponentBase::isConnected_productGetOut_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PRODUCTGETOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PRODUCTGETOUT_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::M::InstanceIds::M_c1:
        switch (portNum) {
          case 0:
            result = true;
            break;
          default:
            break;
        }
        break;
      case ::M::InstanceIds::M_c2:
        switch (portNum) {
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  bool CComponentBase::isConnected_productRequestOut_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PRODUCTREQUESTOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PRODUCTREQUESTOUT_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::M::InstanceIds::M_c1:
        switch (portNum) {
          case 0:
            result = true;
            break;
          default:
            break;
        }
        break;
      case ::M::InstanceIds::M_c2:
        switch (portNum) {
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  bool CComponentBase::isConnected_productSendOut_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PRODUCTSENDOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PRODUCTSENDOUT_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::M::InstanceIds::M_c1:
        switch (portNum) {
          case 0:
            result = true;
            break;
          default:
            break;
        }
        break;
      case ::M::InstanceIds::M_c2:
        switch (portNum) {
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  bool CComponentBase::isConnected_timeGetOut_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_TIMEGETOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_TIMEGETOUT_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::M::InstanceIds::M_c1:
        switch (portNum) {
          default:
            break;
        }
        break;
      case ::M::InstanceIds::M_c2:
        switch (portNum) {
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  Fw::Success CComponentBase::productGetOut_out(
      FwIndexType portNum,
      FwDpIdType id,
      FwSizeType dataSize,
      Fw::Buffer& buffer
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PRODUCTGETOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PRODUCTGETOUT_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    Fw::Success _result = {};
    switch (instance) {
      case ::M::InstanceIds::M_c1:
        switch (portNum) {
          case 0:
            _result = M::dpManager.productGetIn_handlerBase(
              0,
              id,
              dataSize,
              buffer
            );
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      case ::M::InstanceIds::M_c2:
        switch (portNum) {
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return _result;
  }

  void CComponentBase::productRequestOut_out(
      FwIndexType portNum,
      FwDpIdType id,
      FwSizeType dataSize
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PRODUCTREQUESTOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PRODUCTREQUESTOUT_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    switch (instance) {
      case ::M::InstanceIds::M_c1:
        switch (portNum) {
          case 0:
            M::dpManager.productRequestIn_handlerBase(
              0,
              id,
              dataSize
            );
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      case ::M::InstanceIds::M_c2:
        switch (portNum) {
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
  }

  void CComponentBase::productSendOut_out(
      FwIndexType portNum,
      FwDpIdType id,
      const Fw::Buffer& buffer
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PRODUCTSENDOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PRODUCTSENDOUT_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    switch (instance) {
      case ::M::InstanceIds::M_c1:
        switch (portNum) {
          case 0:
            M::dpManager.productSendIn_handlerBase(
              0,
              id,
              buffer
            );
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      case ::M::InstanceIds::M_c2:
        switch (portNum) {
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
  }

  void CComponentBase::timeGetOut_out(
      FwIndexType portNum,
      Fw::Time& time
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_TIMEGETOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_TIMEGETOUT_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    switch (instance) {
      case ::M::InstanceIds::M_c1:
        switch (portNum) {
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      case ::M::InstanceIds::M_c2:
        switch (portNum) {
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
  }

}

namespace M {

  bool DpManagerComponentBase::isConnected_productResponseOut_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PRODUCTRESPONSEOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PRODUCTRESPONSEOUT_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::M::InstanceIds::M_dpManager:
        switch (portNum) {
          case 0:
            result = true;
            break;
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  void DpManagerComponentBase::productResponseOut_out(
      FwIndexType portNum,
      FwDpIdType id,
      const Fw::Buffer& buffer,
      const Fw::Success& status
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PRODUCTRESPONSEOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PRODUCTRESPONSEOUT_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    switch (instance) {
      case ::M::InstanceIds::M_dpManager:
        switch (portNum) {
          case 0:
            M::c1.productRecvIn_handlerBase(
              0,
              id,
              buffer,
              status
            );
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
  }

}

namespace M {

  bool NoDpComponentBase::isConnected_productGetOut_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PRODUCTGETOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PRODUCTGETOUT_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::M::InstanceIds::M_noDp:
        switch (portNum) {
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  bool NoDpComponentBase::isConnected_productSendOut_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PRODUCTSENDOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PRODUCTSENDOUT_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::M::InstanceIds::M_noDp:
        switch (portNum) {
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  bool NoDpComponentBase::isConnected_timeGetOut_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_TIMEGETOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_TIMEGETOUT_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::M::InstanceIds::M_noDp:
        switch (portNum) {
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  void NoDpComponentBase::timeGetOut_out(
      FwIndexType portNum,
      Fw::Time& time
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_TIMEGETOUT_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_TIMEGETOUT_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    switch (instance) {
      case ::M::InstanceIds::M_noDp:
        switch (portNum) {
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
  }

}

#endif
