// ======================================================================
// \title  TypedPortsActiveTopologyAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for TypedPortsActive topology
// ======================================================================

#include "TypedPortsActiveTopologyAc.hpp"

// ----------------------------------------------------------------------
// Component instances
// ----------------------------------------------------------------------

namespace TypedPortsActive {

  TypedPortsActive::Receiver receiver(FW_OPTIONAL_NAME("receiver"));

}

namespace TypedPortsActive {

  TypedPortsActive::Sender sender(FW_OPTIONAL_NAME("sender"));

}

namespace TypedPortsActive {

  // ----------------------------------------------------------------------
  // Helper functions
  // ----------------------------------------------------------------------

  void initComponents(const TopologyState& state) {
    TypedPortsActive::receiver.init(QueueSizes::TypedPortsActive_receiver, InstanceIds::TypedPortsActive_receiver);
    TypedPortsActive::sender.init(InstanceIds::TypedPortsActive_sender);
  }

  void configComponents(const TopologyState& state) {
    // Nothing to do
  }

  void setBaseIds() {
    TypedPortsActive::sender.setIdBase(BaseIds::TypedPortsActive_sender);
    TypedPortsActive::receiver.setIdBase(BaseIds::TypedPortsActive_receiver);
  }

  void connectComponents() {

#ifndef FW_DIRECT_PORT_CALLS

    // C
    TypedPortsActive::sender.set_p1_OutputPort(
        0,
        TypedPortsActive::receiver.get_p1_InputPort(1)
    );
    TypedPortsActive::sender.set_p1_OutputPort(
        1,
        TypedPortsActive::receiver.get_p1_InputPort(0)
    );
    TypedPortsActive::sender.set_p2_OutputPort(
        0,
        TypedPortsActive::receiver.get_p2_InputPort(1)
    );
    TypedPortsActive::sender.set_p2_OutputPort(
        1,
        TypedPortsActive::receiver.get_p2_InputPort(0)
    );
    TypedPortsActive::sender.set_p3_OutputPort(
        0,
        TypedPortsActive::receiver.get_p3_InputPort(0)
    );
    TypedPortsActive::sender.set_p3_OutputPort(
        1,
        TypedPortsActive::receiver.get_p3_InputPort(1)
    );
    TypedPortsActive::sender.set_p4_OutputPort(
        0,
        TypedPortsActive::receiver.get_p4_InputPort(0)
    );
    TypedPortsActive::sender.set_p4_OutputPort(
        1,
        TypedPortsActive::receiver.get_p4_InputPort(0)
    );
    TypedPortsActive::sender.set_p5_OutputPort(
        0,
        TypedPortsActive::receiver.get_p5_InputPort(0)
    );
    TypedPortsActive::sender.set_p5_OutputPort(
        1,
        TypedPortsActive::receiver.get_p5_InputPort(0)
    );
    TypedPortsActive::sender.set_p6_OutputPort(
        0,
        TypedPortsActive::receiver.get_p6_InputPort(0)
    );
    TypedPortsActive::sender.set_p6_OutputPort(
        1,
        TypedPortsActive::receiver.get_p6_InputPort(0)
    );
    TypedPortsActive::sender.set_p7_OutputPort(
        0,
        TypedPortsActive::receiver.get_p7_InputPort(0)
    );
    TypedPortsActive::sender.set_p7_OutputPort(
        1,
        TypedPortsActive::receiver.get_p7_InputPort(0)
    );
    TypedPortsActive::sender.set_p8_OutputPort(
        0,
        TypedPortsActive::receiver.get_p8_InputPort(0)
    );
    TypedPortsActive::sender.set_p8_OutputPort(
        1,
        TypedPortsActive::receiver.get_p8_InputPort(0)
    );

#endif

  }

  void regCommands() {
    // Nothing to do
  }

  void readParameters() {
    // Nothing to do
  }

  void loadParameters() {
    // Nothing to do
  }

  void startTasks(const TopologyState& state) {
    TypedPortsActive::receiver.start(
      Os::Task::TASK_PRIORITY_DEFAULT, // Default priority
      static_cast<Os::Task::ParamType>(StackSizes::TypedPortsActive_receiver),
      Os::Task::TASK_DEFAULT, // Default CPU
      static_cast<Os::Task::ParamType>(TaskIds::TypedPortsActive_receiver)
    );
  }

  void stopTasks(const TopologyState& state) {
    TypedPortsActive::receiver.exit();
  }

  void freeThreads(const TopologyState& state) {
    (void) TypedPortsActive::receiver.ActiveComponentBase::join();
  }

  void tearDownComponents(const TopologyState& state) {
    // Nothing to do
  }

  // ----------------------------------------------------------------------
  // Setup and teardown functions
  // ----------------------------------------------------------------------

  void setup(const TopologyState& state) {
    initComponents(state);
    configComponents(state);
    setBaseIds();
    connectComponents();
    regCommands();
    readParameters();
    loadParameters();
    startTasks(state);
  }

  void teardown(const TopologyState& state) {
    stopTasks(state);
    freeThreads(state);
    tearDownComponents(state);
  }

}

#if FW_DIRECT_PORT_CALLS

// ----------------------------------------------------------------------
// Topology-dependent component implementation
// ----------------------------------------------------------------------

namespace TypedPortsActive {

  bool SenderComponentBase::isConnected_p1_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P1_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P1_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            result = true;
            break;
          case 1:
            result = true;
            break;
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  bool SenderComponentBase::isConnected_p2_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P2_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P2_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            result = true;
            break;
          case 1:
            result = true;
            break;
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  bool SenderComponentBase::isConnected_p3_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P3_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P3_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            result = true;
            break;
          case 1:
            result = true;
            break;
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  bool SenderComponentBase::isConnected_p4_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P4_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P4_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            result = true;
            break;
          case 1:
            result = true;
            break;
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  bool SenderComponentBase::isConnected_p5_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P5_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P5_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            result = true;
            break;
          case 1:
            result = true;
            break;
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  bool SenderComponentBase::isConnected_p6_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P6_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P6_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            result = true;
            break;
          case 1:
            result = true;
            break;
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  bool SenderComponentBase::isConnected_p7_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P7_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P7_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            result = true;
            break;
          case 1:
            result = true;
            break;
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  bool SenderComponentBase::isConnected_p8_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P8_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P8_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            result = true;
            break;
          case 1:
            result = true;
            break;
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  void SenderComponentBase::p1_out(
      FwIndexType portNum,
      U32 x1,
      F32 x2,
      bool x3,
      const Fw::StringBase& x4,
      const TypedPortsActive::A& x5,
      const TypedPortsActive::E& x6,
      const TypedPortsActive::S& x7
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P1_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P1_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            TypedPortsActive::receiver.p1_handlerBase(
              1,
              x1,
              x2,
              x3,
              x4,
              x5,
              x6,
              x7
            );
            break;
          case 1:
            TypedPortsActive::receiver.p1_handlerBase(
              0,
              x1,
              x2,
              x3,
              x4,
              x5,
              x6,
              x7
            );
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
  }

  U32 SenderComponentBase::p2_out(
      FwIndexType portNum,
      U32 x
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P2_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P2_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    U32 _result = {};
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            _result = TypedPortsActive::receiver.p2_handlerBase(
              1,
              x
            );
            break;
          case 1:
            _result = TypedPortsActive::receiver.p2_handlerBase(
              0,
              x
            );
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return _result;
  }

  F32 SenderComponentBase::p3_out(
      FwIndexType portNum,
      F32 x
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P3_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P3_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    F32 _result = {};
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            _result = TypedPortsActive::receiver.p3_handlerBase(
              0,
              x
            );
            break;
          case 1:
            _result = TypedPortsActive::receiver.p3_handlerBase(
              1,
              x
            );
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return _result;
  }

  bool SenderComponentBase::p4_out(
      FwIndexType portNum,
      bool x
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P4_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P4_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    bool _result = {};
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            _result = TypedPortsActive::receiver.p4_handlerBase(
              0,
              x
            );
            break;
          case 1:
            _result = TypedPortsActive::receiver.p4_handlerBase(
              0,
              x
            );
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return _result;
  }

  Fw::String SenderComponentBase::p5_out(
      FwIndexType portNum,
      const Fw::StringBase& x
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P5_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P5_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    Fw::String _result = {};
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            _result = TypedPortsActive::receiver.p5_handlerBase(
              0,
              x
            );
            break;
          case 1:
            _result = TypedPortsActive::receiver.p5_handlerBase(
              0,
              x
            );
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return _result;
  }

  TypedPortsActive::A SenderComponentBase::p6_out(
      FwIndexType portNum,
      const TypedPortsActive::A& x
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P6_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P6_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    TypedPortsActive::A _result = {};
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            _result = TypedPortsActive::receiver.p6_handlerBase(
              0,
              x
            );
            break;
          case 1:
            _result = TypedPortsActive::receiver.p6_handlerBase(
              0,
              x
            );
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return _result;
  }

  TypedPortsActive::E SenderComponentBase::p7_out(
      FwIndexType portNum,
      const TypedPortsActive::E& x
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P7_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P7_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    TypedPortsActive::E _result = {};
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            _result = TypedPortsActive::receiver.p7_handlerBase(
              0,
              x
            );
            break;
          case 1:
            _result = TypedPortsActive::receiver.p7_handlerBase(
              0,
              x
            );
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return _result;
  }

  TypedPortsActive::S SenderComponentBase::p8_out(
      FwIndexType portNum,
      const TypedPortsActive::S& x
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_P8_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_P8_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    TypedPortsActive::S _result = {};
    switch (instance) {
      case ::TypedPortsActive::InstanceIds::TypedPortsActive_sender:
        switch (portNum) {
          case 0:
            _result = TypedPortsActive::receiver.p8_handlerBase(
              0,
              x
            );
            break;
          case 1:
            _result = TypedPortsActive::receiver.p8_handlerBase(
              0,
              x
            );
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return _result;
  }

}

#endif
