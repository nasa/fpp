// ======================================================================
// \title  SerialPortsPassiveTopologyAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for SerialPortsPassive topology
// ======================================================================

#include "SerialPortsPassiveTopologyAc.hpp"

// ----------------------------------------------------------------------
// Component instances
// ----------------------------------------------------------------------

namespace SerialPortsPassive {

  SerialPortsPassive::Receiver receiver(FW_OPTIONAL_NAME("receiver"));

}

namespace SerialPortsPassive {

  SerialPortsPassive::Sender sender(FW_OPTIONAL_NAME("sender"));

}

namespace SerialPortsPassive {

  // ----------------------------------------------------------------------
  // Helper functions
  // ----------------------------------------------------------------------

  void initComponents(const TopologyState& state) {
    SerialPortsPassive::receiver.init(InstanceIds::SerialPortsPassive_receiver);
    SerialPortsPassive::sender.init(InstanceIds::SerialPortsPassive_sender);
  }

  void configComponents(const TopologyState& state) {
    // Nothing to do
  }

  void setBaseIds() {
    SerialPortsPassive::sender.setIdBase(BaseIds::SerialPortsPassive_sender);
    SerialPortsPassive::receiver.setIdBase(BaseIds::SerialPortsPassive_receiver);
  }

  void connectComponents() {

#if !FW_DIRECT_PORT_CALLS

    // SerialToTyped
    SerialPortsPassive::sender.set_pSerial_OutputPort(
        0,
        SerialPortsPassive::receiver.get_pTypedSync_InputPort(0)
    );
    SerialPortsPassive::sender.set_pSerial_OutputPort(
        1,
        SerialPortsPassive::receiver.get_pTypedSync_InputPort(1)
    );
    SerialPortsPassive::sender.set_pSerial_OutputPort(
        2,
        SerialPortsPassive::receiver.get_pTypedGuarded_InputPort(0)
    );
    SerialPortsPassive::sender.set_pSerial_OutputPort(
        3,
        SerialPortsPassive::receiver.get_pTypedGuarded_InputPort(1)
    );

    // TypedToSerial
    SerialPortsPassive::sender.set_pTyped_OutputPort(
        0,
        SerialPortsPassive::receiver.get_pSerialSync_InputPort(0)
    );
    SerialPortsPassive::sender.set_pTyped_OutputPort(
        1,
        SerialPortsPassive::receiver.get_pSerialSync_InputPort(1)
    );
    SerialPortsPassive::sender.set_pTyped_OutputPort(
        2,
        SerialPortsPassive::receiver.get_pSerialGuarded_InputPort(0)
    );
    SerialPortsPassive::sender.set_pTyped_OutputPort(
        3,
        SerialPortsPassive::receiver.get_pSerialGuarded_InputPort(1)
    );

#endif

  }

  void regCommands() {
    // Nothing to do
  }

  void readParameters() {
    // Nothing to do
  }

  void loadParameters() {
    // Nothing to do
  }

  void startTasks(const TopologyState& state) {
    // Nothing to do
  }

  void stopTasks(const TopologyState& state) {
    // Nothing to do
  }

  void freeThreads(const TopologyState& state) {
    // Nothing to do
  }

  void tearDownComponents(const TopologyState& state) {
    // Nothing to do
  }

  // ----------------------------------------------------------------------
  // Setup and teardown functions
  // ----------------------------------------------------------------------

  void setup(const TopologyState& state) {
    initComponents(state);
    configComponents(state);
    setBaseIds();
    connectComponents();
    regCommands();
    readParameters();
    loadParameters();
    startTasks(state);
  }

  void teardown(const TopologyState& state) {
    stopTasks(state);
    freeThreads(state);
    tearDownComponents(state);
  }

}

#if FW_DIRECT_PORT_CALLS

// ----------------------------------------------------------------------
// Topology-dependent component implementation
// ----------------------------------------------------------------------

namespace SerialPortsPassive {

  bool SenderComponentBase::isConnected_pSerial_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PSERIAL_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PSERIAL_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::SerialPortsPassive::InstanceIds::SerialPortsPassive_sender:
        switch (portNum) {
          case 0:
            result = true;
            break;
          case 1:
            result = true;
            break;
          case 2:
            result = true;
            break;
          case 3:
            result = true;
            break;
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  bool SenderComponentBase::isConnected_pTyped_OutputPort(FwIndexType portNum) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PTYPED_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PTYPED_OUTPUT_PORTS)
    );
    bool result = false;
    const auto instance = this->getInstance();
    switch (instance) {
      case ::SerialPortsPassive::InstanceIds::SerialPortsPassive_sender:
        switch (portNum) {
          case 0:
            result = true;
            break;
          case 1:
            result = true;
            break;
          case 2:
            result = true;
            break;
          case 3:
            result = true;
            break;
          default:
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return result;
  }

  Fw::SerializeStatus SenderComponentBase::pSerial_out(
      FwIndexType portNum,
      Fw::LinearBufferBase& buffer
  ) {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PSERIAL_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PSERIAL_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    Fw::SerializeStatus _result = {};
    switch (instance) {
      case ::SerialPortsPassive::InstanceIds::SerialPortsPassive_sender:
        switch (portNum) {
          case 0:
            // TODO: Serial to typed connection
            FW_ASSERT(0);
            break;
          case 1:
            // TODO: Serial to typed connection
            FW_ASSERT(0);
            break;
          case 2:
            // TODO: Serial to typed connection
            FW_ASSERT(0);
            break;
          case 3:
            // TODO: Serial to typed connection
            FW_ASSERT(0);
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
    return _result;
  }

  void SenderComponentBase::pTyped_out(
      FwIndexType portNum,
      U32 x1,
      F32 x2,
      bool x3,
      const Fw::StringBase& x4,
      const SerialPortsPassive::A& x5,
      const SerialPortsPassive::E& x6,
      const SerialPortsPassive::S& x7
  ) const {
    FW_ASSERT(
      (0 <= portNum) && (portNum < NUM_PTYPED_OUTPUT_PORTS),
      static_cast<FwAssertArgType>(portNum),
      static_cast<FwAssertArgType>(NUM_PTYPED_OUTPUT_PORTS)
    );
    const auto instance = this->getInstance();
    switch (instance) {
      case ::SerialPortsPassive::InstanceIds::SerialPortsPassive_sender:
        switch (portNum) {
          case 0:
            // TODO: Typed to serial connection
            FW_ASSERT(0);
            break;
          case 1:
            // TODO: Typed to serial connection
            FW_ASSERT(0);
            break;
          case 2:
            // TODO: Typed to serial connection
            FW_ASSERT(0);
            break;
          case 3:
            // TODO: Typed to serial connection
            FW_ASSERT(0);
            break;
          default:
            FW_ASSERT(0, static_cast<FwAssertArgType>(portNum));
            break;
        }
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(instance));
        break;
    }
  }

}

#endif
