=== Module Template Definitions

A *module template definition* defines an FPP template that can
hold reduce FPP model code duplication.
A module template is an FPP construct with definitions inside
parameterized with a set of types, constants, and interfaces that
can be expanded into a module.

==== Syntax

`template`
<<Lexical-Elements_Identifiers,_identifier_>>
`(` _parameter-sequence_ `)` `{`
_module-member-sequence_
`}`

The _identifier_ specifies the name of the template.

_parameter-sequence_ is a
<<Template-Parameter-Lists,template parameter sequence>> in
which each element is a *parameter*, and
the terminating punctuation is a comma.

_module-member-sequence_ is an
<<Element-Sequences,element sequence>> in
which each element is a <<Definitions_Module-Definitions_Syntax,
module member>>, and the terminating punctuation is a semicolon.

==== Semantics

_Template_ definitions differ from other definitions in that symbols
defined inside a template are not symbols added to the global symbol
namespace. All symbols defined inside a template (including it's parameters)
are _local_ to that template. This means that the definitions _inside_
the template definition cannot be refered to from outside the template
definition.

A template can be expanded through a <<Specifiers_Template-Expansion-Specifiers,
template expansion specifier>>. When a template is expanded,
the set of parameters are applied to the template and the newly concrete definitions
inside the template are placed into the scope of the expansion specifier.

Because a template needs to apply its parameters during instantiation,
analysis inside a template is limited since parameters are variable and
therefore a full analysis cannot be performed.

A template definition _D_ must be resolvable to a template _T_, according to the
following algorithm:

. Recursively resolve any template definitions inside of _D_.

. Check that _parameter-sequence_ does not have any duplicate names.

. Perform the following analysis on the inside of the template:

.. Enter symbols. Symbols entered in the template definition will
not effect analysis outside the template definition.

.. Construct implied use map.

.. Check uses. Uses inside the template definition will be promoted to
<<Scoping-of-Names_Fully-Qualified-Identifiers,fully qualified names>>
after they are resolved.

.. Check use-definition cycles.

.. Check type uses. All type parameters are assumed to be
<<Types_Abstract-Types,abstract types>> during this phase of analysis.

.. Check expression types. All type parameters are assumed to be
<<Types_Abstract-Types,abstract types>> during this phase of analysis.

==== Example

[source,fpp]
----
template MT(
    constant base_id: U32,
    interface comDriver: ByteStreamDriver
) {
    instance comStub: Svc.ComStub base id \
        base_id + 0x0800

    toplogy T {
        instance comStub

        # TODO(tumbar) What is this? Do we need it
        # (do we need `instance comStub`?)
        instance comDriver

        # Connect to the driver from the parameter list
        connections Downlink {
            # ComStub <-> ComDriver
            comStub.drvSendOut      -> comDriver.$send
            comDriver.sendReturnOut -> comStub.drvSendReturnIn
            comDriver.ready         -> comStub.drvConnected
        }
    }
}

instance comDriver: Drv.TcpClient base id 0x10300000 + 0x100

module M {
    # Instantiate template with topology inside
    # Pass an external component into the topology
    expand MT(0x100, comDriver)
}

topology T {
    import M.T # Imports the instantiated template topology
    import MT.T # Error: Cannot reference definitions inside a _template_

    instance comDriver
}
----
