=== Module Template Definitions

A *module template definition* defines an FPP template that can
help reduce FPP model code duplication.
A module template is an FPP construct with definitions inside
parameterized with a set of types, constants, and interfaces that
can be expanded into a module.

==== Syntax

`template`
<<Lexical-Elements_Identifiers,_identifier_>>
`(` _parameter-sequence_ `)` `{`
_module-member-sequence_
`}`

The _identifier_ specifies the name of the template.

_parameter-sequence_ is an
<<Element-Sequences,element sequence>> in which the
elements are one of the following and the terminating punctuation
is a comma:

* `constant` <<Lexical-Elements_Identifiers,_identifier_>> `:` <<Type-Names,_type-name_>>
* `interface` <<Lexical-Elements_Identifiers,_identifier_>> `:` <<Scoping-of-Names_Qualified-Identifiers,_qual-ident_>>
* `type` <<Lexical-Elements_Identifiers,_identifier_>>

_module-member-sequence_ is an
<<Element-Sequences,element sequence>> in
which each element is a <<Definitions_Module-Definitions_Syntax,
module member>>, and the terminating punctuation is a semicolon.

. Note that <<Definitions_Module-Template-Definitions,template definition>> defined
as members to template definitions will cause an error.

==== Semantics

Module template definitions define parameterized FPP syntax. A template can be expanded
through a <<Specifiers_Template-Expansion-Specifiers,
template expansion specifier>>.

Templates are expanded with the following algorithm:

. For each template expansion specifier _E_:

.. Create a new empty scope _S_ for _E_.

.. Resolve the module template definition _T_ which _E_
<<Scoping-of-Names_Resolution-of-Qualified-Identifiers,refers to>>.

.. Enter template parameters of _T_ into _S_ with concrete values given in _E_.

.. Duplicate the syntax contained in _T_ into syntax _X_ contained under _E_.

.. Enter symbols discovered in _X_ into _S_.

.. For each template expansion specifier in _X_, apply these rules recursively.

With templates expanded, 

==== Example

[source,fpp]
----
template MT(
    constant base_id: U32,
    interface comDriver: ByteStreamDriver
) {
    instance comStub: Svc.ComStub base id \
        base_id + 0x0800

    toplogy T {
        instance comStub

        # TODO(tumbar) What is this? Do we need it
        # (do we need `instance comStub`?)
        instance comDriver

        # Connect to the driver from the parameter list
        connections Downlink {
            # ComStub <-> ComDriver
            comStub.drvSendOut      -> comDriver.$send
            comDriver.sendReturnOut -> comStub.drvSendReturnIn
            comDriver.ready         -> comStub.drvConnected
        }
    }
}

instance comDriver: Drv.TcpClient base id 0x10300000 + 0x100

module M {
    # Instantiate template with topology inside
    # Pass an external component into the topology
    expand MT(constant 0x100, interface comDriver)
}

topology T {
    import M.T # Imports the instantiated template topology
    import MT.T # Error: Cannot reference definitions inside a _template_

    instance comDriver
}
----
