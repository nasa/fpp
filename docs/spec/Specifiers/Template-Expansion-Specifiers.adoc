=== Template Expansion Specifiers

A *template expansion specifier* takes a
<<Definitions_Module-Template-Definitions,template>> and
applies a set of values to its parameters
to generate concrete definitions.

=== Syntax

`expand`
<<Scoping-of-Names_Qualified-Identifiers,_qual-ident>>
`(` _parameter-sequence_ `)`

_parameter-sequence_ is an
<<Element-Sequences,element sequence>> in
which each element is one of the following:

. `constant` <<Expressions,_expression_>>

. `type` <<Type-Names,_type-name_>>

. `interface` <<Scoping-of-Names_Qualified-Identifiers,_qual-ident_>>

=== Semantics

. The qualified identifier must
<<Scoping-of-Names_Resolution-of-Qualified-Identifiers,refer to>>
a
<<Definitions_Module-Template-Definitions,module template definition _T_>>.

. The parameter sequence is the set of parameters that map to
the template parameters of the template _T_.

==== Checking parameter types

For each template parameter _P_ and its corresponding parameter definition _D_ in _T_:

. If _P_ is `constant`, _D_ must be `constant and the expression is
<<Type-Checking_Type-Conversion,converted to>> the type specified in _D_.

. If _P_ is `type`, _D_ must also be a `type` parameter.

. If _P_ is `interface`, _D_ must also be `interface and the value must be a
<<Scoping-of-Names_Qualified-Identifiers,_qualified-identifier_>> of a
<<Ports_Port-Interface-Instances,port interface instance>>
which is a <<Ports_Sub-Interfaces,sub-interface>> to _I_

=== Examples

[source,fpp]
----
port P

@ A basic template parameterizing an interface port count
template Templ(
  constant numPorts: U32
) {
  interface I {
    output port N[numPorts]: P
  }

  passive component C {
    import I
  }
}

@ Instantiate the template giving the parameters concrete values
module M {
  expand Templ(constant 30)
}
# M.I => interface { output port N[30]: P }
# M.C => passive component { output port N[30]: P }
----
