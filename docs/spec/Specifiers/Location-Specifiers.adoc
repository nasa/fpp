=== Location Specifiers

A *location specifier* specifies the
<<Translation-Units-and-Models_Locations,location>>
of a <<Definitions,definition>>.

==== Syntax

A location specifier is one of the following:

* A *component instance location specifier* `locate` `instance`
<<Scoping-of-Names_Qualified-Identifiers,_qual-ident_>> `at`
<<Expressions_String-Literals,_string-literal_>>

* A *component location specifier* `locate` `component`
<<Scoping-of-Names_Qualified-Identifiers,_qual-ident_>> `at`
<<Expressions_String-Literals,_string-literal_>>

* A *constant location specifier* `locate`
_[_
`dictionary`
_]_
`constant`
<<Scoping-of-Names_Qualified-Identifiers,_qual-ident_>> `at`
<<Expressions_String-Literals,_string-literal_>>

* A *port interface location specifier* `locate`
`interface`
<<Scoping-of-Names_Qualified-Identifiers,_qual-ident_>> `at`
<<Expressions_String-Literals,_string-literal_>>

* A *port location specifier* `locate` `port`
<<Scoping-of-Names_Qualified-Identifiers,_qual-ident_>> `at`
<<Expressions_String-Literals,_string-literal_>>

* A *state machine location specifier* `locate` `state` `machine`
<<Scoping-of-Names_Qualified-Identifiers,_qual-ident_>> `at`
<<Expressions_String-Literals,_string-literal_>>

* A *topology location specifier* `locate` `topology`
<<Scoping-of-Names_Qualified-Identifiers,_qual-ident_>> `at`
<<Expressions_String-Literals,_string-literal_>>

* A *type location specifier* `locate`
_[_
`dictionary`
_]_
`type`
<<Scoping-of-Names_Qualified-Identifiers,_qual-ident_>> `at`
<<Expressions_String-Literals,_string-literal_>>

If the optional keyword `dictionary` appears in a location specifier _S_,
then _S_ is called a *dictionary specifier*.

==== Semantics

A location specifier _S_ with qualified identifier _Q_ must conform
to the following rules:

. _Q_ is resolved like a
<<Definitions-and-Uses_Uses,use>> that refers to a <<Definitions,definition>>
as follows:

.. A component instance location specifier refers to a
<<Definitions_Component-Instance-Definitions,component instance definition>>.

.. A component location specifier refers to a
<<Definitions_Component-Definitions,component definition>>.

.. A constant location specifier refers to a
<<Definitions_Constant-Definitions,constant definition>>.

.. A port interface location specifier refers to a
<<Definitions_Port-Interface-Definitions,port interface definition>>.

.. A port location specifier refers to a
<<Definitions_Port-Definitions,port definition>>.

.. A state machine location specifier refers to a
<<Definitions_State-Machine-Definitions,state machine definition>>.

.. A topology location specifier refers to a
<<Definitions_Topology-Definitions,topology definition>>.

.. A type location specifier refers to an
<<Definitions_Array-Definitions,array definition>>,
<<Definitions_Enum-Definitions,enum definition>>,
<<Definitions_Struct-Definitions,struct definition>>, or
<<Definitions_Abstract-Type-Definitions,abstract type definition>>.

. When a location specifier appears inside a
<<Definitions_Module-Definitions,module definition _M_>>,
_Q_ is implicitly qualified by the
<<Scoping-of-Names_Names-of-Definitions,qualified name>>
of _M_.
This rule allows the resolution to occur during dependency analysis,
before uses have been matched with their definitions.

. _Q_ need not actually refer to any definition.
This rule allows the specification of dependencies for a larger set
of files than the ones involved in a particular analysis
or translation.
If _Q_ does refer to a definition _D_, then _S_
must be a dictionary specifier if _D_ is a
<<Definitions_Dictionary-Definitions,dictionary definition>>;
otherwise it must not be.

. The string literal must specify the path of an FPP source file, relative to the
<<Translation-Units-and-Models_Locations,location>>
of the specifier.
The file must exist.
After resolving
<<Specifiers_Include-Specifiers,include specifiers>>,
the file must contain the definition referred to in the
location specifier.

. Multiple location specifiers for the same definition are allowed in a single
<<Translation-Units-and-Models_Models,model>>, so long as the following
conditions are met:

.. All of the specifiers must be dictionary specifiers, or none of them must
   be.

.. All the specifiers must have the same locations.

==== Examples

*Example 1:*

File `a.fpp` contains the following:

[source,fpp]
----
constant a = 1
----

File `b.fpp` contains the following:

[source,fpp]
----
locate constant a at "a.fpp"
constant b = a
----

When analyzing `b.fpp`, the analyzer knows that the definition of constant
`a` is available in `a.fpp`.

*Example 2:*

File `a.fpp` is as in the previous example.
File `b.fpp` contains the following:

[source,fpp]
----
module M { constant b = 0 }
----

File `c.fpp` contains the following:

[source,fpp]
----
locate constant a at "a.fpp"
module M { locate constant b at "b.fpp" }
----

The first location specifier refers to the constant `a`.
The second location specifier refers to the constant `M.b`.
